/*
 * Smart GWT (GWT for SmartClient)
 * Copyright 2008 and beyond, Isomorphic Software, Inc.
 *
 * Smart GWT is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License version 3
 * as published by the Free Software Foundation.  Smart GWT is also
 * available under typical commercial license terms - see
 * http://smartclient.com/license
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 */
/* sgwtgen */
 
package com.smartgwt.client.widgets.grid;


import com.smartgwt.client.event.*;
import com.smartgwt.client.core.*;
import com.smartgwt.client.types.*;
import com.smartgwt.client.data.*;
import com.smartgwt.client.data.events.*;
import com.smartgwt.client.rpc.*;
import com.smartgwt.client.callbacks.*;
import com.smartgwt.client.tools.*;
import com.smartgwt.client.bean.*;
import com.smartgwt.client.widgets.*;
import com.smartgwt.client.widgets.events.*;
import com.smartgwt.client.widgets.form.*;
import com.smartgwt.client.widgets.form.validator.*;
import com.smartgwt.client.widgets.form.fields.*;
import com.smartgwt.client.widgets.tile.*;
import com.smartgwt.client.widgets.tile.events.*;
import com.smartgwt.client.widgets.grid.*;
import com.smartgwt.client.widgets.grid.events.*;
import com.smartgwt.client.widgets.chart.*;
import com.smartgwt.client.widgets.layout.*;
import com.smartgwt.client.widgets.layout.events.*;
import com.smartgwt.client.widgets.menu.*;
import com.smartgwt.client.widgets.rte.*;
import com.smartgwt.client.widgets.rte.events.*;
import com.smartgwt.client.widgets.ace.*;
import com.smartgwt.client.widgets.ace.events.*;
import com.smartgwt.client.widgets.tab.*;
import com.smartgwt.client.widgets.toolbar.*;
import com.smartgwt.client.widgets.tree.*;
import com.smartgwt.client.widgets.tree.events.*;
import com.smartgwt.client.widgets.tableview.*;
import com.smartgwt.client.widgets.viewer.*;
import com.smartgwt.client.widgets.calendar.*;
import com.smartgwt.client.widgets.calendar.events.*;
import com.smartgwt.client.widgets.cube.*;
import com.smartgwt.client.widgets.drawing.*;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gwt.user.client.ui.Widget;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.user.client.Element;
import com.smartgwt.client.util.*;
import com.smartgwt.client.util.events.*;
import com.smartgwt.client.util.workflow.*;
import com.google.gwt.event.shared.*;
import com.google.gwt.event.shared.HasHandlers;
import com.smartgwt.logicalstructure.core.*;
import com.smartgwt.logicalstructure.widgets.*;
import com.smartgwt.logicalstructure.widgets.drawing.*;
import com.smartgwt.logicalstructure.widgets.plugins.*;
import com.smartgwt.logicalstructure.widgets.form.*;
import com.smartgwt.logicalstructure.widgets.tile.*;
import com.smartgwt.logicalstructure.widgets.grid.*;
import com.smartgwt.logicalstructure.widgets.chart.*;
import com.smartgwt.logicalstructure.widgets.layout.*;
import com.smartgwt.logicalstructure.widgets.menu.*;
import com.smartgwt.logicalstructure.widgets.rte.*;
import com.smartgwt.logicalstructure.widgets.ace.*;
import com.smartgwt.logicalstructure.widgets.tab.*;
import com.smartgwt.logicalstructure.widgets.tableview.*;
import com.smartgwt.logicalstructure.widgets.toolbar.*;
import com.smartgwt.logicalstructure.widgets.tree.*;
import com.smartgwt.logicalstructure.widgets.viewer.*;
import com.smartgwt.logicalstructure.widgets.calendar.*;
import com.smartgwt.logicalstructure.widgets.cube.*;
import com.smartgwt.logicalstructure.widgets.tools.*;

/**
 * A ListGrid is a {@link com.smartgwt.client.widgets.DataBoundComponent} that displays a list of objects in a grid, where
 * each row represents one object and each cell in the row represents one property.
 * @see com.smartgwt.client.docs.Editing Editing overview and related methods
 */
@BeanFactory.FrameworkClass
@BeanFactory.ScClassName("ListGrid")
public class ListGrid extends VLayout implements DataBoundComponent, com.smartgwt.client.widgets.grid.events.HasCellSavedHandlers, com.smartgwt.client.widgets.grid.events.HasCellClickHandlers, com.smartgwt.client.widgets.grid.events.HasCellContextClickHandlers, com.smartgwt.client.widgets.grid.events.HasCellDoubleClickHandlers, com.smartgwt.client.widgets.grid.events.HasCellErrorIconHoverHandlers, com.smartgwt.client.widgets.grid.events.HasCellErrorIconOutHandlers, com.smartgwt.client.widgets.grid.events.HasCellErrorIconOverHandlers, com.smartgwt.client.widgets.grid.events.HasCellHoverHandlers, com.smartgwt.client.widgets.grid.events.HasCellMouseDownHandlers, com.smartgwt.client.widgets.grid.events.HasCellMouseUpHandlers, com.smartgwt.client.widgets.grid.events.HasCellOutHandlers, com.smartgwt.client.widgets.grid.events.HasCellOverHandlers, com.smartgwt.client.widgets.grid.events.HasCellSelectionChangedHandlers, com.smartgwt.client.widgets.grid.events.HasCellValueHoverHandlers, com.smartgwt.client.widgets.grid.events.HasDataArrivedHandlers, com.smartgwt.client.widgets.grid.events.HasDataChangedHandlers, com.smartgwt.client.widgets.grid.events.HasDrawAreaChangedHandlers, com.smartgwt.client.widgets.grid.events.HasEditCompleteHandlers, com.smartgwt.client.widgets.grid.events.HasEditFailedHandlers, com.smartgwt.client.widgets.grid.events.HasEditorEnterHandlers, com.smartgwt.client.widgets.grid.events.HasEditorExitHandlers, com.smartgwt.client.widgets.grid.events.HasFieldStateChangedHandlers, com.smartgwt.client.widgets.grid.events.HasFilterEditorSubmitHandlers, com.smartgwt.client.widgets.events.HasFormulaUpdatedHandlers, com.smartgwt.client.widgets.grid.events.HasGroupByCompleteHandlers, com.smartgwt.client.widgets.grid.events.HasGroupStateChangedHandlers, com.smartgwt.client.widgets.grid.events.HasGroupByHandlers, com.smartgwt.client.widgets.grid.events.HasHeaderDoubleClickHandlers, com.smartgwt.client.widgets.grid.events.HasHeaderHoverHandlers, com.smartgwt.client.widgets.grid.events.HasHilitesChangedHandlers, com.smartgwt.client.widgets.grid.events.HasBodyKeyPressHandlers, com.smartgwt.client.widgets.grid.events.HasRecordCollapseHandlers, com.smartgwt.client.widgets.grid.events.HasRecordExpandHandlers, com.smartgwt.client.widgets.grid.events.HasHeaderClickHandlers, com.smartgwt.client.widgets.grid.events.HasRecordClickHandlers, com.smartgwt.client.widgets.grid.events.HasRecordDropHandlers, com.smartgwt.client.widgets.grid.events.HasRemoveRecordClickHandlers, com.smartgwt.client.widgets.grid.events.HasRecordDoubleClickHandlers, com.smartgwt.client.widgets.grid.events.HasRowContextClickHandlers, com.smartgwt.client.widgets.grid.events.HasRowEditorEnterHandlers, com.smartgwt.client.widgets.grid.events.HasRowEditorExitHandlers, com.smartgwt.client.widgets.grid.events.HasRowHoverHandlers, com.smartgwt.client.widgets.grid.events.HasRowMouseDownHandlers, com.smartgwt.client.widgets.grid.events.HasRowMouseUpHandlers, com.smartgwt.client.widgets.grid.events.HasRowOutHandlers, com.smartgwt.client.widgets.grid.events.HasRowOverHandlers, com.smartgwt.client.widgets.grid.events.HasSelectionChangedHandlers, com.smartgwt.client.widgets.grid.events.HasSelectionUpdatedHandlers, com.smartgwt.client.widgets.grid.events.HasSetSortHandlers, com.smartgwt.client.widgets.grid.events.HasSortChangedHandlers, com.smartgwt.client.widgets.grid.events.HasSorterClickHandlers, com.smartgwt.client.widgets.grid.events.HasSorterContextClickHandlers, com.smartgwt.client.widgets.grid.events.HasViewStateChangedHandlers {

    public static ListGrid getOrCreateRef(JavaScriptObject jsObj) {
        if (jsObj == null) return null;
        final BaseWidget refInstance = BaseWidget.getRef(jsObj);
        if (refInstance == null) {
            return new ListGrid(jsObj);
        } else {
            assert refInstance instanceof ListGrid;
            return (ListGrid)refInstance;
        }
    }

    private static final ListGrid TEST_INSTANCE = new ListGrid();
    static {
        TEST_INSTANCE.setID("isc_ListGrid_testInstance");
    }

    @Override
    protected ListGrid getTestInstance() {
        return TEST_INSTANCE;
    }
        


    /**
     * Changes the defaults for Canvas AutoChildren named <code>autoChildName</code>.
     *
     * @param autoChildName name of an AutoChild to customize the defaults for.
     * @param defaults Canvas defaults to apply. These defaults override any existing properties
     * without destroying or wiping out non-overridden properties.  For usage tips on this
     * param, see {@link com.smartgwt.client.docs.SGWTProperties}.
     * @see com.smartgwt.client.docs.AutoChildUsage
     */
    public static native void changeAutoChildDefaults(String autoChildName, Canvas defaults) /*-{
        if (defaults.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPreConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(ListGrid.@java.lang.Object::getClass()(), "changeAutoChildDefaults", "Canvas");
        }
        defaults.@com.smartgwt.client.widgets.BaseWidget::setConfigOnly(Z)(true);
        var cleanDefaultsJS = @com.smartgwt.client.util.JSOHelper::cleanProperties(Lcom/google/gwt/core/client/JavaScriptObject;Z)(defaults.@com.smartgwt.client.widgets.BaseWidget::getConfig()(), true);
        $wnd.isc.ListGrid.changeDefaults(autoChildName + "Defaults", cleanDefaultsJS);
    }-*/;

    /**
     * Changes the defaults for FormItem AutoChildren named <code>autoChildName</code>.
     *
     * @param autoChildName name of an AutoChild to customize the defaults for.
     * @param defaults FormItem defaults to apply. These defaults override any existing properties
     * without destroying or wiping out non-overridden properties.  For usage tips on this
     * param, see {@link com.smartgwt.client.docs.SGWTProperties}.
     * @see com.smartgwt.client.docs.AutoChildUsage
     */
    public static native void changeAutoChildDefaults(String autoChildName, FormItem defaults) /*-{
        if (defaults.@com.smartgwt.client.widgets.form.fields.FormItem::isCreated()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPreConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(ListGrid.@java.lang.Object::getClass()(), "changeAutoChildDefaults", "FormItem");
        }
        defaults.@com.smartgwt.client.widgets.form.fields.FormItem::setConfigOnly(Z)(true);
    	var cleanDefaultsJS = defaults.@com.smartgwt.client.widgets.form.fields.FormItem::getEditorTypeConfig()();
        $wnd.isc.ListGrid.changeDefaults(autoChildName + "Defaults", cleanDefaultsJS);
    }-*/;

    public ListGrid(){
        setModalEditing(true);scClassName = "ListGrid";
    }

    public ListGrid(JavaScriptObject jsObj){
        scClassName = "ListGrid";
        setJavaScriptObject(jsObj);
    }


    public ListGrid(DataSource dataSource) {
        setDataSource(dataSource);
                setModalEditing(true);scClassName = "ListGrid";
    }

    protected native JavaScriptObject create()/*-{
        var config = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
        var widget = $wnd.isc[scClassName].create(config);
        if ($wnd.isc.keepGlobals) this.@com.smartgwt.client.widgets.BaseWidget::internalSetID(Lcom/google/gwt/core/client/JavaScriptObject;)(widget);
        this.@com.smartgwt.client.widgets.BaseWidget::doInit()();
        return widget;
    }-*/;

    // ********************* Properties / Attributes ***********************

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getUseAdvancedFieldPicker useAdvancedFieldPicker} is set, total
     * number of available fields that must be present in the grid before the advanced field picker interface is used instead
     * of the normal columns submenu. <P> Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is
     * true).
     *
     * @param advancedFieldPickerThreshold New advancedFieldPickerThreshold value. Default value is 25
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAdvancedFieldPickerThreshold(int advancedFieldPickerThreshold)  throws IllegalStateException {
        setAttribute("advancedFieldPickerThreshold", advancedFieldPickerThreshold, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getUseAdvancedFieldPicker useAdvancedFieldPicker} is set, total
     * number of available fields that must be present in the grid before the advanced field picker interface is used instead
     * of the normal columns submenu. <P> Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is
     * true).
     *
     * @return Current advancedFieldPickerThreshold value. Default value is 25
     */
    public int getAdvancedFieldPickerThreshold()  {
        return getAttributeAsInt("advancedFieldPickerThreshold");
    }
    

    /**
     * For use with {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor}:true, allows simple
     * search expressions to be entered into filter fields, as though {@link
     * com.smartgwt.client.widgets.form.DynamicForm#getAllowExpressions DynamicForm.allowExpressions} were true. <P> This
     * attribute can also be set at the {@link com.smartgwt.client.widgets.grid.ListGridField#getAllowFilterExpressions field
     * level}.
     *
     * @param allowFilterExpressions New allowFilterExpressions value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.AdvancedFilter AdvancedFilter overview and related methods
     */
    public void setAllowFilterExpressions(Boolean allowFilterExpressions)  throws IllegalStateException {
        setAttribute("allowFilterExpressions", allowFilterExpressions, false);
    }

    /**
     * For use with {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor}:true, allows simple
     * search expressions to be entered into filter fields, as though {@link
     * com.smartgwt.client.widgets.form.DynamicForm#getAllowExpressions DynamicForm.allowExpressions} were true. <P> This
     * attribute can also be set at the {@link com.smartgwt.client.widgets.grid.ListGridField#getAllowFilterExpressions field
     * level}.
     *
     * @return Current allowFilterExpressions value. Default value is null
     * @see com.smartgwt.client.docs.AdvancedFilter AdvancedFilter overview and related methods
     */
    public Boolean getAllowFilterExpressions()  {
        return getAttributeAsBoolean("allowFilterExpressions");
    }
    

    /**
     * Causes a menu item titled {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterUsingText "Filter using"} to appear
     * in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} that allows the end
     * user to pick an advanced {@link com.smartgwt.client.types.OperatorId search operator} to use for this field. <p> Once an
     * operator has been chosen, the active operator is indicated by an {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon} placed within the field (you can alternatively
     * cause the icon to {@link com.smartgwt.client.widgets.grid.ListGrid#getAlwaysShowOperatorIcon always be present}).  The
     * <code>operatorIcon</code>  shows the same textual representation of the search operator as is used by the {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getAllowExpressions FormItem.allowExpressions} feature.  Clicking on
     * the icon provides a second way to  modify the search operator.   <p> This feature is enabled by default if {@link
     * com.smartgwt.client.data.DataSource#supportsAdvancedCriteria DataSource.supportsAdvancedCriteria()} is true,  for all
     * fields where it is normally possible to filter by typing in a search string.  This  excludes field types such as "date"
     * or "boolean" which show specialized filter controls.   Use {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAllowFilterOperators ListGridField.allowFilterOperators} to disable
     * this interface for individual  fields, or set {@link com.smartgwt.client.data.DataSourceField#getCanFilter
     * DataSourceField.canFilter} to false to disallow filtering entirely for  a field. <p> Note that this feature is similar
     * to {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterExpressions allowFilterExpressions}, which allows  the
     * end users to directly type in characters such as "&gt;" to control filtering. <code>allowFilterOperators</code> is
     * easier to use and more discoverable than <code>allowFilterExpressions</code>, and also avoids the drawback where special
     * characters  like "&gt;" cannot be used in filter values.  However, <code>allowFilterExpressions</code>  allows users to
     * make use of certain operators that <code>allowFilterOperators</code> does  not support, such as using the
     * "betweenInclusive" operator by typing "5...10". <P> When both <code>allowfilterExpressions</code> and
     * <code>allowFilterOperators</code> are set, filter expressions entered in to the edit-area are parsed and the operator
     * automatically  applied to the {@link com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon}.
     *
     * @param allowFilterOperators New allowFilterOperators value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAllowFilterOperators(Boolean allowFilterOperators)  throws IllegalStateException {
        setAttribute("allowFilterOperators", allowFilterOperators, false);
    }

    /**
     * Causes a menu item titled {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterUsingText "Filter using"} to appear
     * in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} that allows the end
     * user to pick an advanced {@link com.smartgwt.client.types.OperatorId search operator} to use for this field. <p> Once an
     * operator has been chosen, the active operator is indicated by an {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon} placed within the field (you can alternatively
     * cause the icon to {@link com.smartgwt.client.widgets.grid.ListGrid#getAlwaysShowOperatorIcon always be present}).  The
     * <code>operatorIcon</code>  shows the same textual representation of the search operator as is used by the {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getAllowExpressions FormItem.allowExpressions} feature.  Clicking on
     * the icon provides a second way to  modify the search operator.   <p> This feature is enabled by default if {@link
     * com.smartgwt.client.data.DataSource#supportsAdvancedCriteria DataSource.supportsAdvancedCriteria()} is true,  for all
     * fields where it is normally possible to filter by typing in a search string.  This  excludes field types such as "date"
     * or "boolean" which show specialized filter controls.   Use {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAllowFilterOperators ListGridField.allowFilterOperators} to disable
     * this interface for individual  fields, or set {@link com.smartgwt.client.data.DataSourceField#getCanFilter
     * DataSourceField.canFilter} to false to disallow filtering entirely for  a field. <p> Note that this feature is similar
     * to {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterExpressions allowFilterExpressions}, which allows  the
     * end users to directly type in characters such as "&gt;" to control filtering. <code>allowFilterOperators</code> is
     * easier to use and more discoverable than <code>allowFilterExpressions</code>, and also avoids the drawback where special
     * characters  like "&gt;" cannot be used in filter values.  However, <code>allowFilterExpressions</code>  allows users to
     * make use of certain operators that <code>allowFilterOperators</code> does  not support, such as using the
     * "betweenInclusive" operator by typing "5...10". <P> When both <code>allowfilterExpressions</code> and
     * <code>allowFilterOperators</code> are set, filter expressions entered in to the edit-area are parsed and the operator
     * automatically  applied to the {@link com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon}.
     *
     * @return Current allowFilterOperators value. Default value is null
     */
    public Boolean getAllowFilterOperators()  {
        return getAttributeAsBoolean("allowFilterOperators");
    }
    

    /**
     * Should cells in this grid be allowed to span multiple rows? If set to <code>true</code>, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} method will be called for every cell when rendering
     * out the listGrid to determine how many rows the cell should span. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} for more details
     *
     * @param allowRowSpanning New allowRowSpanning value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAllowRowSpanning(Boolean allowRowSpanning)  throws IllegalStateException {
        setAttribute("allowRowSpanning", allowRowSpanning, false);
    }

    /**
     * Should cells in this grid be allowed to span multiple rows? If set to <code>true</code>, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} method will be called for every cell when rendering
     * out the listGrid to determine how many rows the cell should span. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} for more details
     *
     * @return Current allowRowSpanning value. Default value is false
     */
    public Boolean getAllowRowSpanning()  {
        Boolean result = getAttributeAsBoolean("allowRowSpanning");
        return result == null ? false : result;
    }
    

    /**
     * Optional css style to apply to the body if {@link com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles
     * alternateRecordStyles} is true for this grid. If unset {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyStyleName
     * bodyStyleName} will be used to style the body regardless of the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles alternateRecordStyles} setting.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Update the {@link com.smartgwt.client.widgets.grid.ListGrid#getAlternateBodyStyleName alternateBodyStyleName} for this listGrid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param alternateBodyStyleName new body style name when showing alternateRecordStyles. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setAlternateBodyStyleName(String alternateBodyStyleName) {
        setAttribute("alternateBodyStyleName", alternateBodyStyleName, true);
    }

    /**
     * Optional css style to apply to the body if {@link com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles
     * alternateRecordStyles} is true for this grid. If unset {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyStyleName
     * bodyStyleName} will be used to style the body regardless of the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles alternateRecordStyles} setting.
     *
     * @return Current alternateBodyStyleName value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getAlternateBodyStyleName()  {
        return getAttributeAsString("alternateBodyStyleName");
    }
    

    /**
     * The number of consecutive columns to draw in the same style before alternating, when {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles alternateColumnStyles} is true.
     *
     * @param alternateFieldFrequency New alternateFieldFrequency value. Default value is 1
     */
    public void setAlternateFieldFrequency(int alternateFieldFrequency) {
        setAttribute("alternateFieldFrequency", alternateFieldFrequency, true);
    }

    /**
     * The number of consecutive columns to draw in the same style before alternating, when {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles alternateColumnStyles} is true.
     *
     * @return Current alternateFieldFrequency value. Default value is 1
     */
    public int getAlternateFieldFrequency()  {
        return getAttributeAsInt("alternateFieldFrequency");
    }
    

    /**
     * Whether alternating columns (or blocks of columns, depending on {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnFrequency GridRenderer.alternateColumnFrequency}) should
     * be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. <P> If enabled, the
     * cell style for alternate rows will have the {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnSuffix GridRenderer.alternateColumnSuffix} appended to
     * it. See also {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles
     * GridRenderer.alternateRowStyles}.
     *
     * @param alternateFieldStyles New alternateFieldStyles value. Default value is false
     */
    public void setAlternateFieldStyles(boolean alternateFieldStyles) {
        setAttribute("alternateFieldStyles", alternateFieldStyles, true);
    }

    /**
     * Whether alternating columns (or blocks of columns, depending on {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnFrequency GridRenderer.alternateColumnFrequency}) should
     * be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. <P> If enabled, the
     * cell style for alternate rows will have the {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnSuffix GridRenderer.alternateColumnSuffix} appended to
     * it. See also {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles
     * GridRenderer.alternateRowStyles}.
     *
     * @return Current alternateFieldStyles value. Default value is false
     */
    public boolean getAlternateFieldStyles()  {
        Boolean result = getAttributeAsBoolean("alternateFieldStyles");
        return result == null ? false : result;
    }
    

    /**
     * Suffix to append to {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles alternate columns}.
     * Note that if {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles GridRenderer.alternateRowStyles}
     * is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example
     * <code>"cellDarkAltCol"</code>.
     *
     * @param alternateFieldSuffix New alternateFieldSuffix value. Default value is "AltCol"
     */
    public void setAlternateFieldSuffix(String alternateFieldSuffix) {
        setAttribute("alternateFieldSuffix", alternateFieldSuffix, true);
    }

    /**
     * Suffix to append to {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles alternate columns}.
     * Note that if {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles GridRenderer.alternateRowStyles}
     * is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example
     * <code>"cellDarkAltCol"</code>.
     *
     * @return Current alternateFieldSuffix value. Default value is "AltCol"
     */
    public String getAlternateFieldSuffix()  {
        return getAttributeAsString("alternateFieldSuffix");
    }
    

    /**
     * The number of consecutive rows to draw in the same style before alternating, when {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles alternateRowStyles} is true.
     *
     * @param alternateRecordFrequency New alternateRecordFrequency value. Default value is 1
     */
    public void setAlternateRecordFrequency(int alternateRecordFrequency) {
        setAttribute("alternateRecordFrequency", alternateRecordFrequency, true);
    }

    /**
     * The number of consecutive rows to draw in the same style before alternating, when {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles alternateRowStyles} is true.
     *
     * @return Current alternateRecordFrequency value. Default value is 1
     */
    public int getAlternateRecordFrequency()  {
        return getAttributeAsInt("alternateRecordFrequency");
    }
    

    /**
     * Whether alternating rows (or blocks of rows, depending on {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowFrequency GridRenderer.alternateRowFrequency}) should be
     * drawn in alternating styles, in order to create a "ledger" effect for easier reading. <P> If enabled, the cell style for
     * alternate rows will have the {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowSuffix
     * GridRenderer.alternateRowSuffix} appended to it. See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles GridRenderer.alternateColumnStyles}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles alternateRecordStyles}
     *
     * @param alternateRecordStyles New value for <code>this.alternateRecordStyles</code>. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_lf_grid_cells" target="examples">Grid cells Example</a>
     */
    public void setAlternateRecordStyles(Boolean alternateRecordStyles) {
        setAttribute("alternateRecordStyles", alternateRecordStyles, true);
    }

    /**
     * Whether alternating rows (or blocks of rows, depending on {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowFrequency GridRenderer.alternateRowFrequency}) should be
     * drawn in alternating styles, in order to create a "ledger" effect for easier reading. <P> If enabled, the cell style for
     * alternate rows will have the {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowSuffix
     * GridRenderer.alternateRowSuffix} appended to it. See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles GridRenderer.alternateColumnStyles}.
     *
     * @return Current alternateRecordStyles value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_lf_grid_cells" target="examples">Grid cells Example</a>
     */
    public Boolean getAlternateRecordStyles()  {
        Boolean result = getAttributeAsBoolean("alternateRecordStyles");
        return result == null ? false : result;
    }
    

    /**
     * Suffix to append to {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles alternate rows}. Note
     * that if {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles
     * GridRenderer.alternateColumnStyles} is enabled, cells which fall into both an alternate row and column will have both
     * suffixes appended - for example <code>"cellDarkAltCol"</code>.
     *
     * @param alternateRecordSuffix New alternateRecordSuffix value. Default value is "Dark"
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_lf_grid_cells" target="examples">Grid cells Example</a>
     */
    public void setAlternateRecordSuffix(String alternateRecordSuffix) {
        setAttribute("alternateRecordSuffix", alternateRecordSuffix, true);
    }

    /**
     * Suffix to append to {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateRowStyles alternate rows}. Note
     * that if {@link com.smartgwt.client.widgets.grid.GridRenderer#getAlternateColumnStyles
     * GridRenderer.alternateColumnStyles} is enabled, cells which fall into both an alternate row and column will have both
     * suffixes appended - for example <code>"cellDarkAltCol"</code>.
     *
     * @return Current alternateRecordSuffix value. Default value is "Dark"
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_lf_grid_cells" target="examples">Grid cells Example</a>
     */
    public String getAlternateRecordSuffix()  {
        return getAttributeAsString("alternateRecordSuffix");
    }
    

    /**
     * When this attribute is set, editors will be appear to be present in every row of the  grid, allowing the user to
     * immediately start editing any cell, rather thanshowing  up in a single record at a time.<br> This attribute is only
     * valid when {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell editByCell} is false. <P> This setting has
     * some limitations and is typically only used for simple grids with  a limited set of fields and standard editors. <ul>
     * <li>Not all formItem types are supported. Default editors for standard data types   (text, boolean, date, datetime,
     * integer and float) are all supported, but custom   editorType, including CanvasItem based editors are not. Fields with
     * an unsupported   editor type will show static values for all rows other than the current edit row, though   users can
     * start editing these with a single click</li>  <li><code>alwaysShowEditors:true</code> grids do not support showing
     * different   editor types for the same field in different rows</li> <li>In some cases there may be visual differences
     * between the editor displayed in the   edit row and the editor displayed in other rows.</li> <li>From a design
     * perspective, this mode presents a very "busy-looking" UI,     which can made it harder to read the actual data.
     * Functionally having      {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} set to "click"
     * provides the same single-click to edit     any cell user experience without the busy UI.</li> <li>In some cases there
     * may be a performance penalty for writing out so many controls     (editors for every cell of the grid).</li> </ul> Note
     * that in addition to alwaysShowEditors, listGrid support single-click editing via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent:"click"}, and, for boolean fields,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanToggle ListGridField.canToggle}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param alwaysShowEditors New alwaysShowEditors value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setAlwaysShowEditors(Boolean alwaysShowEditors)  throws IllegalStateException {
        setAttribute("alwaysShowEditors", alwaysShowEditors, false);
    }

    /**
     * When this attribute is set, editors will be appear to be present in every row of the  grid, allowing the user to
     * immediately start editing any cell, rather thanshowing  up in a single record at a time.<br> This attribute is only
     * valid when {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell editByCell} is false. <P> This setting has
     * some limitations and is typically only used for simple grids with  a limited set of fields and standard editors. <ul>
     * <li>Not all formItem types are supported. Default editors for standard data types   (text, boolean, date, datetime,
     * integer and float) are all supported, but custom   editorType, including CanvasItem based editors are not. Fields with
     * an unsupported   editor type will show static values for all rows other than the current edit row, though   users can
     * start editing these with a single click</li>  <li><code>alwaysShowEditors:true</code> grids do not support showing
     * different   editor types for the same field in different rows</li> <li>In some cases there may be visual differences
     * between the editor displayed in the   edit row and the editor displayed in other rows.</li> <li>From a design
     * perspective, this mode presents a very "busy-looking" UI,     which can made it harder to read the actual data.
     * Functionally having      {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} set to "click"
     * provides the same single-click to edit     any cell user experience without the busy UI.</li> <li>In some cases there
     * may be a performance penalty for writing out so many controls     (editors for every cell of the grid).</li> </ul> Note
     * that in addition to alwaysShowEditors, listGrid support single-click editing via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent:"click"}, and, for boolean fields,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanToggle ListGridField.canToggle}
     *
     * @return Current alwaysShowEditors value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getAlwaysShowEditors()  {
        return getAttributeAsBoolean("alwaysShowEditors");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} is enabled, whether
     * to show the {@link com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon} for all filterable fields, or
     * only for fields where the user has explicitly chosen a search operator different from the default operator for the
     * field. <p> The default operator for a field is determined by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle autoFetchTextMatchStyle} or by setting {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFilterOperator ListGridField.filterOperator} for a specific field.
     *
     * @param alwaysShowOperatorIcon New alwaysShowOperatorIcon value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAlwaysShowOperatorIcon(Boolean alwaysShowOperatorIcon)  throws IllegalStateException {
        setAttribute("alwaysShowOperatorIcon", alwaysShowOperatorIcon, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} is enabled, whether
     * to show the {@link com.smartgwt.client.widgets.grid.ListGrid#getOperatorIcon operatorIcon} for all filterable fields, or
     * only for fields where the user has explicitly chosen a search operator different from the default operator for the
     * field. <p> The default operator for a field is determined by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle autoFetchTextMatchStyle} or by setting {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFilterOperator ListGridField.filterOperator} for a specific field.
     *
     * @return Current alwaysShowOperatorIcon value. Default value is null
     */
    public Boolean getAlwaysShowOperatorIcon()  {
        return getAttributeAsBoolean("alwaysShowOperatorIcon");
    }
    

    /**
     * When animating folder opening / closing, this property can be set to apply an animated acceleration effect. This allows
     * the animation speed to be "weighted", for example expanding or collapsing at a faster rate toward the beginning of the
     * animation than at the end. <P> For a ListGrid, this property applies when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is enabled.
     *
     * @param animateFolderEffect New animateFolderEffect value. Default value is null
     */
    public void setAnimateFolderEffect(AnimationAcceleration animateFolderEffect) {
        setAttribute("animateFolderEffect", animateFolderEffect == null ? null : animateFolderEffect.getValue(), true);
    }

    /**
     * When animating folder opening / closing, this property can be set to apply an animated acceleration effect. This allows
     * the animation speed to be "weighted", for example expanding or collapsing at a faster rate toward the beginning of the
     * animation than at the end. <P> For a ListGrid, this property applies when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is enabled.
     *
     * @return Current animateFolderEffect value. Default value is null
     */
    public AnimationAcceleration getAnimateFolderEffect()  {
        return EnumUtil.getEnum(AnimationAcceleration.values(), getAttribute("animateFolderEffect"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateFolders animateFolders} is true for this grid, this number
     * can be set to designate the maximum number of rows to animate at a time when opening / closing a folder. <P> For a
     * ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is
     * enabled.
     *
     * @param animateFolderMaxRows New animateFolderMaxRows value. Default value is null
     * @see com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderMaxRows
     */
    public void setAnimateFolderMaxRows(Integer animateFolderMaxRows) {
        setAttribute("animateFolderMaxRows", animateFolderMaxRows, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateFolders animateFolders} is true for this grid, this number
     * can be set to designate the maximum number of rows to animate at a time when opening / closing a folder. <P> For a
     * ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is
     * enabled.
     *
     * @return Current animateFolderMaxRows value. Default value is null
     * @see com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderMaxRows
     */
    public Integer getAnimateFolderMaxRows()  {
        return getAttributeAsInt("animateFolderMaxRows");
    }
    

    /**
     * If true, when folders are opened / closed children will be animated into view. <P> For a ListGrid, this property applies
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is enabled.
     *
     * @param animateFolders New animateFolders value. Default value is true
     */
    public void setAnimateFolders(Boolean animateFolders) {
        setAttribute("animateFolders", animateFolders, true);
    }

    /**
     * If true, when folders are opened / closed children will be animated into view. <P> For a ListGrid, this property applies
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is enabled.
     *
     * @return Current animateFolders value. Default value is true
     */
    public Boolean getAnimateFolders()  {
        Boolean result = getAttributeAsBoolean("animateFolders");
        return result == null ? true : result;
    }
    

    /**
     * When animating folder opening / closing, this property designates the speed of the animation in pixels shown (or hidden)
     * per second. Takes precedence over the {@link com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderTime
     * TreeGrid.animateFolderTime} property, which allows the developer to specify a duration for the animation rather than a
     * speed. <P> For a ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy
     * grouping} is enabled.
     *
     * @param animateFolderSpeed New animateFolderSpeed value. Default value is 3000
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateFolderTime
     */
    public void setAnimateFolderSpeed(int animateFolderSpeed) {
        setAttribute("animateFolderSpeed", animateFolderSpeed, true);
    }

    /**
     * When animating folder opening / closing, this property designates the speed of the animation in pixels shown (or hidden)
     * per second. Takes precedence over the {@link com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderTime
     * TreeGrid.animateFolderTime} property, which allows the developer to specify a duration for the animation rather than a
     * speed. <P> For a ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy
     * grouping} is enabled.
     *
     * @return Current animateFolderSpeed value. Default value is 3000
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateFolderTime
     */
    public int getAnimateFolderSpeed()  {
        return getAttributeAsInt("animateFolderSpeed");
    }
    

    /**
     * When animating folder opening / closing, if {@link com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderSpeed
     * TreeGrid.animateFolderSpeed} is not set, this property designates the duration of the animation in ms. <P> For a
     * ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is
     * enabled.
     *
     * @param animateFolderTime New animateFolderTime value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateFolderSpeed
     */
    public void setAnimateFolderTime(int animateFolderTime) {
        setAttribute("animateFolderTime", animateFolderTime, true);
    }

    /**
     * When animating folder opening / closing, if {@link com.smartgwt.client.widgets.tree.TreeGrid#getAnimateFolderSpeed
     * TreeGrid.animateFolderSpeed} is not set, this property designates the duration of the animation in ms. <P> For a
     * ListGrid, this property applies when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping} is
     * enabled.
     *
     * @return Current animateFolderTime value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateFolderSpeed
     */
    public int getAnimateFolderTime()  {
        return getAttributeAsInt("animateFolderTime");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, should records
     * be animated out of view when they are removed by the user?
     *
     * @param animateRemoveRecord New animateRemoveRecord value. Default value is true
     */
    public void setAnimateRemoveRecord(Boolean animateRemoveRecord) {
        setAttribute("animateRemoveRecord", animateRemoveRecord, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, should records
     * be animated out of view when they are removed by the user?
     *
     * @return Current animateRemoveRecord value. Default value is true
     */
    public Boolean getAnimateRemoveRecord()  {
        Boolean result = getAttributeAsBoolean("animateRemoveRecord");
        return result == null ? true : result;
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord animating record removal}, this property
     * designates the speed of the animation in pixels per second. Takes precedence over the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveTime animateRemoveTime} property, which allows the developer
     * to specify a duration for the animation rather than a speed.
     *
     * @param animateRemoveSpeed New animateRemoveSpeed value. Default value is 200
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateRemoveRecord
     */
    public void setAnimateRemoveSpeed(int animateRemoveSpeed) {
        setAttribute("animateRemoveSpeed", animateRemoveSpeed, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord animating record removal}, this property
     * designates the speed of the animation in pixels per second. Takes precedence over the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveTime animateRemoveTime} property, which allows the developer
     * to specify a duration for the animation rather than a speed.
     *
     * @return Current animateRemoveSpeed value. Default value is 200
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord
     */
    public int getAnimateRemoveSpeed()  {
        return getAttributeAsInt("animateRemoveSpeed");
    }
    

    /**
     * When animating record removal {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord (see
     * animateRemoveRecord)}, if {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveSpeed animateRemoveSpeed} is
     * not set, this property designates the duration of the animation in ms.
     *
     * @param animateRemoveTime New animateRemoveTime value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateRemoveRecord
     */
    public void setAnimateRemoveTime(int animateRemoveTime) {
        setAttribute("animateRemoveTime", animateRemoveTime, true);
    }

    /**
     * When animating record removal {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord (see
     * animateRemoveRecord)}, if {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveSpeed animateRemoveSpeed} is
     * not set, this property designates the duration of the animation in ms.
     *
     * @return Current animateRemoveTime value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord
     */
    public int getAnimateRemoveTime()  {
        return getAttributeAsInt("animateRemoveTime");
    }
    

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>rollOverCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>rollOverCanvasProperties</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param animateRollOver New animateRollOver value. Default value is false
     */
    public void setAnimateRollOver(Boolean animateRollOver) {
        setAttribute("animateRollOver", animateRollOver, true);
    }

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>rollOverCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>rollOverCanvasProperties</code>.
     *
     * @return Current animateRollOver value. Default value is false
     */
    public Boolean getAnimateRollOver()  {
        Boolean result = getAttributeAsBoolean("animateRollOver");
        return result == null ? false : result;
    }
    

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>rollUnderCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>rollUnderCanvasProperties</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param animateRollUnder New animateRollUnder value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public void setAnimateRollUnder(Boolean animateRollUnder) {
        setAttribute("animateRollUnder", animateRollUnder, true);
    }

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>rollUnderCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>rollUnderCanvasProperties</code>.
     *
     * @return Current animateRollUnder value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public Boolean getAnimateRollUnder()  {
        Boolean result = getAttributeAsBoolean("animateRollUnder");
        return result == null ? false : result;
    }
    

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>selectionCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>selectionCanvasProperties</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param animateSelection New animateSelection value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateSelectionUnder
     */
    public void setAnimateSelection(Boolean animateSelection) {
        setAttribute("animateSelection", animateSelection, true);
    }

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas} is enabled, setting this
     * property to <code>true</code> ensures that when the <code>selectionCanvas</code> is displayed it is animated into view
     * via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the animation effect may be
     * customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect Canvas.animateShowEffect}, {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and {@link
     * com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>selectionCanvasProperties</code>.
     *
     * @return Current animateSelection value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateSelectionUnder
     */
    public Boolean getAnimateSelection()  {
        Boolean result = getAttributeAsBoolean("animateSelection");
        return result == null ? false : result;
    }
    

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} is enabled,
     * setting this property to <code>true</code> ensures that when the <code>selectionUnderCanvas</code> is displayed it is
     * animated into view via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the
     * animation effect may be customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect
     * Canvas.animateShowEffect}, {@link com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and
     * {@link com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>selectionUnderCanvasProperties</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param animateSelectionUnder New animateSelectionUnder value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAnimateSelection
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public void setAnimateSelectionUnder(Boolean animateSelectionUnder) {
        setAttribute("animateSelectionUnder", animateSelectionUnder, true);
    }

    /**
     * If the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} is enabled,
     * setting this property to <code>true</code> ensures that when the <code>selectionUnderCanvas</code> is displayed it is
     * animated into view via {@link com.smartgwt.client.widgets.Canvas#animateShow Canvas.animateShow()}. Note that the
     * animation effect may be customized via {@link com.smartgwt.client.widgets.Canvas#getAnimateShowEffect
     * Canvas.animateShowEffect}, {@link com.smartgwt.client.widgets.Canvas#getAnimateShowTime Canvas.animateShowTime} and
     * {@link com.smartgwt.client.widgets.Canvas#getAnimateShowAcceleration Canvas.animateShowAcceleration} set in
     * <code>selectionUnderCanvasProperties</code>.
     *
     * @return Current animateSelectionUnder value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAnimateSelection
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public Boolean getAnimateSelectionUnder()  {
        Boolean result = getAttributeAsBoolean("animateSelectionUnder");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGridField#getUserFormula ListGridField.userFormula} is set for some
     * field, and this grid is showing {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summaries} or
     * a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary}, this property determines what field
     * value should be present in those summary rows. Should the field apply the user-formula to the calculated summary row, or
     * should it apply a standard grid or group summary to the user-formula values displayed in the grid? <P> May be overridden
     * at the field level via {@link com.smartgwt.client.widgets.grid.ListGridField#getApplyAfterSummary
     * ListGridField.applyAfterSummary}
     *
     * @param applyFormulaAfterSummary New applyFormulaAfterSummary value. Default value is false
     */
    public void setApplyFormulaAfterSummary(Boolean applyFormulaAfterSummary) {
        setAttribute("applyFormulaAfterSummary", applyFormulaAfterSummary, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGridField#getUserFormula ListGridField.userFormula} is set for some
     * field, and this grid is showing {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summaries} or
     * a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary}, this property determines what field
     * value should be present in those summary rows. Should the field apply the user-formula to the calculated summary row, or
     * should it apply a standard grid or group summary to the user-formula values displayed in the grid? <P> May be overridden
     * at the field level via {@link com.smartgwt.client.widgets.grid.ListGridField#getApplyAfterSummary
     * ListGridField.applyAfterSummary}
     *
     * @return Current applyFormulaAfterSummary value. Default value is false
     */
    public Boolean getApplyFormulaAfterSummary()  {
        Boolean result = getAttributeAsBoolean("applyFormulaAfterSummary");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true, should we apply the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getRowNumberStyle rowNumberStyle} to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowNumberField rowNumberField}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param applyRowNumberStyle New applyRowNumberStyle value. Default value is true
     */
    public void setApplyRowNumberStyle(boolean applyRowNumberStyle) {
        setAttribute("applyRowNumberStyle", applyRowNumberStyle, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true, should we apply the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getRowNumberStyle rowNumberStyle} to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowNumberField rowNumberField}
     *
     * @return Current applyRowNumberStyle value. Default value is true
     */
    public boolean getApplyRowNumberStyle()  {
        Boolean result = getAttributeAsBoolean("applyRowNumberStyle");
        return result == null ? true : result;
    }
    

    /**
     * Action to perform when the listGrid has keyboard focus (but not editing focus) and a user presses the up or down arrow
     * key. Possible values are: <ul> <li><code>"select"</code> : select the next row in the list (calls
     * <code>recordClick</code> handler)</li> <li><code>"focus"</code> : move focus to the next row in the list without
     * changing the selection</li> <li><code>"activate"</code> : select and activate the next row in the list (calls 
     * <code>recordDoubleClick</code> handler)</li> <li><code>"none"</code> : no action</li> <li> <code>null</code> : if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is "checkbox", behaves as if set 
     * to "focus"; otherwise, behaves as if set to "select"</li> </ul> <P> Note: If this grid is editable, behavior while
     * editing is governed by the result of  {@link com.smartgwt.client.widgets.grid.ListGrid#getArrowKeyEditAction
     * getArrowKeyEditAction()}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param arrowKeyAction New arrowKeyAction value. Default value is null
     */
    public void setArrowKeyAction(String arrowKeyAction) {
        setAttribute("arrowKeyAction", arrowKeyAction, true);
    }

    /**
     * Action to perform when the listGrid has keyboard focus (but not editing focus) and a user presses the up or down arrow
     * key. Possible values are: <ul> <li><code>"select"</code> : select the next row in the list (calls
     * <code>recordClick</code> handler)</li> <li><code>"focus"</code> : move focus to the next row in the list without
     * changing the selection</li> <li><code>"activate"</code> : select and activate the next row in the list (calls 
     * <code>recordDoubleClick</code> handler)</li> <li><code>"none"</code> : no action</li> <li> <code>null</code> : if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is "checkbox", behaves as if set 
     * to "focus"; otherwise, behaves as if set to "select"</li> </ul> <P> Note: If this grid is editable, behavior while
     * editing is governed by the result of  {@link com.smartgwt.client.widgets.grid.ListGrid#getArrowKeyEditAction
     * getArrowKeyEditAction()}.
     *
     * @return Current arrowKeyAction value. Default value is null
     */
    public String getArrowKeyAction()  {
        return getAttributeAsString("arrowKeyAction");
    }
    

    /**
     * What to do when a user hits arrow key while editing a field?<br> If not explicitly specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getArrowKeyEditAction getArrowKeyEditAction()}  will return an appropriate
     * action depending on the field type.
     *
     * @param arrowKeyEditAction New arrowKeyEditAction value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setArrowKeyEditAction(ArrowKeyEditAction arrowKeyEditAction) {
        setAttribute("arrowKeyEditAction", arrowKeyEditAction == null ? null : arrowKeyEditAction.getValue(), true);
    }

    /**
     * What to do when a user hits arrow key while editing a field?<br> If not explicitly specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getArrowKeyEditAction getArrowKeyEditAction()}  will return an appropriate
     * action depending on the field type.
     *
     * @return How should "Up" and "Down" arrow keypresses be handled when the user is editing an item in the grid. <P> Returning
     * "none" will cause the grid to take no action and allow default up/down arrow key behavior within the editor to proceed.
     * Returning "editNext" will create an appropriate {@link com.smartgwt.client.types.EditCompletionEvent} (<i>"arrow_up"</i>
     * or <i>"arrow_down"</i> and cause the grid to start editing the previous or next row). <P> Default behavior varies by
     * item type. For items where up and down arrows have significant functionality to the editor this method returns
     * <i>"none"</i>, allowing that standard behavior to proceed. This includes:<br> - Multi line editors (such as
     * TextAreaItems)<br> - SelectItems<br> - SpinnerItems<br> For other items, the default return value will be
     * <i>"edit_next"</i> <P> To override these defaults, developers may specify an explicit arrowKeyEditAction at the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getArrowKeyEditAction grid}, or  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getArrowKeyEditAction field} level. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public ArrowKeyEditAction getArrowKeyEditAction()  {
        return EnumUtil.getEnum(ArrowKeyEditAction.values(), getAttribute("arrowKeyEditAction"));
    }
    

    /**
     * The prompt to display while interactivity is blocked during {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold asynchronous grouping}.
     *
     * @param asynchGroupingPrompt New asynchGroupingPrompt value. Default value is "${loadingImage}&amp;nbsp;Grouping data..."
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setAsynchGroupingPrompt(String asynchGroupingPrompt)  throws IllegalStateException {
        setAttribute("asynchGroupingPrompt", asynchGroupingPrompt, false);
    }

    /**
     * The prompt to display while interactivity is blocked during {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold asynchronous grouping}.
     *
     * @return Current asynchGroupingPrompt value. Default value is "${loadingImage}&amp;nbsp;Grouping data..."
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getAsynchGroupingPrompt()  {
        return getAttributeAsString("asynchGroupingPrompt");
    }
    

    /**
     * Whether to do inline autoComplete in text fields during inline editing<br> Overridden by {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoComplete ListGridField.autoComplete} if specified. If unset picks
     * up the default from the appropriate editor class (subclass of FormItem).
     *
     * @param autoComplete New autoComplete value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#setAutoComplete
     */
    public void setAutoComplete(AutoComplete autoComplete) {
        setAttribute("autoComplete", autoComplete == null ? null : autoComplete.getValue(), true);
    }

    /**
     * Whether to do inline autoComplete in text fields during inline editing<br> Overridden by {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoComplete ListGridField.autoComplete} if specified. If unset picks
     * up the default from the appropriate editor class (subclass of FormItem).
     *
     * @return Current autoComplete value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#getAutoComplete
     */
    public AutoComplete getAutoComplete()  {
        return EnumUtil.getEnum(AutoComplete.values(), getAttribute("autoComplete"));
    }
    

    /**
     * For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded by
     * default. This flag determines whether we should save such edits automatically in this case.  See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getConfirmDiscardEdits confirmDiscardEdits}, which  allows the user to choose
     * whether to save or discard the unsaved edits.
     *
     * @param autoConfirmSaveEdits New autoConfirmSaveEdits value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setAutoConfirmSaveEdits(Boolean autoConfirmSaveEdits) {
        setAttribute("autoConfirmSaveEdits", autoConfirmSaveEdits, true);
    }

    /**
     * For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded by
     * default. This flag determines whether we should save such edits automatically in this case.  See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getConfirmDiscardEdits confirmDiscardEdits}, which  allows the user to choose
     * whether to save or discard the unsaved edits.
     *
     * @return Current autoConfirmSaveEdits value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getAutoConfirmSaveEdits()  {
        Boolean result = getAttributeAsBoolean("autoConfirmSaveEdits");
        return result == null ? false : result;
    }
    
    

    /**
     * If true, for fields where {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource} is specified, a valueMap will be automatically created by making a {@link
     * com.smartgwt.client.data.DataSource#fetchData DataSource.fetchData()} call against the specified dataSource and
     * extracting a valueMap from the returned records based on the displayField and valueField. <P> If set to false, valueMaps
     * will not be automatically fetched.  In this case, setting field.optionDataSource is effectively a shortcut for setting
     * optionDataSource on the editor via {@link com.smartgwt.client.widgets.grid.ListGridField#getEditorProperties
     * ListGridField.editorProperties}. <P> Can also be disabled on a per-field basis with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFetchDisplayMap ListGridField.autoFetchDisplayMap}.
     *
     * @param autoFetchDisplayMap New autoFetchDisplayMap value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGridField#setAutoFetchDisplayMap
     * @see com.smartgwt.client.widgets.grid.ListGridField#setOptionDataSource
     */
    public void setAutoFetchDisplayMap(Boolean autoFetchDisplayMap) {
        setAttribute("autoFetchDisplayMap", autoFetchDisplayMap, true);
    }

    /**
     * If true, for fields where {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource} is specified, a valueMap will be automatically created by making a {@link
     * com.smartgwt.client.data.DataSource#fetchData DataSource.fetchData()} call against the specified dataSource and
     * extracting a valueMap from the returned records based on the displayField and valueField. <P> If set to false, valueMaps
     * will not be automatically fetched.  In this case, setting field.optionDataSource is effectively a shortcut for setting
     * optionDataSource on the editor via {@link com.smartgwt.client.widgets.grid.ListGridField#getEditorProperties
     * ListGridField.editorProperties}. <P> Can also be disabled on a per-field basis with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFetchDisplayMap ListGridField.autoFetchDisplayMap}.
     *
     * @return Current autoFetchDisplayMap value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGridField#getAutoFetchDisplayMap
     * @see com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     */
    public Boolean getAutoFetchDisplayMap()  {
        Boolean result = getAttributeAsBoolean("autoFetchDisplayMap");
        return result == null ? true : result;
    }
    
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} is true, this attribute
     * will be shown as the menu item title for an item to perform a one-time autoFit of all visible fields via the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#autoFitField autoFitField()} method.
     *
     * @param autoFitAllText New autoFitAllText value. Default value is "Auto Fit All Columns"
     */
    public void setAutoFitAllText(String autoFitAllText) {
        setAttribute("autoFitAllText", autoFitAllText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} is true, this attribute
     * will be shown as the menu item title for an item to perform a one-time autoFit of all visible fields via the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#autoFitField autoFitField()} method.
     *
     * @return Current autoFitAllText value. Default value is "Auto Fit All Columns"
     */
    public String getAutoFitAllText()  {
        return getAttributeAsString("autoFitAllText");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} is enabled and the
     * calculated field sizes are wide enough that horizontal scrolling would be introduced, this attribute may be set to an
     * array of fieldNames, causing those fields to be clipped rather than forcing horizontal scrollbars to appear. <P> Note:
     * If any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen columns} are included in this list they
     * will not be clipped.
     *
     * @param autoFitClipFields New autoFitClipFields value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoFitClipFields(String... autoFitClipFields)  throws IllegalStateException {
        setAttribute("autoFitClipFields", autoFitClipFields, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} is enabled and the
     * calculated field sizes are wide enough that horizontal scrolling would be introduced, this attribute may be set to an
     * array of fieldNames, causing those fields to be clipped rather than forcing horizontal scrollbars to appear. <P> Note:
     * If any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen columns} are included in this list they
     * will not be clipped.
     *
     * @return Current autoFitClipFields value. Default value is null
     */
    public String[] getAutoFitClipFields()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfString(getAttributeAsJavaScriptObject("autoFitClipFields"));
    }
    

    /**
     * Should this ListGrid automatically expand to accommodate the size of records and fields? <P> Valid settings are
     * <ul><li><code>"vertical"</code>: expand vertically to accommodate records.</li>     <li><code>"horizontal"</code>:
     * expand horizontally to accommodate fields.</li>     <li><code>"both"</code>: expand horizontally and vertically to
     * accommodate content.</li> </ul> How far the ListGrid will expand may be limited via the following properties: {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxHeight autoFitMaxHeight}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns}. <P> Note that this property causes
     * the grid as a whole to expand to fit records or fields. To have the fields or records themselves expand to fit cell
     * contents, see {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData}.
     *
     * @param autoFitData One of <code>"vertical"</code>, <code>"horizontal"</code>  or <code>"both"</code>. To disable auto fit behavior, pass in
     * <code>null</code>. Default value is null
     */
    public void setAutoFitData(Autofit autoFitData) {
        setAttribute("autoFitData", autoFitData == null ? null : autoFitData.getValue(), true);
    }

    /**
     * Should this ListGrid automatically expand to accommodate the size of records and fields? <P> Valid settings are
     * <ul><li><code>"vertical"</code>: expand vertically to accommodate records.</li>     <li><code>"horizontal"</code>:
     * expand horizontally to accommodate fields.</li>     <li><code>"both"</code>: expand horizontally and vertically to
     * accommodate content.</li> </ul> How far the ListGrid will expand may be limited via the following properties: {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxHeight autoFitMaxHeight}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns}. <P> Note that this property causes
     * the grid as a whole to expand to fit records or fields. To have the fields or records themselves expand to fit cell
     * contents, see {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}.
     *
     * @return Current autoFitData value. Default value is null
     */
    public Autofit getAutoFitData()  {
        return EnumUtil.getEnum(Autofit.values(), getAttribute("autoFitData"));
    }
    

    /**
     * Should listGrids automatically size date fields to fit their values or titles? If set to <code>"value"</code>, fields of
     * type date will be rendered at the size specified by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultDateFieldWidth defaultDateFieldWidth},  (or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultEditableDateFieldWidth defaultEditableDateFieldWidth} for editable
     * fields). This static value is appropriate for dates rendered with the standard short-date formatter. If set to
     * <code>"title"</code> or <code>"both"</code>, the drawn width of the title will be taken into account when sizing the
     * column. <P> This is achieved by enabling {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth
     * autoFitWidth:true} on date fields when this property is set to anything other than <code>"none"</code>, setting the
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach} to the
     * value specified here and having logic in {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} pick up the {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultDateFieldWidth
     * defaultDateFieldWidth} or {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultEditableDateFieldWidth
     * defaultEditableDateFieldWidth} if appropriate.
     *
     * @param autoFitDateFields New autoFitDateFields value. Default value is "value"
     */
    public void setAutoFitDateFields(AutoFitWidthApproach autoFitDateFields) {
        setAttribute("autoFitDateFields", autoFitDateFields == null ? null : autoFitDateFields.getValue(), true);
    }

    /**
     * Should listGrids automatically size date fields to fit their values or titles? If set to <code>"value"</code>, fields of
     * type date will be rendered at the size specified by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultDateFieldWidth defaultDateFieldWidth},  (or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultEditableDateFieldWidth defaultEditableDateFieldWidth} for editable
     * fields). This static value is appropriate for dates rendered with the standard short-date formatter. If set to
     * <code>"title"</code> or <code>"both"</code>, the drawn width of the title will be taken into account when sizing the
     * column. <P> This is achieved by enabling {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth
     * autoFitWidth:true} on date fields when this property is set to anything other than <code>"none"</code>, setting the
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach} to the
     * value specified here and having logic in {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} pick up the {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultDateFieldWidth
     * defaultDateFieldWidth} or {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultEditableDateFieldWidth
     * defaultEditableDateFieldWidth} if appropriate.
     *
     * @return Current autoFitDateFields value. Default value is "value"
     */
    public AutoFitWidthApproach getAutoFitDateFields()  {
        return EnumUtil.getEnum(AutoFitWidthApproach.values(), getAttribute("autoFitDateFields"));
    }
    

    /**
     * The field to expand if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldsFillViewport autoFitFieldsFillViewport} are enabled and
     * auto-fitting will not fill all available horizontal space. <P> If unset, will default to the text field with the longest
     * {@link com.smartgwt.client.data.DataSourceField#getLength DataSourceField.length} if length is set, otherwise, the first
     * text field with no width specified. <P> Note that expanding {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen columns} is not supported.
     *
     * @param autoFitExpandField New autoFitExpandField value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoFitExpandField(String autoFitExpandField)  throws IllegalStateException {
        setAttribute("autoFitExpandField", autoFitExpandField, false);
    }

    /**
     * The field to expand if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldsFillViewport autoFitFieldsFillViewport} are enabled and
     * auto-fitting will not fill all available horizontal space. <P> If unset, will default to the text field with the longest
     * {@link com.smartgwt.client.data.DataSourceField#getLength DataSourceField.length} if length is set, otherwise, the first
     * text field with no width specified. <P> Note that expanding {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen columns} is not supported.
     *
     * @return Current autoFitExpandField value. Default value is null
     */
    public String getAutoFitExpandField()  {
        return getAttributeAsString("autoFitExpandField");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code>, setting this property will cause the ListGrid body to size large enough to accomodate the actual
     * data and also leave this many extra rows' worth of blank space below the last record. If a maximum size is specified via
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxHeight autoFitMaxHeight} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords}, it will still be respected. Once the
     * data set is large enough to fill or exceed that space, this property no longer has an effect.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitExtraRecords autoFitExtraRecords}.
     *
     * @param autoFitExtraRecords Number of extra rows beyond the data-size we'll expand to accommodate if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData auto fit} is enabled vertically. Default value is null
     */
    public void setAutoFitExtraRecords(Integer autoFitExtraRecords) {
        setAttribute("autoFitExtraRecords", autoFitExtraRecords, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code>, setting this property will cause the ListGrid body to size large enough to accomodate the actual
     * data and also leave this many extra rows' worth of blank space below the last record. If a maximum size is specified via
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxHeight autoFitMaxHeight} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords}, it will still be respected. Once the
     * data set is large enough to fill or exceed that space, this property no longer has an effect.
     *
     * @return Current autoFitExtraRecords value. Default value is null
     */
    public Integer getAutoFitExtraRecords()  {
        return getAttributeAsInt("autoFitExtraRecords");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} is enabled, and extra
     * space is available after autofitting all fields, should the grid automatically expand one field to fill the extra space.
     * <P> When enabled, the field to expand may be specified via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitExpandField autoFitExpandField}. <P> Note this logic will not expand
     * a {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen column}.
     *
     * @param autoFitFieldsFillViewport New autoFitFieldsFillViewport value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoFitFieldsFillViewport(Boolean autoFitFieldsFillViewport)  throws IllegalStateException {
        setAttribute("autoFitFieldsFillViewport", autoFitFieldsFillViewport, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} is enabled, and extra
     * space is available after autofitting all fields, should the grid automatically expand one field to fill the extra space.
     * <P> When enabled, the field to expand may be specified via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitExpandField autoFitExpandField}. <P> Note this logic will not expand
     * a {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen column}.
     *
     * @return Current autoFitFieldsFillViewport value. Default value is true
     */
    public Boolean getAutoFitFieldsFillViewport()  {
        Boolean result = getAttributeAsBoolean("autoFitFieldsFillViewport");
        return result == null ? true : result;
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and user-driven auto fit of fields is enabled via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields}, this attribute will be shown as the
     * menu item title for an item to perform a one-time autoFit of the field to its title or content via a call to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#autoFitField autoFitField()}.
     *
     * @param autoFitFieldText New autoFitFieldText value. Default value is "Auto Fit"
     */
    public void setAutoFitFieldText(String autoFitFieldText) {
        setAttribute("autoFitFieldText", autoFitFieldText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and user-driven auto fit of fields is enabled via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields}, this attribute will be shown as the
     * menu item title for an item to perform a one-time autoFit of the field to its title or content via a call to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#autoFitField autoFitField()}.
     *
     * @return Current autoFitFieldText value. Default value is "Auto Fit"
     */
    public String getAutoFitFieldText()  {
        return getAttributeAsString("autoFitFieldText");
    }
    

    /**
     * Should ListGrid fields autofit their widths to titles or content? This property may be overridden on a per-field basis
     * via {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}. Developers may
     * wish to consider disabling autoFit for fields known to have  exceptionally long content as this can lead to large
     * horizontal scrollbars and unwieldy UI. <P> The {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach
     * autoFitWidthApproach} controls whether fitting is to values, titles or both. This property may also be overridden on a
     * per field basis. <P> If {@link com.smartgwt.client.widgets.grid.ListGridField#getWidth field.width} is also set on the
     * field, it will be taken as a minimum width. {@link com.smartgwt.client.widgets.grid.ListGrid#getMinFieldWidth
     * minFieldWidth} will also be respected. <P> By default, the entire available width of the grid will still be used, by
     * allocating any "extra" space to specific columns - see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldsFillViewport autoFitFieldsFillViewport} for details on
     * controlling this behavior. <P> When this feature is enabled, autofitting is active on an ongoing basis. Autofitting will
     * be performed: <ul>  <li> whenever the dataset is completely changed or rows are added or removed  <li> whenever a field
     * which is autofitting is changed  <li> on a manual call to {@link com.smartgwt.client.widgets.grid.ListGrid#autoFitField
     * autoFitField()} or       {@link com.smartgwt.client.widgets.grid.ListGrid#autoFitFields autoFitFields()} </ul>
     * Auto-fitting behavior continues until the user resizes the field manually, at which point it stops. The user can also
     * perform a one-time auto-fit of fields via the header context menu if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} is enabled. <P> When autofitting to
     * column values, {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} will be
     * called to determine the space required for a field's values. This method uses values from the rendered set of rows to
     * calculate the required column width, which means the field width may still be smaller than values from non-rendered
     * rows.  See {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllRecords showAllRecords} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio}) to control incremental rendering of rows.
     * <P> Note that for <code>icon</code> type fields, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitIconFields autoFitIconFields} property setting may turn on
     * auto-fit-width behavior for specific fields by default, even if <code>autoFitFieldWidths</code> is false for the grid as
     * a whole. <P> Using this feature has a performance penalty roughly comparable to always rendering one additional field
     * per field where autofitting is enabled.  Specifically, enabling it for all fields would be comparable to <i>both</i>
     * doubling the number of fields <i>and</i> disabling {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllColumns
     * horizontal incremental rendering}. In a grid where only half the fields are normally visible and hence only half are
     * normally rendered, this would be roughly 4 times slower overall. <P> This performance penalty is a result of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} having to render out the data set
     * offscreen and measure the rendered content - it does not apply for cases where this method can return a simple fixed
     * values (as with icon fields). <P> Which fields are currently autofitting is saved as part of the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getViewState view state} of the ListGrid. <P> Interaction with wrapping: If
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapping of cell values} is  enabled, autoFit behavior
     * based on {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach cell content} will render fields wide
     * enough to contain the <i>unwrapped</i> cell values. If {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap
     * wrapping of field titles} is enabled, when fitting to  a title, a field will render wide enough to accomodate the
     * <i>wrapped</i> title without clipping (so wide enough for the natural wrap-point / longest word or unwrappable string).
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths}. Modifies the default auto-fit-width behavior for fields in this grid. Note that this may be overridden at the field level via {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}.
     *
     * @param autoFitFieldWidths New value for autoFitFieldWidths. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoFitFieldWidths(Boolean autoFitFieldWidths)  throws IllegalStateException {
        setAttribute("autoFitFieldWidths", autoFitFieldWidths, false);
    }

    /**
     * Should ListGrid fields autofit their widths to titles or content? This property may be overridden on a per-field basis
     * via {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}. Developers may
     * wish to consider disabling autoFit for fields known to have  exceptionally long content as this can lead to large
     * horizontal scrollbars and unwieldy UI. <P> The {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach
     * autoFitWidthApproach} controls whether fitting is to values, titles or both. This property may also be overridden on a
     * per field basis. <P> If {@link com.smartgwt.client.widgets.grid.ListGridField#getWidth field.width} is also set on the
     * field, it will be taken as a minimum width. {@link com.smartgwt.client.widgets.grid.ListGrid#getMinFieldWidth
     * minFieldWidth} will also be respected. <P> By default, the entire available width of the grid will still be used, by
     * allocating any "extra" space to specific columns - see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldsFillViewport autoFitFieldsFillViewport} for details on
     * controlling this behavior. <P> When this feature is enabled, autofitting is active on an ongoing basis. Autofitting will
     * be performed: <ul>  <li> whenever the dataset is completely changed or rows are added or removed  <li> whenever a field
     * which is autofitting is changed  <li> on a manual call to {@link com.smartgwt.client.widgets.grid.ListGrid#autoFitField
     * autoFitField()} or       {@link com.smartgwt.client.widgets.grid.ListGrid#autoFitFields autoFitFields()} </ul>
     * Auto-fitting behavior continues until the user resizes the field manually, at which point it stops. The user can also
     * perform a one-time auto-fit of fields via the header context menu if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} is enabled. <P> When autofitting to
     * column values, {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} will be
     * called to determine the space required for a field's values. This method uses values from the rendered set of rows to
     * calculate the required column width, which means the field width may still be smaller than values from non-rendered
     * rows.  See {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllRecords showAllRecords} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio}) to control incremental rendering of rows.
     * <P> Note that for <code>icon</code> type fields, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitIconFields autoFitIconFields} property setting may turn on
     * auto-fit-width behavior for specific fields by default, even if <code>autoFitFieldWidths</code> is false for the grid as
     * a whole. <P> Using this feature has a performance penalty roughly comparable to always rendering one additional field
     * per field where autofitting is enabled.  Specifically, enabling it for all fields would be comparable to <i>both</i>
     * doubling the number of fields <i>and</i> disabling {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllColumns
     * horizontal incremental rendering}. In a grid where only half the fields are normally visible and hence only half are
     * normally rendered, this would be roughly 4 times slower overall. <P> This performance penalty is a result of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} having to render out the data set
     * offscreen and measure the rendered content - it does not apply for cases where this method can return a simple fixed
     * values (as with icon fields). <P> Which fields are currently autofitting is saved as part of the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getViewState view state} of the ListGrid. <P> Interaction with wrapping: If
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapping of cell values} is  enabled, autoFit behavior
     * based on {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach cell content} will render fields wide
     * enough to contain the <i>unwrapped</i> cell values. If {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap
     * wrapping of field titles} is enabled, when fitting to  a title, a field will render wide enough to accomodate the
     * <i>wrapped</i> title without clipping (so wide enough for the natural wrap-point / longest word or unwrappable string).
     *
     * @return Current autoFitFieldWidths value. Default value is null
     */
    public Boolean getAutoFitFieldWidths()  {
        return getAttributeAsBoolean("autoFitFieldWidths");
    }
    

    /**
     * If this property is set to true, header buttons for either {@link com.smartgwt.client.widgets.grid.ListGrid#getFields
     * fields} or {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans header spans} will automatically expand to
     * accommodate their titles vertically.  This means if you have a "tall" title - typically a long string where {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getWrap ListGridField.wrap} is set to true such that you end up with
     * several lines of text - the button will render large enough to accommodate it.  If necessary this will cause the header
     * for the grid as a whole to expand beyond the specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight
     * headerHeight}. <P> Note that you need not set {@link com.smartgwt.client.widgets.grid.HeaderSpan#getHeight
     * HeaderSpan.height} or {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpanHeight headerSpanHeight} if you set
     * this property, but if you do, they will be used as minimum values.
     *
     * @param autoFitHeaderHeights New autoFitHeaderHeights value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoFitHeaderHeights(Boolean autoFitHeaderHeights)  throws IllegalStateException {
        setAttribute("autoFitHeaderHeights", autoFitHeaderHeights, false);
    }

    /**
     * If this property is set to true, header buttons for either {@link com.smartgwt.client.widgets.grid.ListGrid#getFields
     * fields} or {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans header spans} will automatically expand to
     * accommodate their titles vertically.  This means if you have a "tall" title - typically a long string where {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getWrap ListGridField.wrap} is set to true such that you end up with
     * several lines of text - the button will render large enough to accommodate it.  If necessary this will cause the header
     * for the grid as a whole to expand beyond the specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight
     * headerHeight}. <P> Note that you need not set {@link com.smartgwt.client.widgets.grid.HeaderSpan#getHeight
     * HeaderSpan.height} or {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpanHeight headerSpanHeight} if you set
     * this property, but if you do, they will be used as minimum values.
     *
     * @return Current autoFitHeaderHeights value. Default value is null
     */
    public Boolean getAutoFitHeaderHeights()  {
        return getAttributeAsBoolean("autoFitHeaderHeights");
    }
    

    /**
     * Smart GWT listGrids have special logic to automatically size fields that are displayed as an icon - that is fields with
     * {@link com.smartgwt.client.types.ListGridFieldType type:"icon"}, fields displaying only {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowValueIconOnly value icons}, and boolean fields (which are rendered
     * as a checkmark type icon by default. <P> This attribute controls this behavior - governing whether icon fields should be
     * sized to fit their content (icon), title, or whether to disable this behavior. Setting this value to
     * <code>"title"</code> or <code>"iconWidth"</code> will cause {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth} to be enabled by default for
     * all icon fields with the {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach
     * ListGridField.autoFitWidthApproach} set to <code>"value"</code> or <code>"both"</code> as appropriate. Note that the
     * width required for the icons is calculated by {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} which performs a simple calculation based on the specified icon width for these types of fields.
     * <P> This setting governs default behavior for icon fields - for specific fields within a grid, this default behavior can
     * be overridden by setting an explicit {@link com.smartgwt.client.widgets.grid.ListGridField#getWidth ListGridField.width}
     * or explicitly enabling {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}
     * and setting {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach
     * ListGridField.autoFitWidthApproach} on the field in question.
     *
     * @param autoFitIconFields New autoFitIconFields value. Default value is "title"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setAutoFitFieldWidths
     */
    public void setAutoFitIconFields(AutoFitIconFieldType autoFitIconFields) {
        setAttribute("autoFitIconFields", autoFitIconFields == null ? null : autoFitIconFields.getValue(), true);
    }

    /**
     * Smart GWT listGrids have special logic to automatically size fields that are displayed as an icon - that is fields with
     * {@link com.smartgwt.client.types.ListGridFieldType type:"icon"}, fields displaying only {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowValueIconOnly value icons}, and boolean fields (which are rendered
     * as a checkmark type icon by default. <P> This attribute controls this behavior - governing whether icon fields should be
     * sized to fit their content (icon), title, or whether to disable this behavior. Setting this value to
     * <code>"title"</code> or <code>"iconWidth"</code> will cause {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth} to be enabled by default for
     * all icon fields with the {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach
     * ListGridField.autoFitWidthApproach} set to <code>"value"</code> or <code>"both"</code> as appropriate. Note that the
     * width required for the icons is calculated by {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} which performs a simple calculation based on the specified icon width for these types of fields.
     * <P> This setting governs default behavior for icon fields - for specific fields within a grid, this default behavior can
     * be overridden by setting an explicit {@link com.smartgwt.client.widgets.grid.ListGridField#getWidth ListGridField.width}
     * or explicitly enabling {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}
     * and setting {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach
     * ListGridField.autoFitWidthApproach} on the field in question.
     *
     * @return Current autoFitIconFields value. Default value is "title"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths
     */
    public AutoFitIconFieldType getAutoFitIconFields()  {
        return EnumUtil.getEnum(AutoFitIconFieldType.values(), getAttribute("autoFitIconFields"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides the maximum number of columns for which the ListGrid will expand. If more
     * columns are present, scrolling will be introduced to reach them as normal. If unset the ListGrid will expand to
     * accommodate as many columns as are defined for the grid.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns}.
     *
     * @param autoFitMaxColumns Maximum number of fields we'll expand to accommodate if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * auto fit} is enabled horizontally. Default value is 50
     */
    public void setAutoFitMaxColumns(int autoFitMaxColumns) {
        setAttribute("autoFitMaxColumns", autoFitMaxColumns, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides the maximum number of columns for which the ListGrid will expand. If more
     * columns are present, scrolling will be introduced to reach them as normal. If unset the ListGrid will expand to
     * accommodate as many columns as are defined for the grid.
     *
     * @return Current autoFitMaxColumns value. Default value is 50
     */
    public int getAutoFitMaxColumns()  {
        return getAttributeAsInt("autoFitMaxColumns");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand vertically to accommodate
     * its content. If content exceeds this height, scrollbars will be introduced as usual. In addition to this property,
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords} allows you to limit vertical
     * expansion based on the number of rows to be rendered.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxHeight autoFitMaxHeight}.
     *
     * @param autoFitMaxHeight Maximum height in px we'll expand to accommodate if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData auto
     * fit} is enabled vertically. Default value is null
     */
    public void setAutoFitMaxHeight(Integer autoFitMaxHeight) {
        setAttribute("autoFitMaxHeight", autoFitMaxHeight, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand vertically to accommodate
     * its content. If content exceeds this height, scrollbars will be introduced as usual. In addition to this property,
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords} allows you to limit vertical
     * expansion based on the number of rows to be rendered.
     *
     * @return Current autoFitMaxHeight value. Default value is null
     */
    public Integer getAutoFitMaxHeight()  {
        return getAttributeAsInt("autoFitMaxHeight");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code> this property provides the maximum number of records for which the ListGrid will expand. If more
     * records are present, scrolling will be introduced to reach them as normal. If unset, by default the ListGrid will expand
     * to accommodate as many records as are present.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxRecords autoFitMaxRecords}.
     *
     * @param autoFitMaxRecords Maximum number of rows we'll expand to accommodate if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * auto fit} is enabled vertically. Default value is 50
     */
    public void setAutoFitMaxRecords(int autoFitMaxRecords) {
        setAttribute("autoFitMaxRecords", autoFitMaxRecords, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"vertical"</code> or
     * <code>"both"</code> this property provides the maximum number of records for which the ListGrid will expand. If more
     * records are present, scrolling will be introduced to reach them as normal. If unset, by default the ListGrid will expand
     * to accommodate as many records as are present.
     *
     * @return Current autoFitMaxRecords value. Default value is 50
     */
    public int getAutoFitMaxRecords()  {
        return getAttributeAsInt("autoFitMaxRecords");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand horizontally to
     * accommodate its content. Value may be specified as a numeric pixel value or a percentage value. <P> If content exceeds
     * this width, scrollbars will be introduced as usual. In addition to this property, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns} allows you to limit horizontal
     * expansion based on the number of columns to be rendered.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}.
     *
     * @param autoFitMaxWidth Width we'll expand to accommodate if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData auto fit} is
     * enabled horizontally. Default value is null
     */
    public void setAutoFitMaxWidth(Integer autoFitMaxWidth) {
        setAttribute("autoFitMaxWidth", autoFitMaxWidth, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand horizontally to
     * accommodate its content. Value may be specified as a numeric pixel value or a percentage value. <P> If content exceeds
     * this width, scrollbars will be introduced as usual. In addition to this property, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns} allows you to limit horizontal
     * expansion based on the number of columns to be rendered.
     *
     * @return Returns the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}. Note that this method
     * always returns an integer value - autoFitMaxWidth specified as a percentage will be resolved to a pixel value before
     * being returned. Default value is null
     */
    public Integer getAutoFitMaxWidth()  {
        return getAttributeAsInt("autoFitMaxWidth");
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand horizontally to
     * accommodate its content. Value may be specified as a numeric pixel value or a percentage value. <P> If content exceeds
     * this width, scrollbars will be introduced as usual. In addition to this property, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns} allows you to limit horizontal
     * expansion based on the number of columns to be rendered.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}.
     *
     * @param autoFitMaxWidth Width we'll expand to accommodate if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData auto fit} is
     * enabled horizontally. Default value is null
     */
    public void setAutoFitMaxWidth(String autoFitMaxWidth) {
        setAttribute("autoFitMaxWidth", autoFitMaxWidth, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData autoFitData} is set to <code>"horizontal"</code> or
     * <code>"both"</code> this property provides an upper limit on how far the ListGrid will expand horizontally to
     * accommodate its content. Value may be specified as a numeric pixel value or a percentage value. <P> If content exceeds
     * this width, scrollbars will be introduced as usual. In addition to this property, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxColumns autoFitMaxColumns} allows you to limit horizontal
     * expansion based on the number of columns to be rendered.
     *
     * @return Returns the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitMaxWidth autoFitMaxWidth}. Note that this method
     * always returns an integer value - autoFitMaxWidth specified as a percentage will be resolved to a pixel value before
     * being returned. Default value is null
     */
    public String getAutoFitMaxWidthAsString()  {
        return getAttributeAsString("autoFitMaxWidth");
    }
    

    /**
     * Should listGrids automatically size time fields to fit their values or titles? If set to <code>"value"</code>, fields of
     * type time will be rendered at the size specified by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultTimeFieldWidth defaultTimeFieldWidth}. This static value is
     * appropriate for dates rendered with the standard time formatter. If set to <code>"title"</code> or <code>"both"</code>,
     * the drawn width of the title will be taken into account when sizing the column. <P> This is achieved by enabling {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth autoFitWidth:true} on date fields when this property is
     * set to anything other than <code>"none"</code>, setting the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach} to the value
     * specified here and having logic in {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} pick up the {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultTimeFieldWidth
     * defaultTimeFieldWidth} if appropriate.
     *
     * @param autoFitTimeFields New autoFitTimeFields value. Default value is "value"
     */
    public void setAutoFitTimeFields(AutoFitWidthApproach autoFitTimeFields) {
        setAttribute("autoFitTimeFields", autoFitTimeFields == null ? null : autoFitTimeFields.getValue(), true);
    }

    /**
     * Should listGrids automatically size time fields to fit their values or titles? If set to <code>"value"</code>, fields of
     * type time will be rendered at the size specified by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultTimeFieldWidth defaultTimeFieldWidth}. This static value is
     * appropriate for dates rendered with the standard time formatter. If set to <code>"title"</code> or <code>"both"</code>,
     * the drawn width of the title will be taken into account when sizing the column. <P> This is achieved by enabling {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth autoFitWidth:true} on date fields when this property is
     * set to anything other than <code>"none"</code>, setting the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach} to the value
     * specified here and having logic in {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth
     * getDefaultFieldWidth()} pick up the {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultTimeFieldWidth
     * defaultTimeFieldWidth} if appropriate.
     *
     * @return Current autoFitTimeFields value. Default value is "value"
     */
    public AutoFitWidthApproach getAutoFitTimeFields()  {
        return EnumUtil.getEnum(AutoFitWidthApproach.values(), getAttribute("autoFitTimeFields"));
    }
    

    /**
     * When a user requests column autofitting via the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderContextMenuItems header context menu} or via a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderAutoFitEvent mouse gesture}, what autofit approach is used.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach autoFitWidthApproach}.
     *
     * @param autoFitWidthApproach new AutoFitWidth approach. Default value is "value"
     */
    public void setAutoFitWidthApproach(AutoFitWidthApproach autoFitWidthApproach) {
        setAttribute("autoFitWidthApproach", autoFitWidthApproach == null ? null : autoFitWidthApproach.getValue(), true);
    }

    /**
     * When a user requests column autofitting via the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderContextMenuItems header context menu} or via a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderAutoFitEvent mouse gesture}, what autofit approach is used.
     *
     * @return Current autoFitWidthApproach value. Default value is "value"
     */
    public AutoFitWidthApproach getAutoFitWidthApproach()  {
        return EnumUtil.getEnum(AutoFitWidthApproach.values(), getAttribute("autoFitWidthApproach"));
    }
    

    /**
     * If this ListGrid is editable, should edits be saved out when the user finishes editing a row (or a cell if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell saveByCell} is true). <P> The default of <code>true</code>
     * indicates that edits will be {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell automatically saved} as the
     * user navigates through the grid and/or {@link com.smartgwt.client.types.EnterKeyEditAction hits 'Enter'} to end editing.
     * See the {@link com.smartgwt.client.docs.Editing Grid Editing} overview for details. <P> Setting
     * <code>autoSaveEdits</code> false creates a "mass update" / "mass delete" interaction where edits will be retained for
     * all edited cells (across rows if appropriate) until {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits
     * saveEdits()} is called to save a particular row, or {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits
     * saveAllEdits()} is called to save all changes in a batch. <P> <b>Note:</b> when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByField listGrid grouping} is enabled, or when working with
     * hierarchical data in a {@link com.smartgwt.client.widgets.tree.TreeGrid}, users have the option to hide records from
     * view by collapsing the parent folder or group. This, in conjunction with <code>autoSaveEdits</code> being set to
     * <code>false</code> can lead to a case where a user is unable to save edits due to validation errors on hidden rows.
     * Therefore we recommend developers consider having validators in place such that errors are caught and displayed to the
     * user on change or editor exit rather than being caught only when saving is attempted. If it's not possible for all
     * validation to be performed immediately  on row exit, we recommend that a different UI design be used that does not
     * involve <code>autoSaveEdits</code> being set to <code>false</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param autoSaveEdits New autoSaveEdits value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setAutoSaveEdits(Boolean autoSaveEdits) {
        setAttribute("autoSaveEdits", autoSaveEdits, true);
    }

    /**
     * If this ListGrid is editable, should edits be saved out when the user finishes editing a row (or a cell if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell saveByCell} is true). <P> The default of <code>true</code>
     * indicates that edits will be {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell automatically saved} as the
     * user navigates through the grid and/or {@link com.smartgwt.client.types.EnterKeyEditAction hits 'Enter'} to end editing.
     * See the {@link com.smartgwt.client.docs.Editing Grid Editing} overview for details. <P> Setting
     * <code>autoSaveEdits</code> false creates a "mass update" / "mass delete" interaction where edits will be retained for
     * all edited cells (across rows if appropriate) until {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits
     * saveEdits()} is called to save a particular row, or {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits
     * saveAllEdits()} is called to save all changes in a batch. <P> <b>Note:</b> when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByField listGrid grouping} is enabled, or when working with
     * hierarchical data in a {@link com.smartgwt.client.widgets.tree.TreeGrid}, users have the option to hide records from
     * view by collapsing the parent folder or group. This, in conjunction with <code>autoSaveEdits</code> being set to
     * <code>false</code> can lead to a case where a user is unable to save edits due to validation errors on hidden rows.
     * Therefore we recommend developers consider having validators in place such that errors are caught and displayed to the
     * user on change or editor exit rather than being caught only when saving is attempted. If it's not possible for all
     * validation to be performed immediately  on row exit, we recommend that a different UI design be used that does not
     * involve <code>autoSaveEdits</code> being set to <code>false</code>.
     *
     * @return Current autoSaveEdits value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getAutoSaveEdits()  {
        Boolean result = getAttributeAsBoolean("autoSaveEdits");
        return result == null ? true : result;
    }
    

    /**
     * If this listGrid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, setting
     * this attribute to true will cause spans to expand to accommodate long titles if necessary.
     *
     * @param autoSizeHeaderSpans New autoSizeHeaderSpans value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setAutoSizeHeaderSpans(Boolean autoSizeHeaderSpans)  throws IllegalStateException {
        setAttribute("autoSizeHeaderSpans", autoSizeHeaderSpans, false);
    }

    /**
     * If this listGrid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, setting
     * this attribute to true will cause spans to expand to accommodate long titles if necessary.
     *
     * @return Current autoSizeHeaderSpans value. Default value is false
     */
    public Boolean getAutoSizeHeaderSpans()  {
        Boolean result = getAttributeAsBoolean("autoSizeHeaderSpans");
        return result == null ? false : result;
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Has no effect unless {@link com.smartgwt.client.widgets.grid.ListGrid#getShowBackgroundComponents
     * showBackgroundComponents} is <code>true</code>. <P> Canvas created and embedded in the body behind a given record.  
     * When {@link com.smartgwt.client.widgets.grid.ListGridRecord#getBackgroundComponent ListGridRecord.backgroundComponent}
     * is set, this autoChild canvas will be constructed (if listGridRecord.backgroundComponent is not already a Canvas) and
     * its properties combined with those of listGridRecord.backgroundComponent and then displayed behind a specific record in
     * the page's z-order, meaning it will only be visible if the cell styling is transparent.
     *
     * @return null
     */
    public Canvas getBackgroundComponent()  {
        return null;
    }
    

    /**
     * If the result of a formula evaluation is invalid (specifically, if isNaN(result)==true), badFormulaResultValue is
     * displayed instead.  The default value is ".".
     *
     * @param badFormulaResultValue New badFormulaResultValue value. Default value is "."
     * @see com.smartgwt.client.docs.FormulaFields FormulaFields overview and related methods
     */
    public void setBadFormulaResultValue(String badFormulaResultValue) {
        setAttribute("badFormulaResultValue", badFormulaResultValue, true);
    }

    /**
     * If the result of a formula evaluation is invalid (specifically, if isNaN(result)==true), badFormulaResultValue is
     * displayed instead.  The default value is ".".
     *
     * @return Current badFormulaResultValue value. Default value is "."
     * @see com.smartgwt.client.docs.FormulaFields FormulaFields overview and related methods
     */
    public String getBadFormulaResultValue()  {
        return getAttributeAsString("badFormulaResultValue");
    }
    

    /**
     * {@link com.smartgwt.client.widgets.grid.GridRenderer#getBaseStyle base cell style} for this listGrid. If this property
     * is unset, base style may be derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle
     * normalBaseStyle} or {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} as described in
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle getBaseStyle()}. <P> See {@link
     * com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are combined with the base style to
     * generate stateful cell styles.
     *
     * @param baseStyle New baseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setBaseStyle(String baseStyle)  throws IllegalStateException {
        setAttribute("baseStyle", baseStyle, false);
    }

    /**
     * {@link com.smartgwt.client.widgets.grid.GridRenderer#getBaseStyle base cell style} for this listGrid. If this property
     * is unset, base style may be derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle
     * normalBaseStyle} or {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} as described in
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle getBaseStyle()}. <P> See {@link
     * com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are combined with the base style to
     * generate stateful cell styles.
     *
     * @return Return the base styleName for this cell.  Has the following implementation by default: <ul> <li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditFailedBaseStyle this.editFailedBaseStyle} is defined, and the     cell
     * is displaying a validation error return this value.</li> <li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditPendingBaseStyle this.editFailedPendingStyle} is defined, and     the
     * cell is displaying an edit value that has not yet been saved (see     {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits}) return this value.</li> <li>Otherwise return
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordBaseStyleProperty record[listGrid.recordBaseStyleProperty]},  
     * if defined, otherwise {@link com.smartgwt.client.widgets.grid.ListGridField#getBaseStyle field.baseStyle}.</li> </ul> If
     * no custom style is found for the cell as described above, the default baseStyle will be returned. If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} is specified this will be used. Otherwise for grids
     * showing fixed height rows which match {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight
     * normalCellHeight} {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} will be used. For
     * grids with variable, or modified cell heights, {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle
     * tallBaseStyle} will be used. <P> Note also that enabling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} will cause the <code>tallBaseStyle</code>
     * to be used rather than {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle}. <P> As
     * noted under {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping enforceVClipping}, cell content which
     * renders taller than the available space within a cell may cause rows to expand even if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}  is true. This can lead to
     * misaligned rows when frozen columns are used. Developers should be aware that changing cell styling such that there is
     * increased borders or padding will reduce the available space for content within the specified cell height, making this
     * scenario more common. To fix this, specify a larger cellHeight, or set enforceVClipping to true. <p> <b>Note: This is an
     * override point.</b>. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getBaseStyle()  {
        return getAttributeAsString("baseStyle");
    }
    
    

    /**
     * Background color applied to the ListGrid body (that is, the area of the grid where data values are rendered).<br> Note
     * that this will typically not be visible to the user unless there are few enough rows that there is visible space in the
     * body below the last row. To style data cells, override {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} instead.
     *
     * @param bodyBackgroundColor New bodyBackgroundColor value. Default value is "white"
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setBodyBackgroundColor(String bodyBackgroundColor) {
        setAttribute("bodyBackgroundColor", bodyBackgroundColor, true);
    }

    /**
     * Background color applied to the ListGrid body (that is, the area of the grid where data values are rendered).<br> Note
     * that this will typically not be visible to the user unless there are few enough rows that there is visible space in the
     * body below the last row. To style data cells, override {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} instead.
     *
     * @return Current bodyBackgroundColor value. Default value is "white"
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getBodyBackgroundColor()  {
        return getAttributeAsString("bodyBackgroundColor");
    }
    

    /**
     * Overflow setting for the "body", that is, the area of the grid where data values are rendered. <P> <b>This is a very
     * advanced setting</b> which is typically only changed by subclasses of ListGrid which never show a header.  To achieve
     * auto-fitting, instead use properties such as {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * autoFitData}, {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Update the {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyOverflow bodyOverflow} for this listGrid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param bodyOverflow new overflow setting for the body. Default value is Canvas.AUTO
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public void setBodyOverflow(Overflow bodyOverflow) {
        setAttribute("bodyOverflow", bodyOverflow == null ? null : bodyOverflow.getValue(), true);
    }

    /**
     * Overflow setting for the "body", that is, the area of the grid where data values are rendered. <P> <b>This is a very
     * advanced setting</b> which is typically only changed by subclasses of ListGrid which never show a header.  To achieve
     * auto-fitting, instead use properties such as {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * autoFitData}, {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}.
     *
     * @return Current bodyOverflow value. Default value is Canvas.AUTO
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public Overflow getBodyOverflow()  {
        return EnumUtil.getEnum(Overflow.values(), getAttribute("bodyOverflow"));
    }
    

    /**
     * CSS style used for the body of this grid.  If applying a background-color to the body via a CSS style applied using this
     * property, be sure to set {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyBackgroundColor bodyBackgroundColor} to
     * <code>null</code>.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Update the {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyStyleName bodyStyleName} for this listGrid.
     *
     * @param bodyStyleName new body style name. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setBodyStyleName(String bodyStyleName) {
        setAttribute("bodyStyleName", bodyStyleName, true);
    }

    /**
     * CSS style used for the body of this grid.  If applying a background-color to the body via a CSS style applied using this
     * property, be sure to set {@link com.smartgwt.client.widgets.grid.ListGrid#getBodyBackgroundColor bodyBackgroundColor} to
     * <code>null</code>.
     *
     * @return Current bodyStyleName value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getBodyStyleName()  {
        return getAttributeAsString("bodyStyleName");
    }
    

    /**
     * An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is enabled, the base style is
     * suffixed with "True", "False", or "Partial" if the checkbox is selected, unselected, or partially selected; if the
     * checkbox is disabled, the suffix is "TrueDisabled", "FalseDisabled", or "PartialDisabled". <p> <b>NOTE:</b> This
     * attribute is not supported by {@link com.smartgwt.client.widgets.tree.TreeGrid}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanBaseStyle New booleanBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintBooleanBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanBaseStyle(String booleanBaseStyle)  throws IllegalStateException {
        setAttribute("booleanBaseStyle", booleanBaseStyle, false);
    }

    /**
     * An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is enabled, the base style is
     * suffixed with "True", "False", or "Partial" if the checkbox is selected, unselected, or partially selected; if the
     * checkbox is disabled, the suffix is "TrueDisabled", "FalseDisabled", or "PartialDisabled". <p> <b>NOTE:</b> This
     * attribute is not supported by {@link com.smartgwt.client.widgets.tree.TreeGrid}.
     *
     * @return Current booleanBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public String getBooleanBaseStyle()  {
        return getAttributeAsString("booleanBaseStyle");
    }
    

    /**
     * Image to display for a false value in a boolean field. Default <code>null</code> value or the special value "blank"
     * means no image will be displayed. <P> To turn this off explicitly set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon ListGridField.suppressValueIcon} to true <P> If
     * this, {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getUncheckedImage CheckboxItem.uncheckedImage}. <P>
     * <P> {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image, by setting this property to a {@link
     * com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers can omit this property and instead
     * use CSS directly in the  {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property
     * to provide a "boolean false" appearance.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanFalseImage New booleanFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanPartialImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintBooleanFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanFalseImage(String booleanFalseImage) {
        setAttribute("booleanFalseImage", booleanFalseImage, true);
    }

    /**
     * Image to display for a false value in a boolean field. Default <code>null</code> value or the special value "blank"
     * means no image will be displayed. <P> To turn this off explicitly set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon ListGridField.suppressValueIcon} to true <P> If
     * this, {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getUncheckedImage CheckboxItem.uncheckedImage}. <P>
     * <P> {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image, by setting this property to a {@link
     * com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers can omit this property and instead
     * use CSS directly in the  {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property
     * to provide a "boolean false" appearance.
     *
     * @return Current booleanFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public String getBooleanFalseImage()  {
        return getAttributeAsString("booleanFalseImage");
    }
    

    /**
     * Height for the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage}. Note: If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} is unset, the {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage} will be used to indicate
     * a true value in a boolean field. In this case this property is ignored in favor of {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getValueIconHeight CheckboxItem.valueIconHeight}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanImageHeight New booleanImageHeight value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanImageHeight(int booleanImageHeight) {
        setAttribute("booleanImageHeight", booleanImageHeight, true);
    }

    /**
     * Height for the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage}. Note: If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} is unset, the {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage} will be used to indicate
     * a true value in a boolean field. In this case this property is ignored in favor of {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getValueIconHeight CheckboxItem.valueIconHeight}.
     *
     * @return Current booleanImageHeight value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getBooleanImageHeight()  {
        return getAttributeAsInt("booleanImageHeight");
    }
    

    /**
     * Width for the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage}. Note: If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} is unset, the {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage} will be used to indicate
     * a true value in a boolean field. In this case this property is ignored in favor of {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getValueIconWidth CheckboxItem.valueIconWidth}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanImageWidth New booleanImageWidth value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanImageWidth(int booleanImageWidth) {
        setAttribute("booleanImageWidth", booleanImageWidth, true);
    }

    /**
     * Width for the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage}. Note: If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} is unset, the {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage} will be used to indicate
     * a true value in a boolean field. In this case this property is ignored in favor of {@link
     * com.smartgwt.client.widgets.form.fields.CheckboxItem#getValueIconWidth CheckboxItem.valueIconWidth}.
     *
     * @return Current booleanImageWidth value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getBooleanImageWidth()  {
        return getAttributeAsInt("booleanImageWidth");
    }
    

    /**
     * Image to display for a partially true value in a boolean field (typically selection). The special value "blank" means
     * that no image will be shown. <P> To turn this off explicitly set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon ListGridField.suppressValueIcon} to true. <P> If
     * this, {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPartialSelectedImage
     * CheckboxItem.partialSelectedImage}. <P> {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image,
     * by setting this property to a {@link com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers
     * can omit this property and instead use CSS directly in the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property to provide a "boolean true"
     * appearance.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanPartialImage New booleanPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintBooleanPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanPartialImage(String booleanPartialImage) {
        setAttribute("booleanPartialImage", booleanPartialImage, true);
    }

    /**
     * Image to display for a partially true value in a boolean field (typically selection). The special value "blank" means
     * that no image will be shown. <P> To turn this off explicitly set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon ListGridField.suppressValueIcon} to true. <P> If
     * this, {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPartialSelectedImage
     * CheckboxItem.partialSelectedImage}. <P> {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image,
     * by setting this property to a {@link com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers
     * can omit this property and instead use CSS directly in the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property to provide a "boolean true"
     * appearance.
     *
     * @return Current booleanPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public String getBooleanPartialImage()  {
        return getAttributeAsString("booleanPartialImage");
    }
    

    /**
     * Image to display for a true value in a boolean field. The special value "blank" means that no image will be shown. <P>
     * To turn this off explicitly set {@link com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon
     * ListGridField.suppressValueIcon} to true. <P> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage}. <P>
     * {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image, by setting this property to a {@link
     * com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers can omit this property and instead
     * use CSS directly in the  {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property
     * to provide a "boolean true" appearance.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param booleanTrueImage New booleanTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanPartialImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintBooleanTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setBooleanTrueImage(String booleanTrueImage) {
        setAttribute("booleanTrueImage", booleanTrueImage, true);
    }

    /**
     * Image to display for a true value in a boolean field. The special value "blank" means that no image will be shown. <P>
     * To turn this off explicitly set {@link com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon
     * ListGridField.suppressValueIcon} to true. <P> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} are unset, this will be set to the
     * default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getCheckedImage CheckboxItem.checkedImage}. <P>
     * {@link com.smartgwt.client.docs.Skinning Spriting} can be used for this image, by setting this property to a {@link
     * com.smartgwt.client.docs.SCSpriteConfig} formatted string. Alternatively developers can omit this property and instead
     * use CSS directly in the  {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} property
     * to provide a "boolean true" appearance.
     *
     * @return Current booleanTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public String getBooleanTrueImage()  {
        return getAttributeAsString("booleanTrueImage");
    }
    

    /**
     * Indicates whether records can be dropped into this listGrid.
     *
     * @param canAcceptDroppedRecords New canAcceptDroppedRecords value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanAcceptDrop
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     */
    public void setCanAcceptDroppedRecords(Boolean canAcceptDroppedRecords) {
        setAttribute("canAcceptDroppedRecords", canAcceptDroppedRecords, true);
    }

    /**
     * Indicates whether records can be dropped into this listGrid.
     *
     * @return Current canAcceptDroppedRecords value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanAcceptDrop
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     */
    public Boolean getCanAcceptDroppedRecords()  {
        Boolean result = getAttributeAsBoolean("canAcceptDroppedRecords");
        return result == null ? false : result;
    }
    
    
    

    /**
     * Can the user perform one-time autofit for specific columns in this grid? <P> If set to true, the default header menu
     * will include options to auto fit {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitAllText all fields} such
     * that they fit their content or titles as specified via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach}.<br>
     * Autofitting of individual fields via a {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldText header
     * context menu item}, or the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderAutoFitEvent headerAutoFitEvent}
     * will also be enabled when this property is set unless {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} is explicitly set to
     * false <P> Note that the ability to perform one-time autofitting of fields via this  subsystem is separate from the
     * programmatic autofit behavior enabled  via {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths
     * autoFitFieldWidths}. <P> This subsystem is requires canResizeFields be enabled and will be disabled if that property is
     * set to false
     *
     * @param canAutoFitFields New canAutoFitFields value. Default value is true
     */
    public void setCanAutoFitFields(Boolean canAutoFitFields) {
        setAttribute("canAutoFitFields", canAutoFitFields, true);
    }

    /**
     * Can the user perform one-time autofit for specific columns in this grid? <P> If set to true, the default header menu
     * will include options to auto fit {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitAllText all fields} such
     * that they fit their content or titles as specified via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach ListGridField.autoFitWidthApproach}.<br>
     * Autofitting of individual fields via a {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldText header
     * context menu item}, or the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderAutoFitEvent headerAutoFitEvent}
     * will also be enabled when this property is set unless {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} is explicitly set to
     * false <P> Note that the ability to perform one-time autofitting of fields via this  subsystem is separate from the
     * programmatic autofit behavior enabled  via {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths
     * autoFitFieldWidths}. <P> This subsystem is requires canResizeFields be enabled and will be disabled if that property is
     * set to false
     *
     * @return Current canAutoFitFields value. Default value is true
     */
    public Boolean getCanAutoFitFields()  {
        Boolean result = getAttributeAsBoolean("canAutoFitFields");
        return result == null ? true : result;
    }
    

    /**
     * If this is an editable listGrid, and <code>this.confirmCancelEditing</code> is true this property is used as the message
     * to display in the confirmation dismissal prompt.
     *
     * @param cancelEditingConfirmationMessage New cancelEditingConfirmationMessage value. Default value is Cancelling this edit will discard unsaved changes for this record. Continue?
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setCancelEditingConfirmationMessage(String cancelEditingConfirmationMessage) {
        setAttribute("cancelEditingConfirmationMessage", cancelEditingConfirmationMessage, true);
    }

    /**
     * If this is an editable listGrid, and <code>this.confirmCancelEditing</code> is true this property is used as the message
     * to display in the confirmation dismissal prompt.
     *
     * @return Current cancelEditingConfirmationMessage value. Default value is Cancelling this edit will discard unsaved changes for this record. Continue?
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getCancelEditingConfirmationMessage()  {
        return getAttributeAsString("cancelEditingConfirmationMessage");
    }
    

    /**
     * Can a group be collapsed/expanded? When true a collapse/expand icon is shown ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupIcon groupIcon}) and the user can collapse or expand the group by
     * clicking either the row as a whole or the opener icon (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCollapseGroupOnRowClick collapseGroupOnRowClick}); When false the group
     * icon is not shown and clicking on the row does not change group state. Additionally {@link
     * com.smartgwt.client.types.GroupStartOpen groupStartOpen} is initialized to "all".
     *
     * @param canCollapseGroup New canCollapseGroup value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setCanCollapseGroup(Boolean canCollapseGroup)  throws IllegalStateException {
        setAttribute("canCollapseGroup", canCollapseGroup, false);
    }

    /**
     * Can a group be collapsed/expanded? When true a collapse/expand icon is shown ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupIcon groupIcon}) and the user can collapse or expand the group by
     * clicking either the row as a whole or the opener icon (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCollapseGroupOnRowClick collapseGroupOnRowClick}); When false the group
     * icon is not shown and clicking on the row does not change group state. Additionally {@link
     * com.smartgwt.client.types.GroupStartOpen groupStartOpen} is initialized to "all".
     *
     * @return Current canCollapseGroup value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public Boolean getCanCollapseGroup()  {
        Boolean result = getAttributeAsBoolean("canCollapseGroup");
        return result == null ? true : result;
    }
    

    /**
     * Indicates whether records can be dragged from this listGrid and dropped elsewhere. <p> <strong>NOTE:</strong> If
     * <code>canDragRecordsOut</code> is initially enabled or might be dynamically enabled after the grid is created, it may be
     * desirable to disable {@link com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that
     * touch-dragging a record starts a drag operation rather than a scroll. If {@link
     * com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag Canvas.disableTouchScrollingForDrag} is set to
     * <code>true</code>, then touch scrolling will be disabled automatically. However, for {@link
     * com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch scrolling enabled and
     * provide an alternative set of controls that can be used to perform drag and drop of records out of the grid.
     *
     * @param canDragRecordsOut New canDragRecordsOut value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanAcceptDrop
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_records_across_windows" target="examples">Records across Windows Example</a>
     */
    public void setCanDragRecordsOut(Boolean canDragRecordsOut) {
        setAttribute("canDragRecordsOut", canDragRecordsOut, true);
    }

    /**
     * Indicates whether records can be dragged from this listGrid and dropped elsewhere. <p> <strong>NOTE:</strong> If
     * <code>canDragRecordsOut</code> is initially enabled or might be dynamically enabled after the grid is created, it may be
     * desirable to disable {@link com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that
     * touch-dragging a record starts a drag operation rather than a scroll. If {@link
     * com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag Canvas.disableTouchScrollingForDrag} is set to
     * <code>true</code>, then touch scrolling will be disabled automatically. However, for {@link
     * com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch scrolling enabled and
     * provide an alternative set of controls that can be used to perform drag and drop of records out of the grid.
     *
     * @return Current canDragRecordsOut value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanAcceptDrop
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_records_across_windows" target="examples">Records across Windows Example</a>
     */
    public Boolean getCanDragRecordsOut()  {
        Boolean result = getAttributeAsBoolean("canDragRecordsOut");
        return result == null ? false : result;
    }
    

    /**
     * If this property is true, users can drag the mouse to select several rows or cells.  This is mutually exclusive with
     * rearranging rows or cells by dragging. <p> <strong>NOTE:</strong> If <code>canDragSelect</code> is initially enabled or
     * might be dynamically enabled after the grid is created, it may be desirable to disable {@link
     * com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that touch-dragging records/cells selects
     * them rather than starting a scroll. If {@link com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag
     * Canvas.disableTouchScrollingForDrag} is set to <code>true</code>, then touch scrolling will be disabled automatically.
     * However, for {@link com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch
     * scrolling enabled and provide an alternative set of controls that can be used to perform drag-selection.
     *
     * @param canDragSelect New canDragSelect value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_select_list" target="examples">Drag list (select) Example</a>
     */
    public void setCanDragSelect(Boolean canDragSelect) {
        setAttribute("canDragSelect", canDragSelect, true);
    }

    /**
     * If this property is true, users can drag the mouse to select several rows or cells.  This is mutually exclusive with
     * rearranging rows or cells by dragging. <p> <strong>NOTE:</strong> If <code>canDragSelect</code> is initially enabled or
     * might be dynamically enabled after the grid is created, it may be desirable to disable {@link
     * com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that touch-dragging records/cells selects
     * them rather than starting a scroll. If {@link com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag
     * Canvas.disableTouchScrollingForDrag} is set to <code>true</code>, then touch scrolling will be disabled automatically.
     * However, for {@link com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch
     * scrolling enabled and provide an alternative set of controls that can be used to perform drag-selection.
     *
     * @return Current canDragSelect value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_select_list" target="examples">Drag list (select) Example</a>
     */
    public Boolean getCanDragSelect()  {
        Boolean result = getAttributeAsBoolean("canDragSelect");
        return result == null ? false : result;
    }
    

    /**
     * If this property is true, users can drag the mouse to select text within grid rows, ready to be cliped to clipboard.<br>
     * This is mutually exclusive with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanReorderRecords rearranging rows
     * or cells by dragging}, and with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanDragSelect drag selection of
     * rows}. <P> To enable selecting cell text on click, see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectCellTextOnClick selectCellTextOnClick}.
     *
     * @param canDragSelectText New canDragSelectText value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setCanDragSelectText(Boolean canDragSelectText) {
        setAttribute("canDragSelectText", canDragSelectText, true);
    }

    /**
     * If this property is true, users can drag the mouse to select text within grid rows, ready to be cliped to clipboard.<br>
     * This is mutually exclusive with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanReorderRecords rearranging rows
     * or cells by dragging}, and with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanDragSelect drag selection of
     * rows}. <P> To enable selecting cell text on click, see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectCellTextOnClick selectCellTextOnClick}.
     *
     * @return Current canDragSelectText value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public Boolean getCanDragSelectText()  {
        Boolean result = getAttributeAsBoolean("canDragSelectText");
        return result == null ? false : result;
    }
    

    /**
     * If set to false, dropping over an empty part of the grid body is disallowed and the no-drop indicator is displayed.
     *
     * @param canDropInEmptyArea New canDropInEmptyArea value. Default value is true
     * @see com.smartgwt.client.docs.Dragdrop Dragdrop overview and related methods
     */
    public void setCanDropInEmptyArea(Boolean canDropInEmptyArea) {
        setAttribute("canDropInEmptyArea", canDropInEmptyArea, true);
    }

    /**
     * If set to false, dropping over an empty part of the grid body is disallowed and the no-drop indicator is displayed.
     *
     * @return Current canDropInEmptyArea value. Default value is true
     * @see com.smartgwt.client.docs.Dragdrop Dragdrop overview and related methods
     */
    public Boolean getCanDropInEmptyArea()  {
        Boolean result = getAttributeAsBoolean("canDropInEmptyArea");
        return result == null ? true : result;
    }
    

    /**
     * Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for      individual fields.<br>   
     * If 'canEdit' is false at the listGrid level, fields can never be edited - in this case      the canEdit property on
     * individual fields will be ignored.<br>      If 'canEdit' is set to true at the listGrid level, setting the 'canEdit'
     * property to      false at the field level will prevent the field from being edited inline unless a      custom override
     * of {@link com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} allows it.<br>      If 'canEdit' is not
     * set at the listGrid level, setting 'canEdit' to true at the field      level enables the field to be edited inline.
     *
     * @param canEdit New canEdit value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#startEditing
     * @see com.smartgwt.client.widgets.grid.ListGridField#setCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRecordEditProperty
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFields
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_row" target="examples">Edit by row Example</a>
     */
    public void setCanEdit(Boolean canEdit) {
        setAttribute("canEdit", canEdit, true);
    }

    /**
     * Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for      individual fields.<br>   
     * If 'canEdit' is false at the listGrid level, fields can never be edited - in this case      the canEdit property on
     * individual fields will be ignored.<br>      If 'canEdit' is set to true at the listGrid level, setting the 'canEdit'
     * property to      false at the field level will prevent the field from being edited inline unless a      custom override
     * of {@link com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} allows it.<br>      If 'canEdit' is not
     * set at the listGrid level, setting 'canEdit' to true at the field      level enables the field to be edited inline.
     *
     * @return Current canEdit value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#startEditing
     * @see com.smartgwt.client.widgets.grid.ListGridField#getCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRecordEditProperty
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.widgets.grid.ListGrid#getFields
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_row" target="examples">Edit by row Example</a>
     */
    public Boolean getCanEdit()  {
        return getAttributeAsBoolean("canEdit");
    }
    

    /**
     * If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource
     * may be edited by default. For example the {@link com.smartgwt.client.widgets.form.SearchForm} class has this attribute
     * set to <code>"canFilter"</code> which allows search forms to edit dataSource fields marked as <code>canEdit:false</code>
     * (but not those marked as <code>canFilter:false</code>). <P> Note that if <code>canEdit</code> is explicitly specified on
     * a field in  the {@link com.smartgwt.client.widgets.DataBoundComponent#getFields DataBoundComponent.fields} array, that
     * property will be respected in preference to  the canEditAttribute value. (See {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getCanEdit FormItem.canEdit}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanEdit ListGridField.canEdit}). Also note that individual
     * dataBoundComponents may have additional logic around whether a field can be edited - for example {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} may be overridden.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param canEditFieldAttribute New canEditFieldAttribute value. Default value is "canEdit"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCanEditFieldAttribute(String canEditFieldAttribute)  throws IllegalStateException {
        setAttribute("canEditFieldAttribute", canEditFieldAttribute, false);
    }

    /**
     * If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource
     * may be edited by default. For example the {@link com.smartgwt.client.widgets.form.SearchForm} class has this attribute
     * set to <code>"canFilter"</code> which allows search forms to edit dataSource fields marked as <code>canEdit:false</code>
     * (but not those marked as <code>canFilter:false</code>). <P> Note that if <code>canEdit</code> is explicitly specified on
     * a field in  the {@link com.smartgwt.client.widgets.DataBoundComponent#getFields DataBoundComponent.fields} array, that
     * property will be respected in preference to  the canEditAttribute value. (See {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getCanEdit FormItem.canEdit}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanEdit ListGridField.canEdit}). Also note that individual
     * dataBoundComponents may have additional logic around whether a field can be edited - for example {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} may be overridden.
     *
     * @return Current canEditFieldAttribute value. Default value is "canEdit"
     */
    public String getCanEditFieldAttribute()  {
        return getAttributeAsString("canEditFieldAttribute");
    }
    

    /**
     * Adds an item to the header context menu allowing users to launch a dialog to define grid hilites using the {@link
     * com.smartgwt.client.widgets.grid.HiliteEditor}. <P> User-added hilites can be persisted via {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getHiliteState DataBoundComponent.getHiliteState()} and  {@link
     * com.smartgwt.client.widgets.DataBoundComponent#setHiliteState DataBoundComponent.setHiliteState()}.
     *
     * @param canEditHilites New canEditHilites value. Default value is false
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setCanEditHilites(boolean canEditHilites) {
        setAttribute("canEditHilites", canEditHilites, true);
    }

    /**
     * Adds an item to the header context menu allowing users to launch a dialog to define grid hilites using the {@link
     * com.smartgwt.client.widgets.grid.HiliteEditor}. <P> User-added hilites can be persisted via {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getHiliteState DataBoundComponent.getHiliteState()} and  {@link
     * com.smartgwt.client.widgets.DataBoundComponent#setHiliteState DataBoundComponent.setHiliteState()}.
     *
     * @return Current canEditHilites value. Default value is false
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public boolean getCanEditHilites()  {
        Boolean result = getAttributeAsBoolean("canEditHilites");
        return result == null ? false : result;
    }
    

    /**
     * If set to true, the {@link com.smartgwt.client.widgets.grid.ListGrid#getUseAdvancedFieldPicker advanced field picker}
     * provides an interface allowing users to modify fields' titles. <P> Note that when enabled, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFieldState field state} for this component will include field titles.
     *
     * @param canEditTitles New canEditTitles value. Default value is false
     */
    public void setCanEditTitles(boolean canEditTitles) {
        setAttribute("canEditTitles", canEditTitles, true);
    }

    /**
     * If set to true, the {@link com.smartgwt.client.widgets.grid.ListGrid#getUseAdvancedFieldPicker advanced field picker}
     * provides an interface allowing users to modify fields' titles. <P> Note that when enabled, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFieldState field state} for this component will include field titles.
     *
     * @return Current canEditTitles value. Default value is false
     */
    public boolean getCanEditTitles()  {
        Boolean result = getAttributeAsBoolean("canEditTitles");
        return result == null ? false : result;
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true, this property
     * indicates whether multiple records can be expanded simultaneously.  If set to false, expanding a record will
     * automatically collapse any record which is already expanded.  The default value is <code>true</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param canExpandMultipleRecords New canExpandMultipleRecords value. Default value is true
     */
    public void setCanExpandMultipleRecords(Boolean canExpandMultipleRecords) {
        setAttribute("canExpandMultipleRecords", canExpandMultipleRecords, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true, this property
     * indicates whether multiple records can be expanded simultaneously.  If set to false, expanding a record will
     * automatically collapse any record which is already expanded.  The default value is <code>true</code>.
     *
     * @return Current canExpandMultipleRecords value. Default value is true
     */
    public Boolean getCanExpandMultipleRecords()  {
        Boolean result = getAttributeAsBoolean("canExpandMultipleRecords");
        return result == null ? true : result;
    }
    

    /**
     * Property name on a record that will be checked to determine whether a record can be expanded.
     *
     * @param canExpandRecordProperty New canExpandRecordProperty value. Default value is "canExpand"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanExpand
     */
    public void setCanExpandRecordProperty(String canExpandRecordProperty)  throws IllegalStateException {
        setAttribute("canExpandRecordProperty", canExpandRecordProperty, false);
    }

    /**
     * Property name on a record that will be checked to determine whether a record can be expanded.
     *
     * @return Current canExpandRecordProperty value. Default value is "canExpand"
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanExpand
     */
    public String getCanExpandRecordProperty()  {
        return getAttributeAsString("canExpandRecordProperty");
    }
    

    /**
     * When set to true, shows an additional field at the beginning of the field-list (respecting RTL) to allow users to expand
     * and collapse individual records. See {@link com.smartgwt.client.widgets.grid.ListGrid#expandRecord expandRecord()} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} for details on record expansion. <P>
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling} is automatically enabled when
     * canExpandRecords is set to true. <P> Note that expanded records are not currently supported in conjunction with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param canExpandRecords new value for listGrid.canExpandRecords. Default value is false
     */
    public void setCanExpandRecords(Boolean canExpandRecords) {
        setAttribute("canExpandRecords", canExpandRecords, true);
    }

    /**
     * When set to true, shows an additional field at the beginning of the field-list (respecting RTL) to allow users to expand
     * and collapse individual records. See {@link com.smartgwt.client.widgets.grid.ListGrid#expandRecord expandRecord()} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} for details on record expansion. <P>
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling} is automatically enabled when
     * canExpandRecords is set to true. <P> Note that expanded records are not currently supported in conjunction with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}.
     *
     * @return Current canExpandRecords value. Default value is false
     */
    public Boolean getCanExpandRecords()  {
        Boolean result = getAttributeAsBoolean("canExpandRecords");
        return result == null ? false : result;
    }
    

    /**
     * If the listGrid is empty, should the user be able to put focus into the grid body by tabbing to it? <P> Note that if
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditOnFocus editOnFocus} is true for this grid and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} is set to next, having this property
     * set to true will allow users to automatically create a new edit row by simply tabbing into the grid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param canFocusInEmptyGrid New canFocusInEmptyGrid value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCanFocusInEmptyGrid(boolean canFocusInEmptyGrid)  throws IllegalStateException {
        setAttribute("canFocusInEmptyGrid", canFocusInEmptyGrid, false);
    }

    /**
     * If the listGrid is empty, should the user be able to put focus into the grid body by tabbing to it? <P> Note that if
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditOnFocus editOnFocus} is true for this grid and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} is set to next, having this property
     * set to true will allow users to automatically create a new edit row by simply tabbing into the grid.
     *
     * @return Current canFocusInEmptyGrid value. Default value is true
     */
    public boolean getCanFocusInEmptyGrid()  {
        Boolean result = getAttributeAsBoolean("canFocusInEmptyGrid");
        return result == null ? true : result;
    }
    

    /**
     * Whether an interface should be shown to allow user is allowed to dynamically "freeze" or "unfreeze" columns with respect
     * to horizontally scrolling. If unset, this property defaults to <code>true</code> unless:<ul> <li>{@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights this.fixedRecordHeights} is <code>false</code></li>
     * <li>{@link com.smartgwt.client.widgets.grid.ListGrid#getBodyOverflow this.bodyOverflow} is <code>"visible"</code></li>
     * <li>{@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData this.autoFitData} is set to
     * <code>"horizontal"</code> or <code>"both"</code></li> <li>Any field has overflow set to <code>"visible"</code></li></ul>
     * <P> Note that the <code>canFreezeFields</code> setting enables or disables the user interface for freezing and
     * unfreezing fields only.  Fields can be programmatically frozen via setting {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen field.frozen} to true when the grid is created, or dynamically
     * frozen and unfrozen via {@link com.smartgwt.client.widgets.grid.ListGrid#freezeField freezeField()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#unfreezeField unfreezeField()}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter method for {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields canFreezeFields}
     *
     * @param canFreezeFields New value for <code>listGrid.canFreezeFields</code>. Default value is null
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public void setCanFreezeFields(Boolean canFreezeFields) {
        setAttribute("canFreezeFields", canFreezeFields, true);
    }

    /**
     * Whether an interface should be shown to allow user is allowed to dynamically "freeze" or "unfreeze" columns with respect
     * to horizontally scrolling. If unset, this property defaults to <code>true</code> unless:<ul> <li>{@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights this.fixedRecordHeights} is <code>false</code></li>
     * <li>{@link com.smartgwt.client.widgets.grid.ListGrid#getBodyOverflow this.bodyOverflow} is <code>"visible"</code></li>
     * <li>{@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData this.autoFitData} is set to
     * <code>"horizontal"</code> or <code>"both"</code></li> <li>Any field has overflow set to <code>"visible"</code></li></ul>
     * <P> Note that the <code>canFreezeFields</code> setting enables or disables the user interface for freezing and
     * unfreezing fields only.  Fields can be programmatically frozen via setting {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen field.frozen} to true when the grid is created, or dynamically
     * frozen and unfrozen via {@link com.smartgwt.client.widgets.grid.ListGrid#freezeField freezeField()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#unfreezeField unfreezeField()}.
     *
     * @return Current canFreezeFields value. Default value is null
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public Boolean getCanFreezeFields()  {
        return getAttributeAsBoolean("canFreezeFields");
    }
    

    /**
     * If false, grouping via context menu will be disabled.
     *
     * @param canGroupBy New canGroupBy value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setCanGroupBy(Boolean canGroupBy) {
        setAttribute("canGroupBy", canGroupBy, true);
    }

    /**
     * If false, grouping via context menu will be disabled.
     *
     * @return Current canGroupBy value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public Boolean getCanGroupBy()  {
        Boolean result = getAttributeAsBoolean("canGroupBy");
        return result == null ? true : result;
    }
    

    /**
     * If true, cellHover and rowHover events will fire and then a hover will be shown (if not canceled) when the user leaves
     * the mouse over a row / cell unless the corresponding field has {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHover showHover} set to false. If unset or null, the hover will be
     * shown if the corresponding field has showHover:true. If false, then hovers are disabled. <p> Note that standard hovers
     * override {@link com.smartgwt.client.widgets.grid.ListGrid#getShowClippedValuesOnHover clipped value hovers}. Thus, to
     * enable clipped value hovers, canHover must be unset or null and the corresponding field must have showHover unset or
     * null as well.
     *
     * @param canHover New canHover value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowHover
     * @see com.smartgwt.client.widgets.grid.ListGridField#setShowHover
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_value_hover" target="examples">Value hover tips Example</a>
     */
    public void setCanHover(Boolean canHover) {
        setAttribute("canHover", canHover, true);
    }

    /**
     * If true, cellHover and rowHover events will fire and then a hover will be shown (if not canceled) when the user leaves
     * the mouse over a row / cell unless the corresponding field has {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHover showHover} set to false. If unset or null, the hover will be
     * shown if the corresponding field has showHover:true. If false, then hovers are disabled. <p> Note that standard hovers
     * override {@link com.smartgwt.client.widgets.grid.ListGrid#getShowClippedValuesOnHover clipped value hovers}. Thus, to
     * enable clipped value hovers, canHover must be unset or null and the corresponding field must have showHover unset or
     * null as well.
     *
     * @return Current canHover value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowHover
     * @see com.smartgwt.client.widgets.grid.ListGridField#getShowHover
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_value_hover" target="examples">Value hover tips Example</a>
     */
    public Boolean getCanHover()  {
        return getAttributeAsBoolean("canHover");
    }
    

    /**
     * When true, indicates that this ListGrid supports grouping on multiple fields.
     *
     * @param canMultiGroup New canMultiGroup value. Default value is false
     */
    public void setCanMultiGroup(boolean canMultiGroup) {
        setAttribute("canMultiGroup", canMultiGroup, true);
    }

    /**
     * When true, indicates that this ListGrid supports grouping on multiple fields.
     *
     * @return Current canMultiGroup value. Default value is false
     */
    public boolean getCanMultiGroup()  {
        Boolean result = getAttributeAsBoolean("canMultiGroup");
        return result == null ? false : result;
    }
    

    /**
     * When true, indicates that this ListGrid supports sorting on multiple fields.  Note that even when set to true,
     * multi-field sorting may not be available if the grid is databound and the {@link
     * com.smartgwt.client.data.DataSource#getCanMultiSort DataSource doesn't support multi-sort}, or if sorting for a field is
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getCanSortClientOnly client-only} but not all data is available.
     *
     * @param canMultiSort New canMultiSort value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortNumeralMenuButtonSpaceOffset
     */
    public void setCanMultiSort(Boolean canMultiSort) {
        setAttribute("canMultiSort", canMultiSort, true);
    }

    /**
     * When true, indicates that this ListGrid supports sorting on multiple fields.  Note that even when set to true,
     * multi-field sorting may not be available if the grid is databound and the {@link
     * com.smartgwt.client.data.DataSource#getCanMultiSort DataSource doesn't support multi-sort}, or if sorting for a field is
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getCanSortClientOnly client-only} but not all data is available.
     *
     * @return Current canMultiSort value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralMenuButtonSpaceOffset
     */
    public Boolean getCanMultiSort()  {
        Boolean result = getAttributeAsBoolean("canMultiSort");
        return result == null ? true : result;
    }
    

    /**
     * Indicates whether the field picker item and submenu should be present in the header context menu. This menu allows the
     * user to hide visible fields and show hidden fields. <p> By default only fields explicitly included in the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array will be available in this menu, unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanPickOmittedFields canPickOmittedFields} is set to true for a databound
     * grid. <p> A specific field can be omitted from the column picker via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanHide ListGridField.canHide}.
     *
     * @param canPickFields New canPickFields value. Default value is true
     */
    public void setCanPickFields(Boolean canPickFields) {
        setAttribute("canPickFields", canPickFields, true);
    }

    /**
     * Indicates whether the field picker item and submenu should be present in the header context menu. This menu allows the
     * user to hide visible fields and show hidden fields. <p> By default only fields explicitly included in the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array will be available in this menu, unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanPickOmittedFields canPickOmittedFields} is set to true for a databound
     * grid. <p> A specific field can be omitted from the column picker via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanHide ListGridField.canHide}.
     *
     * @return Current canPickFields value. Default value is true
     */
    public Boolean getCanPickFields()  {
        Boolean result = getAttributeAsBoolean("canPickFields");
        return result == null ? true : result;
    }
    

    /**
     * If this grid has a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseAllDataSourceFields useAllDataSourceFields} is false, setting this
     * property to true will cause all dataSource fields not included in the specified set of fields to show up in the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields field picker menu item}. <P> Has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFields fields} is unset (as in this case all dataSource fields will be
     * displayed by default), or if {@link com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields canPickFields} is false.
     *
     * @param canPickOmittedFields New canPickOmittedFields value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCanPickOmittedFields(Boolean canPickOmittedFields)  throws IllegalStateException {
        setAttribute("canPickOmittedFields", canPickOmittedFields, false);
    }

    /**
     * If this grid has a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseAllDataSourceFields useAllDataSourceFields} is false, setting this
     * property to true will cause all dataSource fields not included in the specified set of fields to show up in the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields field picker menu item}. <P> Has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFields fields} is unset (as in this case all dataSource fields will be
     * displayed by default), or if {@link com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields canPickFields} is false.
     *
     * @return Current canPickOmittedFields value. Default value is false
     */
    public Boolean getCanPickOmittedFields()  {
        Boolean result = getAttributeAsBoolean("canPickOmittedFields");
        return result == null ? false : result;
    }
    

    /**
     * If set, provide UI for the user to remove records from the grid as an additional field showing the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon removeIcon}, which, when clicked, will call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeRecordClick removeRecordClick()} which removes the row from the data set
     * (or if {@link com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval deferRemoval} is true changes the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} status for the record). Individual
     * records can be marked to prevent removal - see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordCanRemoveProperty recordCanRemoveProperty}. <P> To add a confirmation
     * dialog before a record is removed, set {@link com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval warnOnRemoval}.
     * <P> If deferring removal, the record will appear marked with the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemovedCSSText removedCSSText} until the removal is committed via a call to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits saveEdits()}. Otherwise, the record will disappear from view.
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord animateRemoveRecord} is true, the removed
     * record will appear to shrink out of view when it is removed. <P> By default the field will display the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon removeIcon} next to each record, and will be rendered as the
     * rightmost column. Two mechanisms exist to further modify this field: <ul> <li>To change the position of the
     * remove-field, include an explicitly specified field with     the attribute {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getIsRemoveField isRemoveField:true} set. This will then     be used as
     * the remove field instead of adding a field to the beginning of the set of     columns.</li> <li>Additional direct
     * configuration of the remove field may be achieved by modifying     {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldProperties removeFieldProperties}.</li> </ul> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval deferRemoval} is true, when a record is marked as removed, the
     * the icon will change to display the {@link com.smartgwt.client.widgets.grid.ListGrid#getUnremoveIcon unremoveIcon} for
     * this row. Clicking on this icon will call {@link com.smartgwt.client.widgets.grid.ListGrid#unmarkRecordRemoved
     * unmarkRecordRemoved()} to mark the record as no longer pending deletion.
     *
     * @param canRemoveRecords New canRemoveRecords value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setCanRemoveRecords(Boolean canRemoveRecords)  throws IllegalStateException {
        setAttribute("canRemoveRecords", canRemoveRecords, false);
    }

    /**
     * If set, provide UI for the user to remove records from the grid as an additional field showing the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon removeIcon}, which, when clicked, will call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeRecordClick removeRecordClick()} which removes the row from the data set
     * (or if {@link com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval deferRemoval} is true changes the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} status for the record). Individual
     * records can be marked to prevent removal - see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordCanRemoveProperty recordCanRemoveProperty}. <P> To add a confirmation
     * dialog before a record is removed, set {@link com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval warnOnRemoval}.
     * <P> If deferring removal, the record will appear marked with the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemovedCSSText removedCSSText} until the removal is committed via a call to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits saveEdits()}. Otherwise, the record will disappear from view.
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAnimateRemoveRecord animateRemoveRecord} is true, the removed
     * record will appear to shrink out of view when it is removed. <P> By default the field will display the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon removeIcon} next to each record, and will be rendered as the
     * rightmost column. Two mechanisms exist to further modify this field: <ul> <li>To change the position of the
     * remove-field, include an explicitly specified field with     the attribute {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getIsRemoveField isRemoveField:true} set. This will then     be used as
     * the remove field instead of adding a field to the beginning of the set of     columns.</li> <li>Additional direct
     * configuration of the remove field may be achieved by modifying     {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldProperties removeFieldProperties}.</li> </ul> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval deferRemoval} is true, when a record is marked as removed, the
     * the icon will change to display the {@link com.smartgwt.client.widgets.grid.ListGrid#getUnremoveIcon unremoveIcon} for
     * this row. Clicking on this icon will call {@link com.smartgwt.client.widgets.grid.ListGrid#unmarkRecordRemoved
     * unmarkRecordRemoved()} to mark the record as no longer pending deletion.
     *
     * @return Current canRemoveRecords value. Default value is false
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public Boolean getCanRemoveRecords()  {
        Boolean result = getAttributeAsBoolean("canRemoveRecords");
        return result == null ? false : result;
    }
    

    /**
     * Indicates whether fields in this listGrid can be reordered by dragging and dropping header fields.  If true, can be
     * overridden at the field level via  {@link com.smartgwt.client.widgets.grid.ListGridField#getCanReorder
     * ListGridField.canReorder}.
     *
     * @param canReorderFields New canReorderFields value. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public void setCanReorderFields(Boolean canReorderFields) {
        setAttribute("canReorderFields", canReorderFields, true);
    }

    /**
     * Indicates whether fields in this listGrid can be reordered by dragging and dropping header fields.  If true, can be
     * overridden at the field level via  {@link com.smartgwt.client.widgets.grid.ListGridField#getCanReorder
     * ListGridField.canReorder}.
     *
     * @return Current canReorderFields value. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public Boolean getCanReorderFields()  {
        Boolean result = getAttributeAsBoolean("canReorderFields");
        return result == null ? true : result;
    }
    

    /**
     * Indicates whether records can be reordered by dragging within this <code>ListGrid</code>. <p> <strong>NOTE:</strong> If
     * <code>canReorderRecords</code> is initially enabled or might be {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCanReorderRecords dynamically enabled} after the grid is created, it may be
     * desirable to disable {@link com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that
     * touch-dragging a record starts a reorder operation rather than a scroll. If {@link
     * com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag Canvas.disableTouchScrollingForDrag} is set to
     * <code>true</code>, then touch scrolling will be disabled automatically. However, for {@link
     * com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch scrolling enabled and
     * provide an alternative set of controls that can be used to perform drag-reordering of records.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getCanReorderRecords canReorderRecords} attribute.
     *
     * @param canReorderRecords new value for <code>this.canReorderRecords</code>. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setCanAcceptDrop
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_drag_reorder" target="examples">Drag reorder Example</a>
     */
    public void setCanReorderRecords(Boolean canReorderRecords) {
        setAttribute("canReorderRecords", canReorderRecords, true);
    }

    /**
     * Indicates whether records can be reordered by dragging within this <code>ListGrid</code>. <p> <strong>NOTE:</strong> If
     * <code>canReorderRecords</code> is initially enabled or might be {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCanReorderRecords dynamically enabled} after the grid is created, it may be
     * desirable to disable {@link com.smartgwt.client.widgets.Canvas#getUseTouchScrolling touch scrolling} so that
     * touch-dragging a record starts a reorder operation rather than a scroll. If {@link
     * com.smartgwt.client.widgets.Canvas#getDisableTouchScrollingForDrag Canvas.disableTouchScrollingForDrag} is set to
     * <code>true</code>, then touch scrolling will be disabled automatically. However, for {@link
     * com.smartgwt.client.docs.Accessibility accessibility} reasons, it is recommended to leave touch scrolling enabled and
     * provide an alternative set of controls that can be used to perform drag-reordering of records.
     *
     * @return Current canReorderRecords value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanDrag
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getCanAcceptDrop
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#effects_dd_move_list" target="examples">Drag list (move) Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_drag_reorder" target="examples">Drag reorder Example</a>
     */
    public Boolean getCanReorderRecords()  {
        Boolean result = getAttributeAsBoolean("canReorderRecords");
        return result == null ? false : result;
    }
    

    /**
     * Indicates whether fields in this listGrid can be resized by dragging header fields.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter method for updating {@link com.smartgwt.client.widgets.grid.ListGrid#getCanResizeFields canResizeFields} at runtime.
     *
     * @param canResizeFields new value for this.canResizeFields. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnsize" target="examples">Column size Example</a>
     */
    public void setCanResizeFields(Boolean canResizeFields) {
        setAttribute("canResizeFields", canResizeFields, true);
    }

    /**
     * Indicates whether fields in this listGrid can be resized by dragging header fields.
     *
     * @return Current canResizeFields value. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnsize" target="examples">Column size Example</a>
     */
    public Boolean getCanResizeFields()  {
        Boolean result = getAttributeAsBoolean("canResizeFields");
        return result == null ? true : result;
    }
    

    /**
     * Controls whether a checkbox for selecting all records appears in the header with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} set to "checkbox"
     *
     * @param canSelectAll New canSelectAll value. Default value is null
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setCanSelectAll(Boolean canSelectAll) {
        setAttribute("canSelectAll", canSelectAll, true);
    }

    /**
     * Controls whether a checkbox for selecting all records appears in the header with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} set to "checkbox"
     *
     * @return Current canSelectAll value. Default value is null
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public Boolean getCanSelectAll()  {
        return getAttributeAsBoolean("canSelectAll");
    }
    

    /**
     * Enables cell-level selection behavior as well as {@link com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers
     * cell-level rollover}. <P> To query and manipulate cell-level selections, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellSelection getCellSelection()} to retrieve the {@link
     * com.smartgwt.client.widgets.grid.CellSelection}. <P> Note that the ListGrid has a data model of one {@link
     * com.smartgwt.client.data.Record} per row, unlike the {@link com.smartgwt.client.widgets.cube.CubeGrid} which supports
     * one {@link com.smartgwt.client.widgets.cube.CellRecord} per cell.  For this reason record-oriented APIs that act on the
     * selection will act on entire Records that have <i>any</i> selected cells (examples include drag and drop and
     * transferSelectedData()). <P> More generally, <code>canSelectCells</code> is primarily intended to enable developers to
     * build Excel-like interactions on local datasets, by using {@link com.smartgwt.client.widgets.grid.ListGrid#setData
     * setData()} plus {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally}:true rather than
     * record-oriented DataSources and data binding. <P> The following keyboard selection behaviors are enabled with this
     * property in addition to standard single-selection Arrow Key navigation: <P> SHIFT +        [Arrow Key]:  begin or
     * continue incremental selection <P> SHIFT + CTRL + [Arrow Key]:  incremental selection to the end of row or column <P>
     * CTRL  + A: select all cells (enabled only with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll
     * canSelectAll}) <P> Incremental selection allows selection of rows and columns of cells via keyboard or mouse provided
     * the shift key is down.  Behavior is designed to match Excel. Thus, if a previous selection has begun, cells will be
     * selected from that origin. <P> Users may also navigate through cells using the <i>Tab</i> and <i>Shift+Tab</i>
     * keypresses if {@link com.smartgwt.client.widgets.grid.ListGrid#getNavigateOnTab navigateOnTab} is true. When a user tabs
     * to the end of the row, the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowEndEditAction rowEndEditAction} is
     * used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on
     * through the page's tab order.
     *
     * @param canSelectCells New canSelectCells value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCanSelectCells(Boolean canSelectCells)  throws IllegalStateException {
        setAttribute("canSelectCells", canSelectCells, false);
    }

    /**
     * Enables cell-level selection behavior as well as {@link com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers
     * cell-level rollover}. <P> To query and manipulate cell-level selections, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellSelection getCellSelection()} to retrieve the {@link
     * com.smartgwt.client.widgets.grid.CellSelection}. <P> Note that the ListGrid has a data model of one {@link
     * com.smartgwt.client.data.Record} per row, unlike the {@link com.smartgwt.client.widgets.cube.CubeGrid} which supports
     * one {@link com.smartgwt.client.widgets.cube.CellRecord} per cell.  For this reason record-oriented APIs that act on the
     * selection will act on entire Records that have <i>any</i> selected cells (examples include drag and drop and
     * transferSelectedData()). <P> More generally, <code>canSelectCells</code> is primarily intended to enable developers to
     * build Excel-like interactions on local datasets, by using {@link com.smartgwt.client.widgets.grid.ListGrid#setData
     * setData()} plus {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally}:true rather than
     * record-oriented DataSources and data binding. <P> The following keyboard selection behaviors are enabled with this
     * property in addition to standard single-selection Arrow Key navigation: <P> SHIFT +        [Arrow Key]:  begin or
     * continue incremental selection <P> SHIFT + CTRL + [Arrow Key]:  incremental selection to the end of row or column <P>
     * CTRL  + A: select all cells (enabled only with {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll
     * canSelectAll}) <P> Incremental selection allows selection of rows and columns of cells via keyboard or mouse provided
     * the shift key is down.  Behavior is designed to match Excel. Thus, if a previous selection has begun, cells will be
     * selected from that origin. <P> Users may also navigate through cells using the <i>Tab</i> and <i>Shift+Tab</i>
     * keypresses if {@link com.smartgwt.client.widgets.grid.ListGrid#getNavigateOnTab navigateOnTab} is true. When a user tabs
     * to the end of the row, the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowEndEditAction rowEndEditAction} is
     * used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on
     * through the page's tab order.
     *
     * @return Current canSelectCells value. Default value is false
     */
    public Boolean getCanSelectCells()  {
        Boolean result = getAttributeAsBoolean("canSelectCells");
        return result == null ? false : result;
    }
    

    /**
     * Controls whether a checkbox for selecting {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groups} appears in
     * the group node if {@link com.smartgwt.client.types.SelectionAppearance} is set to <code>"checkbox"</code>
     *
     * @param canSelectGroups New canSelectGroups value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setCanSelectGroups(boolean canSelectGroups) {
        setAttribute("canSelectGroups", canSelectGroups, true);
    }

    /**
     * Controls whether a checkbox for selecting {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groups} appears in
     * the group node if {@link com.smartgwt.client.types.SelectionAppearance} is set to <code>"checkbox"</code>
     *
     * @return Current canSelectGroups value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public boolean getCanSelectGroups()  {
        Boolean result = getAttributeAsBoolean("canSelectGroups");
        return result == null ? false : result;
    }
    

    /**
     * Enables or disables interactive sorting behavior for this listGrid. Does not affect sorting by direct calls to the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort} or {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort} methods.
     *
     * @param canSort New canSort value. Default value is true
     */
    public void setCanSort(Boolean canSort) {
        setAttribute("canSort", canSort, true);
    }

    /**
     * Enables or disables interactive sorting behavior for this listGrid. Does not affect sorting by direct calls to the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort} or {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort} methods.
     *
     * @return Current canSort value. Default value is true
     */
    public Boolean getCanSort()  {
        Boolean result = getAttributeAsBoolean("canSort");
        return result == null ? true : result;
    }
    

    /**
     * Should the header be included in the tab-order for the page? If not explicitly specified, the header will be included in
     * the tab order for the page if     {@link com.smartgwt.client.util.SC#setScreenReaderMode SC.setScreenReaderMode()}  is
     * called.
     *
     * @param canTabToHeader New canTabToHeader value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public void setCanTabToHeader(Boolean canTabToHeader)  throws IllegalStateException {
        setAttribute("canTabToHeader", canTabToHeader, false);
    }

    /**
     * Should the header be included in the tab-order for the page? If not explicitly specified, the header will be included in
     * the tab order for the page if     {@link com.smartgwt.client.util.SC#setScreenReaderMode SC.setScreenReaderMode()}  is
     * called.
     *
     * @return Current canTabToHeader value. Default value is null
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public Boolean getCanTabToHeader()  {
        return getAttributeAsBoolean("canTabToHeader");
    }
    

    /**
     * The menu displayed when a cell is right clicked on.
     * <p>
     * This component is an AutoChild named "cellContextMenu".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current cellContextMenu value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public Layout getCellContextMenu() throws IllegalStateException {
        errorIfNotCreated("cellContextMenu");
        return (Layout)Layout.getByJSObject(getAttributeAsJavaScriptObject("cellContextMenu"));
    }
    

    /**
     * The default height of each row in pixels.
     *
     * @param cellHeight New cellHeight value. Default value is 20
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_multiline" target="examples">Multiline values Example</a>
     */
    public void setCellHeight(int cellHeight) {
        setAttribute("cellHeight", cellHeight, true);
    }

    /**
     * The default height of each row in pixels.
     *
     * @return Current cellHeight value. Default value is 20
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_multiline" target="examples">Multiline values Example</a>
     */
    public int getCellHeight()  {
        return getAttributeAsInt("cellHeight");
    }
    

    /**
     * The amount of empty space, in pixels, surrounding each value in its cell.
     *
     * @param cellPadding New cellPadding value. Default value is 2
     */
    public void setCellPadding(int cellPadding) {
        setAttribute("cellPadding", cellPadding, true);
    }

    /**
     * The amount of empty space, in pixels, surrounding each value in its cell.
     *
     * @return Current cellPadding value. Default value is 2
     */
    public int getCellPadding()  {
        return getAttributeAsInt("cellPadding");
    }
    

    /**
     * Name of the Smart GWT Class to be used when creating charts.  Must support the Chart interface.
     *
     * @param chartConstructor New chartConstructor value. Default value is "FacetChart"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setChartConstructor(String chartConstructor)  throws IllegalStateException {
        setAttribute("chartConstructor", chartConstructor, false);
    }

    /**
     * Name of the Smart GWT Class to be used when creating charts.  Must support the Chart interface.
     *
     * @return Current chartConstructor value. Default value is "FacetChart"
     */
    public String getChartConstructor()  {
        return getAttributeAsString("chartConstructor");
    }
    

    /**
     * Default type of chart to plot.
     *
     * @param chartType New chartType value. Default value is "Column"
     */
    public void setChartType(ChartType chartType) {
        setAttribute("chartType", chartType == null ? null : chartType.getValue(), true);
    }

    /**
     * Default type of chart to plot.
     *
     * @return Current chartType value. Default value is "Column"
     */
    public ChartType getChartType()  {
        return EnumUtil.getEnum(ChartType.values(), getAttribute("chartType"));
    }
    
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for an unselected row. If
     * unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} will be used. Note
     * that the special value "blank" means that no image will be shown.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param checkboxFieldFalseImage New checkboxFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintCheckboxFieldFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setCheckboxFieldFalseImage(String checkboxFieldFalseImage) {
        setAttribute("checkboxFieldFalseImage", checkboxFieldFalseImage, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for an unselected row. If
     * unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} will be used. Note
     * that the special value "blank" means that no image will be shown.
     *
     * @return Current checkboxFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintCheckboxFieldFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getCheckboxFieldFalseImage()  {
        return getAttributeAsString("checkboxFieldFalseImage");
    }
    
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property may be set to govern the height of the checkbox image displayed to indicate
     * whether a row is selected. If unset, the checkboxField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageHeight booleanImageHeight} for this grid.
     *
     * @param checkboxFieldImageHeight New checkboxFieldImageHeight value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCheckboxFieldImageHeight(Integer checkboxFieldImageHeight)  throws IllegalStateException {
        setAttribute("checkboxFieldImageHeight", checkboxFieldImageHeight, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property may be set to govern the height of the checkbox image displayed to indicate
     * whether a row is selected. If unset, the checkboxField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageHeight booleanImageHeight} for this grid.
     *
     * @return Current checkboxFieldImageHeight value. Default value is null
     */
    public Integer getCheckboxFieldImageHeight()  {
        return getAttributeAsInt("checkboxFieldImageHeight");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property may be set to govern the width of the checkbox image displayed to indicate whether
     * a row is selected. If unset, the checkboxField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageWidth booleanImageWidth} for this grid.
     *
     * @param checkboxFieldImageWidth New checkboxFieldImageWidth value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setCheckboxFieldImageWidth(Integer checkboxFieldImageWidth)  throws IllegalStateException {
        setAttribute("checkboxFieldImageWidth", checkboxFieldImageWidth, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property may be set to govern the width of the checkbox image displayed to indicate whether
     * a row is selected. If unset, the checkboxField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageWidth booleanImageWidth} for this grid.
     *
     * @return Current checkboxFieldImageWidth value. Default value is null
     */
    public Integer getCheckboxFieldImageWidth()  {
        return getAttributeAsInt("checkboxFieldImageWidth");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for a partially selected
     * row. If unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} will be
     * used. Note that the special value "blank" means that no image will be shown.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param checkboxFieldPartialImage New checkboxFieldPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintCheckboxFieldPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setCheckboxFieldPartialImage(String checkboxFieldPartialImage) {
        setAttribute("checkboxFieldPartialImage", checkboxFieldPartialImage, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for a partially selected
     * row. If unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} will be
     * used. Note that the special value "blank" means that no image will be shown.
     *
     * @return Current checkboxFieldPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintCheckboxFieldPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getCheckboxFieldPartialImage()  {
        return getAttributeAsString("checkboxFieldPartialImage");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for a selected row. If
     * unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} will be used. Note
     * that the special value "blank" means that no image will be shown.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param checkboxFieldTrueImage New checkboxFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#setPrintCheckboxFieldTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setCheckboxFieldTrueImage(String checkboxFieldTrueImage) {
        setAttribute("checkboxFieldTrueImage", checkboxFieldTrueImage, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance} is set to
     * <code>"checkbox"</code> this property determines the image to display in the checkbox field for a selected row. If
     * unset, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} will be used. Note
     * that the special value "blank" means that no image will be shown.
     *
     * @return Current checkboxFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldImageHeight
     * @see com.smartgwt.client.widgets.grid.ListGrid#getPrintCheckboxFieldTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getCheckboxFieldTrueImage()  {
        return getAttributeAsString("checkboxFieldTrueImage");
    }
    

    /**
     * For {@link com.smartgwt.client.types.ExpansionMode expansionModes} that show another grid or tree, what the child's
     * expansionMode should be. <P>Default value <code>null</code> means no further expansion.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param childExpansionMode New childExpansionMode value. Default value is null
     */
    public void setChildExpansionMode(ExpansionMode childExpansionMode) {
        setAttribute("childExpansionMode", childExpansionMode == null ? null : childExpansionMode.getValue(), true);
    }

    /**
     * For {@link com.smartgwt.client.types.ExpansionMode expansionModes} that show another grid or tree, what the child's
     * expansionMode should be. <P>Default value <code>null</code> means no further expansion.
     *
     * @return Current childExpansionMode value. Default value is null
     */
    public ExpansionMode getChildExpansionMode()  {
        return EnumUtil.getEnum(ExpansionMode.values(), getAttribute("childExpansionMode"));
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to clear any existing sort on all fields.  This menu-item is
     * displayed only in the context menu for the sorter button.
     *
     * @param clearAllSortingText New clearAllSortingText value. Default value is "Clear All Sorting"
     */
    public void setClearAllSortingText(String clearAllSortingText) {
        setAttribute("clearAllSortingText", clearAllSortingText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to clear any existing sort on all fields.  This menu-item is
     * displayed only in the context menu for the sorter button.
     *
     * @return Current clearAllSortingText value. Default value is "Clear All Sorting"
     */
    public String getClearAllSortingText()  {
        return getAttributeAsString("clearAllSortingText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter-editor} is visible, this
     * attribute will be shown as the menu item title to clear any existing filter.  This menu-item is displayed only in the
     * context menu for the sorter button.
     *
     * @param clearFilterText New clearFilterText value. Default value is "Clear Filter"
     */
    public void setClearFilterText(String clearFilterText) {
        setAttribute("clearFilterText", clearFilterText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter-editor} is visible, this
     * attribute will be shown as the menu item title to clear any existing filter.  This menu-item is displayed only in the
     * context menu for the sorter button.
     *
     * @return Current clearFilterText value. Default value is "Clear Filter"
     */
    public String getClearFilterText()  {
        return getAttributeAsString("clearFilterText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to clear an existing sort on this field.
     *
     * @param clearSortFieldText New clearSortFieldText value. Default value is "Clear Sort"
     */
    public void setClearSortFieldText(String clearSortFieldText) {
        setAttribute("clearSortFieldText", clearSortFieldText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to clear an existing sort on this field.
     *
     * @return Current clearSortFieldText value. Default value is "Clear Sort"
     */
    public String getClearSortFieldText()  {
        return getAttributeAsString("clearSortFieldText");
    }
    

    /**
     * Whether the ListGrid should manage the clipping of titles of header buttons, showing ellipses if the title is clipped,
     * and potentially showing the full title on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowClippedHeaderTitlesOnHover hover}. <p> In some cases this may be
     * preferable to the button component's default clipping behavior because if a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSortArrow sort arrow} or sort numeral is displayed for a header, then
     * the button's default clipping behavior may clip the sort arrow/numeral whereas ListGrid-managed title clipping utilizes
     * special HTML which keeps the sort arrow/numeral visible. <p> This feature is automatically enabled if supported by the
     * browser. The only supported use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles to
     * false. <P> Note that this feature is incompatible with {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap
     * ListGridField.wrap}, and will automatically be disabled for wrapping fields.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param clipHeaderTitles New clipHeaderTitles value. Default value is varies
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setClipHeaderTitles(Boolean clipHeaderTitles)  throws IllegalStateException {
        setAttribute("clipHeaderTitles", clipHeaderTitles, false);
    }

    /**
     * Whether the ListGrid should manage the clipping of titles of header buttons, showing ellipses if the title is clipped,
     * and potentially showing the full title on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowClippedHeaderTitlesOnHover hover}. <p> In some cases this may be
     * preferable to the button component's default clipping behavior because if a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSortArrow sort arrow} or sort numeral is displayed for a header, then
     * the button's default clipping behavior may clip the sort arrow/numeral whereas ListGrid-managed title clipping utilizes
     * special HTML which keeps the sort arrow/numeral visible. <p> This feature is automatically enabled if supported by the
     * browser. The only supported use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles to
     * false. <P> Note that this feature is incompatible with {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap
     * ListGridField.wrap}, and will automatically be disabled for wrapping fields.
     *
     * @return Current clipHeaderTitles value. Default value is varies
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public Boolean getClipHeaderTitles()  {
        return getAttributeAsBoolean("clipHeaderTitles");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanCollapseGroup canCollapseGroup} is true, will a click anywhere
     * on the group row toggle the group's expanded state? If false, the user must click the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupIcon groupIcon} directly to toggle the group.
     *
     * @param collapseGroupOnRowClick New collapseGroupOnRowClick value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setCollapseGroupOnRowClick(boolean collapseGroupOnRowClick)  throws IllegalStateException {
        setAttribute("collapseGroupOnRowClick", collapseGroupOnRowClick, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanCollapseGroup canCollapseGroup} is true, will a click anywhere
     * on the group row toggle the group's expanded state? If false, the user must click the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupIcon groupIcon} directly to toggle the group.
     *
     * @return Current collapseGroupOnRowClick value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public boolean getCollapseGroupOnRowClick()  {
        Boolean result = getAttributeAsBoolean("collapseGroupOnRowClick");
        return result == null ? true : result;
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and multi-grouping is enabled, this attribute is used as the title for a menu item that opens a {@link
     * com.smartgwt.client.widgets.MultiGroupDialog} to configure the grouping for this grid.
     *
     * @param configureGroupingText New configureGroupingText value. Default value is "Configure Grouping..."
     */
    public void setConfigureGroupingText(String configureGroupingText) {
        setAttribute("configureGroupingText", configureGroupingText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and multi-grouping is enabled, this attribute is used as the title for a menu item that opens a {@link
     * com.smartgwt.client.widgets.MultiGroupDialog} to configure the grouping for this grid.
     *
     * @return Current configureGroupingText value. Default value is "Configure Grouping..."
     */
    public String getConfigureGroupingText()  {
        return getAttributeAsString("configureGroupingText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and multi-sorting is enabled, this attribute is used as the title for a menu item that opens a {@link
     * com.smartgwt.client.widgets.MultiSortDialog} to configure the sort-specification for this grid.  This menu-item is
     * displayed only in the context menu for the sorter button.
     *
     * @param configureSortText New configureSortText value. Default value is "Configure Sort..."
     */
    public void setConfigureSortText(String configureSortText) {
        setAttribute("configureSortText", configureSortText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and multi-sorting is enabled, this attribute is used as the title for a menu item that opens a {@link
     * com.smartgwt.client.widgets.MultiSortDialog} to configure the sort-specification for this grid.  This menu-item is
     * displayed only in the context menu for the sorter button.
     *
     * @return Current configureSortText value. Default value is "Configure Sort..."
     */
    public String getConfigureSortText()  {
        return getAttributeAsString("configureSortText");
    }
    

    /**
     * If this is an editable listGrid, when the user attempts to cancel an edit, should we display a confirmation prompt
     * before discarding the edited values for the record?
     *
     * @param confirmCancelEditing New confirmCancelEditing value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setConfirmCancelEditing(Boolean confirmCancelEditing) {
        setAttribute("confirmCancelEditing", confirmCancelEditing, true);
    }

    /**
     * If this is an editable listGrid, when the user attempts to cancel an edit, should we display a confirmation prompt
     * before discarding the edited values for the record?
     *
     * @return Current confirmCancelEditing value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getConfirmCancelEditing()  {
        Boolean result = getAttributeAsBoolean("confirmCancelEditing");
        return result == null ? false : result;
    }
    

    /**
     * For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded. This
     * flag determines whether we should display a confirmation dialog with options to save or discard the edits, or cancel the
     * action in this case.
     *
     * @param confirmDiscardEdits New confirmDiscardEdits value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setConfirmDiscardEdits(Boolean confirmDiscardEdits) {
        setAttribute("confirmDiscardEdits", confirmDiscardEdits, true);
    }

    /**
     * For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded. This
     * flag determines whether we should display a confirmation dialog with options to save or discard the edits, or cancel the
     * action in this case.
     *
     * @return Current confirmDiscardEdits value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getConfirmDiscardEdits()  {
        Boolean result = getAttributeAsBoolean("confirmDiscardEdits");
        return result == null ? true : result;
    }
    

    /**
     * If <code>this.confirmDiscardEdits</code> is true, this property can be used to customize the error message string
     * displayed to the user in a dialog with options to cancel the action, or save or discard pending edits in response to
     * sort/filter actions that would otherwise drop unsaved edit values.
     *
     * @param confirmDiscardEditsMessage New confirmDiscardEditsMessage value. Default value is "This action will discard unsaved changes for this list."
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setConfirmDiscardEditsMessage(String confirmDiscardEditsMessage) {
        setAttribute("confirmDiscardEditsMessage", confirmDiscardEditsMessage, true);
    }

    /**
     * If <code>this.confirmDiscardEdits</code> is true, this property can be used to customize the error message string
     * displayed to the user in a dialog with options to cancel the action, or save or discard pending edits in response to
     * sort/filter actions that would otherwise drop unsaved edit values.
     *
     * @return Current confirmDiscardEditsMessage value. Default value is "This action will discard unsaved changes for this list."
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getConfirmDiscardEditsMessage()  {
        return getAttributeAsString("confirmDiscardEditsMessage");
    }
    

    /**
     * A list of ListGridRecord objects, specifying the data to be used to populate the ListGrid.  In ListGrids, the data array
     * specifies rows. <p> When using a {@link com.smartgwt.client.data.DataSource}, rather than directly providing
     * <code>data</code>, you will typically call {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}
     * instead, which will automatically establish <code>data</code> as a {@link com.smartgwt.client.data.ResultSet ResultSet}
     * (see the {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} docs for details). <p> If you call
     * <code>fetchData</code>, any previously supplied <code>data</code> is discarded.  Also, it is not necessary to call
     * <code>setData()</code> after calling {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}. <p> When
     * calling <code>setData()</code>, if <code>data</code> is provided as a RecordList or ResultSet, direct changes to the
     * list using Framework APIs such as {@link com.smartgwt.client.data.RecordList#add RecordList.add()} or  {@link
     * com.smartgwt.client.data.RecordList#remove RecordList.remove()} will be automatically observed and the ListGrid will
     * redraw in response.  However, direct changes to individual Records will not be automatically observed and require calls
     * to {@link com.smartgwt.client.widgets.grid.ListGrid#refreshCell refreshCell()} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#refreshRow refreshRow()} to cause the ListGrid to visually update.  Calling
     * methods such as {@link com.smartgwt.client.widgets.grid.ListGrid#updateData updateData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeData removeData()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addData addData()} always causes automatic visual refresh.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Provides a new data set to the ListGrid after the grid has been created or drawn. The ListGrid will redraw to show the new data automatically. <P> Note that passing null will not clear {@link com.smartgwt.client.widgets.grid.ListGrid#getData data}, but will regroup it and reapply the current sort, highlighting, and summaries to the grid.  Size will be recalculated for fields marked as {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth autofitWidth}:true and a {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionManager selection manager} will be created if none exists.  To clear the grid instead, pass [].
     *
     * @param data data to show in the list. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridRecord
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_inline_data" target="examples">Inline data Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_local_data" target="examples">Local data Example</a>
     */
    public void setData(ListGridRecord... data) {
        setAttribute("data", data, true);
    }
    

    /**
     * Delay in milliseconds before fetching data. <P> Note: the floor value for this attribute is 1.  If you set this value to
     * zero, it will be defaulted to 1 for you instead.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param dataFetchDelay New dataFetchDelay value. Default value is 1
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setDataFetchDelay(Integer dataFetchDelay) {
        setAttribute("dataFetchDelay", dataFetchDelay, true);
    }

    /**
     * Delay in milliseconds before fetching data. <P> Note: the floor value for this attribute is 1.  If you set this value to
     * zero, it will be defaulted to 1 for you instead.
     *
     * @return Current dataFetchDelay value. Default value is 1
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public Integer getDataFetchDelay()  {
        return getAttributeAsInt("dataFetchDelay");
    }
    

    /**
     * How to fetch and manage records retrieve from the server.  See {@link com.smartgwt.client.types.FetchMode}. <P> This
     * setting only applies to the {@link com.smartgwt.client.data.ResultSet} automatically created by calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}.  If a pre-existing ResultSet is passed to setData()
     * instead, it's existing setting for {@link com.smartgwt.client.data.ResultSet#getFetchMode ResultSet.fetchMode} applies.
     *
     * @param dataFetchMode New dataFetchMode value. Default value is "paged"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowAllRecords
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setDataFetchMode(FetchMode dataFetchMode)  throws IllegalStateException {
        setAttribute("dataFetchMode", dataFetchMode == null ? null : dataFetchMode.getValue(), false);
    }

    /**
     * How to fetch and manage records retrieve from the server.  See {@link com.smartgwt.client.types.FetchMode}. <P> This
     * setting only applies to the {@link com.smartgwt.client.data.ResultSet} automatically created by calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}.  If a pre-existing ResultSet is passed to setData()
     * instead, it's existing setting for {@link com.smartgwt.client.data.ResultSet#getFetchMode ResultSet.fetchMode} applies.
     *
     * @return Current dataFetchMode value. Default value is "paged"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowAllRecords
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public FetchMode getDataFetchMode()  {
        return EnumUtil.getEnum(FetchMode.values(), getAttribute("dataFetchMode"));
    }
    
    
    

    /**
     * The DataSource that this component should bind to for default fields and for performing {@link
     * com.smartgwt.client.data.DSRequest DataSource requests}. <P> Can be specified as either a DataSource instance or the
     * String ID of a DataSource.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Bind to a new DataSource. <P> Like passing the "dataSource" property on creation, binding to a DataSource means that the component will use the DataSource to provide default data for its fields. <P> When binding to a new DataSource, if the component has any existing "fields" or has a dataset, these will be discarded by default, since it is assumed the new DataSource may represent a completely unrelated set of objects.  If the old "fields" are still relevant, pass them to setDataSource().
     *
     * @param dataSource DataSource to bind to. Default value is null
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_ds_fields" target="examples">DataSource fields Example</a>
     */
    public void setDataSource(DataSource dataSource) {
        setAttribute("dataSource", dataSource == null ? null : dataSource.getOrCreateJsObj(), true);
    }

    /**
     * The DataSource that this component should bind to for default fields and for performing {@link
     * com.smartgwt.client.data.DSRequest DataSource requests}. <P> Can be specified as either a DataSource instance or the
     * String ID of a DataSource.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Bind to a new DataSource. <P> Like passing the "dataSource" property on creation, binding to a DataSource means that the component will use the DataSource to provide default data for its fields. <P> When binding to a new DataSource, if the component has any existing "fields" or has a dataset, these will be discarded by default, since it is assumed the new DataSource may represent a completely unrelated set of objects.  If the old "fields" are still relevant, pass them to setDataSource().
     *
     * @param dataSource DataSource to bind to. Default value is null
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_ds_fields" target="examples">DataSource fields Example</a>
     */
    public void setDataSource(String dataSource) {
        setAttribute("dataSource", dataSource, true);
    }
    

    /**
     * How should Date type values be displayed in this ListGrid by default? <P> This property specifies the default
     * DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getType type "time"} (See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getTimeFormatter timeFormatter}).<br> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDatetimeFormatter datetimeFormatter} is specified, that will be applied by
     * default to fields of type <code>"datetime"</code>. <P> Note that if {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDateFormatter ListGridField.dateFormatter} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getTimeFormatter ListGridField.timeFormatter} are specified those
     * properties will take precedence over the component level settings. <P> If unset, date values will be formatted according
     * to the system wide {@link com.smartgwt.client.util.DateUtil#setShortDisplayFormat short display format} or {@link
     * com.smartgwt.client.util.DateUtil#setShortDatetimeDisplayFormat short datetime display format} for datetime type fields.
     * <P> If this field is editable the dateFormatter will also be passed to the editor created to edit this field as {@link
     * com.smartgwt.client.widgets.form.fields.DateItem#getDateFormatter dateFormatter}. In this case you may also need to set
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getDateInputFormat dateInputFormat}.
     *
     * @param dateFormatter New dateFormatter value. Default value is null
     */
    public void setDateFormatter(DateDisplayFormat dateFormatter) {
        setAttribute("dateFormatter", dateFormatter == null ? null : dateFormatter.getValue(), true);
    }

    /**
     * How should Date type values be displayed in this ListGrid by default? <P> This property specifies the default
     * DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getType type "time"} (See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getTimeFormatter timeFormatter}).<br> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDatetimeFormatter datetimeFormatter} is specified, that will be applied by
     * default to fields of type <code>"datetime"</code>. <P> Note that if {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDateFormatter ListGridField.dateFormatter} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getTimeFormatter ListGridField.timeFormatter} are specified those
     * properties will take precedence over the component level settings. <P> If unset, date values will be formatted according
     * to the system wide {@link com.smartgwt.client.util.DateUtil#setShortDisplayFormat short display format} or {@link
     * com.smartgwt.client.util.DateUtil#setShortDatetimeDisplayFormat short datetime display format} for datetime type fields.
     * <P> If this field is editable the dateFormatter will also be passed to the editor created to edit this field as {@link
     * com.smartgwt.client.widgets.form.fields.DateItem#getDateFormatter dateFormatter}. In this case you may also need to set
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getDateInputFormat dateInputFormat}.
     *
     * @return Current dateFormatter value. Default value is null
     */
    public DateDisplayFormat getDateFormatter()  {
        return EnumUtil.getEnum(DateDisplayFormat.values(), getAttribute("dateFormatter"));
    }
    

    /**
     * If this is an editable listGrid, this property will specify the {@link
     * com.smartgwt.client.widgets.form.fields.DateItem#getInputFormat inputFormat} applied to editors for fields of type
     * <code>"date"</code>. May be overridden per field via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getInputFormat ListGridField.inputFormat}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param dateInputFormat New dateInputFormat value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setDateFormatter
     * @see com.smartgwt.client.docs.DateInputFormat DateInputFormat 
     */
    public void setDateInputFormat(String dateInputFormat) {
        setAttribute("dateInputFormat", dateInputFormat, true);
    }
    

    /**
     * Display format to use for fields specified as type 'datetime'.  Default is to use the system-wide default date time
     * format, configured via {@link com.smartgwt.client.util.DateUtil#setShortDatetimeDisplayFormat
     * DateUtil.setShortDatetimeDisplayFormat()}.  Specify any valid {@link com.smartgwt.client.types.DateDisplayFormat} to
     * change the display format for datetimes used by this grid.  <P> May also be specified at the field level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDateFormatter ListGridField.dateFormatter} <P> If this field is
     * editable the dateFormatter will also be passed to the editor created to edit this field as {@link
     * com.smartgwt.client.widgets.form.fields.DateItem#getDateFormatter dateFormatter}. In this case you may also need to set
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getDateInputFormat dateInputFormat}.
     *
     * @param datetimeFormatter New datetimeFormatter value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#setDateFormatter
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setDatetimeFormatter(DateDisplayFormat datetimeFormatter) {
        setAttribute("datetimeFormatter", datetimeFormatter == null ? null : datetimeFormatter.getValue(), true);
    }

    /**
     * Display format to use for fields specified as type 'datetime'.  Default is to use the system-wide default date time
     * format, configured via {@link com.smartgwt.client.util.DateUtil#setShortDatetimeDisplayFormat
     * DateUtil.setShortDatetimeDisplayFormat()}.  Specify any valid {@link com.smartgwt.client.types.DateDisplayFormat} to
     * change the display format for datetimes used by this grid.  <P> May also be specified at the field level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDateFormatter ListGridField.dateFormatter} <P> If this field is
     * editable the dateFormatter will also be passed to the editor created to edit this field as {@link
     * com.smartgwt.client.widgets.form.fields.DateItem#getDateFormatter dateFormatter}. In this case you may also need to set
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getDateInputFormat dateInputFormat}.
     *
     * @return Current datetimeFormatter value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#getDateFormatter
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public DateDisplayFormat getDatetimeFormatter()  {
        return EnumUtil.getEnum(DateDisplayFormat.values(), getAttribute("datetimeFormatter"));
    }
    

    /**
     * Default width for date type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @param defaultDateFieldWidth New defaultDateFieldWidth value. Default value is varies
     */
    public void setDefaultDateFieldWidth(Integer defaultDateFieldWidth) {
        setAttribute("defaultDateFieldWidth", defaultDateFieldWidth, true);
    }

    /**
     * Default width for date type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @return Current defaultDateFieldWidth value. Default value is varies
     */
    public Integer getDefaultDateFieldWidth()  {
        return getAttributeAsInt("defaultDateFieldWidth");
    }
    

    /**
     * Default width for datetime type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @param defaultDateTimeFieldWidth New defaultDateTimeFieldWidth value. Default value is varies
     */
    public void setDefaultDateTimeFieldWidth(Integer defaultDateTimeFieldWidth) {
        setAttribute("defaultDateTimeFieldWidth", defaultDateTimeFieldWidth, true);
    }

    /**
     * Default width for datetime type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @return Current defaultDateTimeFieldWidth value. Default value is varies
     */
    public Integer getDefaultDateTimeFieldWidth()  {
        return getAttributeAsInt("defaultDateTimeFieldWidth");
    }
    

    /**
     * Default width for editable date type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @param defaultEditableDateFieldWidth New defaultEditableDateFieldWidth value. Default value is varies
     */
    public void setDefaultEditableDateFieldWidth(Integer defaultEditableDateFieldWidth) {
        setAttribute("defaultEditableDateFieldWidth", defaultEditableDateFieldWidth, true);
    }

    /**
     * Default width for editable date type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @return Current defaultEditableDateFieldWidth value. Default value is varies
     */
    public Integer getDefaultEditableDateFieldWidth()  {
        return getAttributeAsInt("defaultEditableDateFieldWidth");
    }
    

    /**
     * Default width for editable datetime type fields. See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields autoFitDateFields} for details on how this property is
     * used.
     *
     * @param defaultEditableDateTimeFieldWidth New defaultEditableDateTimeFieldWidth value. Default value is varies
     */
    public void setDefaultEditableDateTimeFieldWidth(Integer defaultEditableDateTimeFieldWidth) {
        setAttribute("defaultEditableDateTimeFieldWidth", defaultEditableDateTimeFieldWidth, true);
    }

    /**
     * Default width for editable datetime type fields. See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields autoFitDateFields} for details on how this property is
     * used.
     *
     * @return Current defaultEditableDateTimeFieldWidth value. Default value is varies
     */
    public Integer getDefaultEditableDateTimeFieldWidth()  {
        return getAttributeAsInt("defaultEditableDateTimeFieldWidth");
    }
    

    /**
     * An array of listGrid field configuration objects.  When a listGrid is initialized, if this property is set and there is
     * no value for the <code>fields</code> attribute, this.fields will be defaulted to a generated array of field objects
     * duplicated from this array. <P> This property is useful for cases where a standard set of fields will be displayed in
     * multiple listGrids - for example a subclass of ListGrid intended to display a particular type of data:<br> In this
     * example we would not assign a single {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array directly
     * to the class via <code>addProperties()</code> as every generated instance of this class would then point to the same
     * fields array object. This would cause unexpected behavior such as changes to the field order in one grid effecting other
     * grids on the page.<br> Instead we could use <code>addProperties()</code> on our new subclass to set
     * <code>defaultFields</code> to a standard array of fields to display. Each generated instance of the subclass would then
     * show up with default fields duplicated from this array.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param defaultFields New defaultFields value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setDefaultFields(ListGridField... defaultFields)  throws IllegalStateException {
        setAttribute("defaultFields", defaultFields, false);
    }

    /**
     * An array of listGrid field configuration objects.  When a listGrid is initialized, if this property is set and there is
     * no value for the <code>fields</code> attribute, this.fields will be defaulted to a generated array of field objects
     * duplicated from this array. <P> This property is useful for cases where a standard set of fields will be displayed in
     * multiple listGrids - for example a subclass of ListGrid intended to display a particular type of data:<br> In this
     * example we would not assign a single {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array directly
     * to the class via <code>addProperties()</code> as every generated instance of this class would then point to the same
     * fields array object. This would cause unexpected behavior such as changes to the field order in one grid effecting other
     * grids on the page.<br> Instead we could use <code>addProperties()</code> on our new subclass to set
     * <code>defaultFields</code> to a standard array of fields to display. Each generated instance of the subclass would then
     * show up with default fields duplicated from this array.
     *
     * @return Current defaultFields value. Default value is null
     */
    public ListGridField[] getDefaultFields()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfListGridField(getAttributeAsJavaScriptObject("defaultFields"));
    }
    

    /**
     * Default {@link com.smartgwt.client.types.OperatorId filter operator} to use for text-based fields in this grid's  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filter editor}, when producing {@link
     * com.smartgwt.client.data.AdvancedCriteria}.   When {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterExpressions allowFilterExpressions} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} are enabled for the grid, the
     * default is {@link com.smartgwt.client.data.DataSource#getTranslatePatternOperators "iContainsPattern"}.  Otherwise, the
     * default is "iContains". <p> Does not apply to special fields where exact match is obviously the right default setting,
     * such as fields of type:"enum", or fields with a {@link com.smartgwt.client.widgets.form.fields.FormItem#getValueMap
     * valueMap} or  {@link com.smartgwt.client.widgets.form.fields.FormItem#getOptionDataSource optionDataSource}.
     *
     * @param defaultFilterOperator New defaultFilterOperator value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setDefaultFilterOperator(OperatorId defaultFilterOperator)  throws IllegalStateException {
        setAttribute("defaultFilterOperator", defaultFilterOperator == null ? null : defaultFilterOperator.getValue(), false);
    }

    /**
     * Default {@link com.smartgwt.client.types.OperatorId filter operator} to use for text-based fields in this grid's  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filter editor}, when producing {@link
     * com.smartgwt.client.data.AdvancedCriteria}.   When {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterExpressions allowFilterExpressions} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} are enabled for the grid, the
     * default is {@link com.smartgwt.client.data.DataSource#getTranslatePatternOperators "iContainsPattern"}.  Otherwise, the
     * default is "iContains". <p> Does not apply to special fields where exact match is obviously the right default setting,
     * such as fields of type:"enum", or fields with a {@link com.smartgwt.client.widgets.form.fields.FormItem#getValueMap
     * valueMap} or  {@link com.smartgwt.client.widgets.form.fields.FormItem#getOptionDataSource optionDataSource}.
     *
     * @return Current defaultFilterOperator value. Default value is null
     */
    public OperatorId getDefaultFilterOperator()  {
        return EnumUtil.getEnum(OperatorId.values(), getAttribute("defaultFilterOperator"));
    }
    

    /**
     * Text to show after the name of the default filterOperator in the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} is enabled.
     *
     * @param defaultFilterOperatorSuffix New defaultFilterOperatorSuffix value. Default value is "(default)"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setDefaultFilterOperatorSuffix(String defaultFilterOperatorSuffix)  throws IllegalStateException {
        setAttribute("defaultFilterOperatorSuffix", defaultFilterOperatorSuffix, false);
    }

    /**
     * Text to show after the name of the default filterOperator in the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} is enabled.
     *
     * @return Current defaultFilterOperatorSuffix value. Default value is "(default)"
     */
    public String getDefaultFilterOperatorSuffix()  {
        return getAttributeAsString("defaultFilterOperatorSuffix");
    }
    

    /**
     * Default width for time type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @param defaultTimeFieldWidth New defaultTimeFieldWidth value. Default value is varies
     */
    public void setDefaultTimeFieldWidth(Integer defaultTimeFieldWidth) {
        setAttribute("defaultTimeFieldWidth", defaultTimeFieldWidth, true);
    }

    /**
     * Default width for time type fields. See {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitDateFields
     * autoFitDateFields} for details on how this property is used.
     *
     * @return Current defaultTimeFieldWidth value. Default value is varies
     */
    public Integer getDefaultTimeFieldWidth()  {
        return getAttributeAsInt("defaultTimeFieldWidth");
    }
    

    /**
     * When enabled, the field shown by {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}
     * causes records to be marked for future removal via {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved
     * markRecordRemoved()} instead of immediately being removed. <P> When a record has been marked for removal, an icon in the
     * <code>canRemoveRecords</code> field allowing it to be unmarked will be displayed. <P> If not explicitly specified by
     * this property, removal of records will be deferred if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits
     * autoSaveEdits} is false for the grid.
     *
     * @param deferRemoval New deferRemoval value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setDeferRemoval(Boolean deferRemoval)  throws IllegalStateException {
        setAttribute("deferRemoval", deferRemoval, false);
    }

    /**
     * When enabled, the field shown by {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}
     * causes records to be marked for future removal via {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved
     * markRecordRemoved()} instead of immediately being removed. <P> When a record has been marked for removal, an icon in the
     * <code>canRemoveRecords</code> field allowing it to be unmarked will be displayed. <P> If not explicitly specified by
     * this property, removal of records will be deferred if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits
     * autoSaveEdits} is false for the grid.
     *
     * @return Current deferRemoval value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getDeferRemoval()  {
        return getAttributeAsBoolean("deferRemoval");
    }
    

    /**
     * Should partially selected checkbox be deselected or selected on click? This setting affects {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll header selection checkbox}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectGroups group\n checkboxes} and folder checkbox selection in a Tree
     * data set. <p> By default clicking a partially selected checkbox selects it.
     *
     * @param deselectOnPartialCheckboxClick New deselectOnPartialCheckboxClick value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setDeselectOnPartialCheckboxClick(Boolean deselectOnPartialCheckboxClick) {
        setAttribute("deselectOnPartialCheckboxClick", deselectOnPartialCheckboxClick, true);
    }

    /**
     * Should partially selected checkbox be deselected or selected on click? This setting affects {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll header selection checkbox}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectGroups group\n checkboxes} and folder checkbox selection in a Tree
     * data set. <p> By default clicking a partially selected checkbox selects it.
     *
     * @return Current deselectOnPartialCheckboxClick value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public Boolean getDeselectOnPartialCheckboxClick()  {
        Boolean result = getAttributeAsBoolean("deselectOnPartialCheckboxClick");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>"related"</code>, this property specifies the
     * dataSource for the related records grid to be shown embedded in expanded records. <P> This property may also be
     * specified on a per-record basis - see {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordDetailDSProperty
     * recordDetailDSProperty}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param detailDS New detailDS value. Default value is null
     */
    public void setDetailDS(String detailDS) {
        setAttribute("detailDS", detailDS, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>"related"</code>, this property specifies the
     * dataSource for the related records grid to be shown embedded in expanded records. <P> This property may also be
     * specified on a per-record basis - see {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordDetailDSProperty
     * recordDetailDSProperty}
     *
     * @return Current detailDS value. Default value is null
     */
    public String getDetailDS()  {
        return getAttributeAsString("detailDS");
    }
    

    /**
     * The field whose contents to show in the expanded portion of a record when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is <code>true</code> and {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>detailField</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param detailField New detailField value. Default value is null
     */
    public void setDetailField(String detailField) {
        setAttribute("detailField", detailField, true);
    }

    /**
     * The field whose contents to show in the expanded portion of a record when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is <code>true</code> and {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>detailField</code>.
     *
     * @return Current detailField value. Default value is null
     */
    public String getDetailField()  {
        return getAttributeAsString("detailField");
    }
    

    /**
     * If a user is editing a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit:true} listGrid, and they hide
     * a field while the editor is showing, should we discard any edits in the edit row for the field being hidden? <P> Default
     * behavior is to discard the edits - set this flag to false to preserve edits
     *
     * @param discardEditsOnHideField New discardEditsOnHideField value. Default value is true
     */
    public void setDiscardEditsOnHideField(boolean discardEditsOnHideField) {
        setAttribute("discardEditsOnHideField", discardEditsOnHideField, true);
    }

    /**
     * If a user is editing a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit:true} listGrid, and they hide
     * a field while the editor is showing, should we discard any edits in the edit row for the field being hidden? <P> Default
     * behavior is to discard the edits - set this flag to false to preserve edits
     *
     * @return Current discardEditsOnHideField value. Default value is true
     */
    public boolean getDiscardEditsOnHideField()  {
        Boolean result = getAttributeAsBoolean("discardEditsOnHideField");
        return result == null ? true : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getConfirmDiscardEdits confirmDiscardEdits} is true this is the
     * title for the save button appearing in the lost edits confirmation dialog. Override this for localization if necessary.
     *
     * @param discardEditsSaveButtonTitle New discardEditsSaveButtonTitle value. Default value is "Save"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setDiscardEditsSaveButtonTitle(String discardEditsSaveButtonTitle) {
        setAttribute("discardEditsSaveButtonTitle", discardEditsSaveButtonTitle, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getConfirmDiscardEdits confirmDiscardEdits} is true this is the
     * title for the save button appearing in the lost edits confirmation dialog. Override this for localization if necessary.
     *
     * @return Current discardEditsSaveButtonTitle value. Default value is "Save"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getDiscardEditsSaveButtonTitle()  {
        return getAttributeAsString("discardEditsSaveButtonTitle");
    }
    
    

    /**
     * An automatically generated field that can be dragged to drag the current selection (where otherwise the grid itself
     * might be scrolled).  Visibility is controlled by  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowInitialDragHandles showInitialDragHandles}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#showDragHandles showDragHandles()}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideDragHandles hideDragHandles()}.
     * <p>
     * This component is an AutoChild named "dragHandleField".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current dragHandleField value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public ListGridField getDragHandleField() throws IllegalStateException {
        errorIfNotCreated("dragHandleField");
        return ListGridField.getOrCreateRef(getAttributeAsJavaScriptObject("dragHandleField"));
    }
    

    /**
     * The title to use for the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field}. <P> By
     * default this title is not displayed in the drag column header button as the autochild defaults for the field set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowTitle ListGridField.showTitle} to <code>false</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param dragHandleFieldTitle New dragHandleFieldTitle value. Default value is "&amp;nbsp;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     */
    public void setDragHandleFieldTitle(String dragHandleFieldTitle) {
        setAttribute("dragHandleFieldTitle", dragHandleFieldTitle, true);
    }

    /**
     * The title to use for the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field}. <P> By
     * default this title is not displayed in the drag column header button as the autochild defaults for the field set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowTitle ListGridField.showTitle} to <code>false</code>.
     *
     * @return Current dragHandleFieldTitle value. Default value is "&amp;nbsp;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     */
    public String getDragHandleFieldTitle()  {
        return getAttributeAsString("dragHandleFieldTitle");
    }
    

    /**
     * Default icon to show in the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field}..
     *
     * @param dragHandleIcon New dragHandleIcon value. Default value is "[SKIN]/actions/drag.png"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setDragHandleIcon(String dragHandleIcon)  throws IllegalStateException {
        setAttribute("dragHandleIcon", dragHandleIcon, false);
    }

    /**
     * Default icon to show in the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field}..
     *
     * @return Current dragHandleIcon value. Default value is "[SKIN]/actions/drag.png"
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getDragHandleIcon()  {
        return getAttributeAsString("dragHandleIcon");
    }
    

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleIcon drag handle icons} for
     * this ListGrid.
     *
     * @param dragHandleIconSize New dragHandleIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     */
    public void setDragHandleIconSize(int dragHandleIconSize) {
        setAttribute("dragHandleIconSize", dragHandleIconSize, true);
    }

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleIcon drag handle icons} for
     * this ListGrid.
     *
     * @return Current dragHandleIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     */
    public int getDragHandleIconSize()  {
        return getAttributeAsInt("dragHandleIconSize");
    }
    

    /**
     * Like {@link com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}, but applies when the
     * component is being drag-scrolled (via a scrollbar).  This value is typically set higher than {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} to avoid too many concurrent fetches
     * to the server for {@link com.smartgwt.client.data.ResultSet}-backed components since it's quite easy to induce such a
     * case with a scrollbar and a grid bound to a large databaset.
     *
     * @param dragScrollRedrawDelay New dragScrollRedrawDelay value. Default value is 75
     */
    public void setDragScrollRedrawDelay(int dragScrollRedrawDelay) {
        setAttribute("dragScrollRedrawDelay", dragScrollRedrawDelay, true);
    }

    /**
     * Like {@link com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}, but applies when the
     * component is being drag-scrolled (via a scrollbar).  This value is typically set higher than {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} to avoid too many concurrent fetches
     * to the server for {@link com.smartgwt.client.data.ResultSet}-backed components since it's quite easy to induce such a
     * case with a scrollbar and a grid bound to a large databaset.
     *
     * @return Current dragScrollRedrawDelay value. Default value is 75
     */
    public int getDragScrollRedrawDelay()  {
        return getAttributeAsInt("dragScrollRedrawDelay");
    }
    

    /**
     * When records are being dragged from within a ListGrid, what sort of drag-tracker should be displayed?<br> Note that if
     * multiple records are being dragged the displayed tracker will be based on the first selected record.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param dragTrackerMode New dragTrackerMode value. Default value is "icon"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setDragTrackerMode(DragTrackerMode dragTrackerMode)  throws IllegalStateException {
        setAttribute("dragTrackerMode", dragTrackerMode == null ? null : dragTrackerMode.getValue(), false);
    }

    /**
     * When records are being dragged from within a ListGrid, what sort of drag-tracker should be displayed?<br> Note that if
     * multiple records are being dragged the displayed tracker will be based on the first selected record.
     *
     * @return Current dragTrackerMode value. Default value is "icon"
     */
    public DragTrackerMode getDragTrackerMode()  {
        return EnumUtil.getEnum(DragTrackerMode.values(), getAttribute("dragTrackerMode"));
    }
    
    

    /**
     * How far should we render records ahead of the currently visible area?  This is expressed as a ratio from viewport size
     * to rendered area size. <P> Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs
     * initial render time and render time when scrolling by large amounts. <P> NOTE: Only applies when showAllRecords is
     * false.
     *
     * @param drawAheadRatio New drawAheadRatio value. Default value is 2.0
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_fetch" target="examples">Databound fetch Example</a>
     */
    public void setDrawAheadRatio(float drawAheadRatio) {
        setAttribute("drawAheadRatio", drawAheadRatio, true);
    }

    /**
     * How far should we render records ahead of the currently visible area?  This is expressed as a ratio from viewport size
     * to rendered area size. <P> Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs
     * initial render time and render time when scrolling by large amounts. <P> NOTE: Only applies when showAllRecords is
     * false.
     *
     * @return Current drawAheadRatio value. Default value is 2.0
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_fetch" target="examples">Databound fetch Example</a>
     */
    public float getDrawAheadRatio()  {
        return getAttributeAsFloat("drawAheadRatio");
    }
    

    /**
     * If drawing all rows would cause less than <code>drawAllMaxCells</code> cells to be rendered, the full dataset will
     * instead be drawn even if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllRecords showAllRecords} is false and
     * the viewport size and {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio} setting would
     * normally have caused incremental rendering to be used. <P> The <code>drawAllMaxCells</code> setting prevents incremental
     * rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200
     * cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief
     * "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be
     * obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on
     * initial draw time. <P> <code>drawAllMaxCells:0</code> disables this features.  You may want to disable this feature if
     * performance is an issue and: <ul> <li> you are very frequently redraw a grid <li> you do a lot of computation when
     * rendering each cell (eg formulas) <li> you are showing many grids on one screen and the user won't scroll most of them
     * </ul>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param drawAllMaxCells New drawAllMaxCells value. Default value is 250
     */
    public void setDrawAllMaxCells(int drawAllMaxCells) {
        setAttribute("drawAllMaxCells", drawAllMaxCells, true);
    }

    /**
     * If drawing all rows would cause less than <code>drawAllMaxCells</code> cells to be rendered, the full dataset will
     * instead be drawn even if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowAllRecords showAllRecords} is false and
     * the viewport size and {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio} setting would
     * normally have caused incremental rendering to be used. <P> The <code>drawAllMaxCells</code> setting prevents incremental
     * rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200
     * cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief
     * "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be
     * obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on
     * initial draw time. <P> <code>drawAllMaxCells:0</code> disables this features.  You may want to disable this feature if
     * performance is an issue and: <ul> <li> you are very frequently redraw a grid <li> you do a lot of computation when
     * rendering each cell (eg formulas) <li> you are showing many grids on one screen and the user won't scroll most of them
     * </ul>
     *
     * @return Current drawAllMaxCells value. Default value is 250
     */
    public int getDrawAllMaxCells()  {
        return getAttributeAsInt("drawAllMaxCells");
    }
    

    /**
     * Determines whether when the user edits a cell in this listGrid the entire row becomes editable, or just the cell that
     * received the edit event. <P> No effect if this.canEdit is false or null.
     *
     * @param editByCell New editByCell value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCanEdit
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_cell" target="examples">Edit by cell Example</a>
     */
    public void setEditByCell(Boolean editByCell) {
        setAttribute("editByCell", editByCell, true);
    }

    /**
     * Determines whether when the user edits a cell in this listGrid the entire row becomes editable, or just the cell that
     * received the edit event. <P> No effect if this.canEdit is false or null.
     *
     * @return Current editByCell value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCanEdit
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_cell" target="examples">Edit by cell Example</a>
     */
    public Boolean getEditByCell()  {
        return getAttributeAsBoolean("editByCell");
    }
    

    /**
     * Event that will trigger inline editing, see {@link com.smartgwt.client.types.ListGridEditEvent} for options. <P> Note
     * this setting has no effect unless {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} has been set to
     * enable editing. <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getEditOnFocus editOnFocus} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()}.
     *
     * @param editEvent New editEvent value. Default value is "doubleClick"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_row" target="examples">Edit by row Example</a>
     */
    public void setEditEvent(ListGridEditEvent editEvent) {
        setAttribute("editEvent", editEvent == null ? null : editEvent.getValue(), true);
    }

    /**
     * Event that will trigger inline editing, see {@link com.smartgwt.client.types.ListGridEditEvent} for options. <P> Note
     * this setting has no effect unless {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} has been set to
     * enable editing. <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getEditOnFocus editOnFocus} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()}.
     *
     * @return Current editEvent value. Default value is "doubleClick"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_row" target="examples">Edit by row Example</a>
     */
    public ListGridEditEvent getEditEvent()  {
        return EnumUtil.getEnum(ListGridEditEvent.values(), getAttribute("editEvent"));
    }
    

    /**
     * A base name for the CSS class applied to cells when editing has failed.<br>  If this listGrid is editable, this style
     * will be applied to any edited cells for which  validation failed.<br>  As with the default 'baseStyle' property, this
     * style will have "Dark", "Over", "Selected",  or "Disabled" appended to it according to the state of the cell.<br> If
     * null, cells for which editing has failed will be rendered using the normal base style classNames, but with custom
     * CSSText applied as derived from <code>this.editFailedCSSText</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editFailedBaseStyle New editFailedBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGrid#setEditFailedCSSText
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setEditFailedBaseStyle(String editFailedBaseStyle) {
        setAttribute("editFailedBaseStyle", editFailedBaseStyle, true);
    }

    /**
     * A base name for the CSS class applied to cells when editing has failed.<br>  If this listGrid is editable, this style
     * will be applied to any edited cells for which  validation failed.<br>  As with the default 'baseStyle' property, this
     * style will have "Dark", "Over", "Selected",  or "Disabled" appended to it according to the state of the cell.<br> If
     * null, cells for which editing has failed will be rendered using the normal base style classNames, but with custom
     * CSSText applied as derived from <code>this.editFailedCSSText</code>
     *
     * @return Current editFailedBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditFailedCSSText
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getEditFailedBaseStyle()  {
        return getAttributeAsString("editFailedBaseStyle");
    }
    

    /**
     * Custom CSS text to be applied to cells when editing has failed.<br>  If this listGrid is editable, this css text will be
     * applied to any edited cells for which  validation failed, on top of the base style for the cell.<br> For further
     * customization of styling for cells that failed editing validation, use <code>this.editFailedBaseStyle</code> instead.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editFailedCSSText New editFailedCSSText value. Default value is "color:red;border:1px solid red;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setEditFailedBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setEditFailedCSSText(String editFailedCSSText) {
        setAttribute("editFailedCSSText", editFailedCSSText, true);
    }

    /**
     * Custom CSS text to be applied to cells when editing has failed.<br>  If this listGrid is editable, this css text will be
     * applied to any edited cells for which  validation failed, on top of the base style for the cell.<br> For further
     * customization of styling for cells that failed editing validation, use <code>this.editFailedBaseStyle</code> instead.
     *
     * @return Current editFailedCSSText value. Default value is "color:red;border:1px solid red;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditFailedBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getEditFailedCSSText()  {
        return getAttributeAsString("editFailedCSSText");
    }
    

    /**
     * Should we start editing when the widget has focus and the user presses the "f2" key (if this ListGrid supports editing)?
     * <P> Note that if {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is set to <code>"click"</code>
     * or <code>"doubleClick"</code>, the <code>Space</code> or <code>Enter</code> key may also be used to start editing,
     * depending on the value for {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateClickOnSpace
     * generateClickOnSpace}, {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateDoubleClickOnSpace
     * generateDoubleClickOnSpace}, {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateClickOnEnter
     * generateClickOnEnter} and {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateDoubleClickOnEnter
     * generateDoubleClickOnEnter}. <P> If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} is false, or
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is set to "none" this property has no effect.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editOnF2Keypress New editOnF2Keypress value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setEditOnF2Keypress(Boolean editOnF2Keypress) {
        setAttribute("editOnF2Keypress", editOnF2Keypress, true);
    }

    /**
     * Should we start editing when the widget has focus and the user presses the "f2" key (if this ListGrid supports editing)?
     * <P> Note that if {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is set to <code>"click"</code>
     * or <code>"doubleClick"</code>, the <code>Space</code> or <code>Enter</code> key may also be used to start editing,
     * depending on the value for {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateClickOnSpace
     * generateClickOnSpace}, {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateDoubleClickOnSpace
     * generateDoubleClickOnSpace}, {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateClickOnEnter
     * generateClickOnEnter} and {@link com.smartgwt.client.widgets.grid.ListGrid#getGenerateDoubleClickOnEnter
     * generateDoubleClickOnEnter}. <P> If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} is false, or
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is set to "none" this property has no effect.
     *
     * @return Current editOnF2Keypress value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getEditOnF2Keypress()  {
        Boolean result = getAttributeAsBoolean("editOnF2Keypress");
        return result == null ? true : result;
    }
    

    /**
     * Should we start editing when this widget receives focus (if this ListGrid supports editing)? <P> Note that this property
     * being set to true will cause editing to occur on a single click, even if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is <code>"doubleClick"</code>, because single clicking
     * the grid will place keyboard focus there automatically. <P> If this property is set together with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} being set to "next",  users can create
     * a new edit row in an empty grid by simply tabbing into the grid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editOnFocus New editOnFocus value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setEditOnFocus(Boolean editOnFocus) {
        setAttribute("editOnFocus", editOnFocus, true);
    }

    /**
     * Should we start editing when this widget receives focus (if this ListGrid supports editing)? <P> Note that this property
     * being set to true will cause editing to occur on a single click, even if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditEvent editEvent} is <code>"doubleClick"</code>, because single clicking
     * the grid will place keyboard focus there automatically. <P> If this property is set together with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} being set to "next",  users can create
     * a new edit row in an empty grid by simply tabbing into the grid.
     *
     * @return Current editOnFocus value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getEditOnFocus()  {
        return getAttributeAsBoolean("editOnFocus");
    }
    

    /**
     * A base name for the CSS class applied to cells containing pending (unsaved) edits<br> As with the default 'baseStyle'
     * property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the
     * cell. <P> If this property is null (the default setting), cells with pending edits will pick up custom css text to be
     * applied on top of the normal base style from <code>this.editPendingCSSText</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editPendingBaseStyle New editPendingBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setEditPendingBaseStyle(String editPendingBaseStyle)  throws IllegalStateException {
        setAttribute("editPendingBaseStyle", editPendingBaseStyle, false);
    }

    /**
     * A base name for the CSS class applied to cells containing pending (unsaved) edits<br> As with the default 'baseStyle'
     * property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the
     * cell. <P> If this property is null (the default setting), cells with pending edits will pick up custom css text to be
     * applied on top of the normal base style from <code>this.editPendingCSSText</code>.
     *
     * @return Current editPendingBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getEditPendingBaseStyle()  {
        return getAttributeAsString("editPendingBaseStyle");
    }
    

    /**
     * Custom CSS text to be applied to cells with pending edits that have not yet been submitted.<br> For further
     * customization of styling for cells with pending edits use <code>this.editPendingBaseStyle</code> instead.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param editPendingCSSText New editPendingCSSText value. Default value is "color:#0066CC;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setEditFailedBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setEditPendingCSSText(String editPendingCSSText) {
        setAttribute("editPendingCSSText", editPendingCSSText, true);
    }

    /**
     * Custom CSS text to be applied to cells with pending edits that have not yet been submitted.<br> For further
     * customization of styling for cells with pending edits use <code>this.editPendingBaseStyle</code> instead.
     *
     * @return Current editPendingCSSText value. Default value is "color:#0066CC;"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditFailedBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getEditPendingCSSText()  {
        return getAttributeAsString("editPendingCSSText");
    }
    

    /**
     * Default class used to construct the {@link com.smartgwt.client.tools.EditProxy} for this component when the component is
     * {@link com.smartgwt.client.widgets.Canvas#setEditMode first placed into edit mode}.
     *
     * @param editProxyConstructor New editProxyConstructor value. Default value is "GridEditProxy"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SCClassName SCClassName 
     */
    public void setEditProxyConstructor(String editProxyConstructor)  throws IllegalStateException {
        setAttribute("editProxyConstructor", editProxyConstructor, false);
    }

    /**
     * Default class used to construct the {@link com.smartgwt.client.tools.EditProxy} for this component when the component is
     * {@link com.smartgwt.client.widgets.Canvas#setEditMode first placed into edit mode}.
     *
     * @return Current editProxyConstructor value. Default value is "GridEditProxy"
     * @see com.smartgwt.client.docs.SCClassName SCClassName 
     */
    public String getEditProxyConstructor()  {
        return getAttributeAsString("editProxyConstructor");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectOnEdit selectOnEdit} is true, what should be the
     * edit-selection behavior be? <P> Default setting of <code>"single"</code> will cause the edit row to be automatically
     * selected and any other selection in the grid to be dropped.<br> If set to <code>"multiple"</code>, selection will be
     * additive (as a record goes  into edit mode, it is selected in addition to any pre-existant selection). <P> If set to
     * <code>null</code> behavior is as follows:<ul> <li>For grids with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} set to <code>"simple"</code> edit rows will be
     * selected additively - this is the same behavior as if the <code>editSelectionType</code> was
     * <code>"multiple"</code></li> <li>Otherwise edit rows will be selected singly - this is the same behavior as if the
     * <code>editSelectionType</code> was <code>"single"</code></li> </ul>
     *
     * @param editSelectionType New editSelectionType value. Default value is "single"
     */
    public void setEditSelectionType(SelectionStyle editSelectionType) {
        setAttribute("editSelectionType", editSelectionType == null ? null : editSelectionType.getValue(), true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectOnEdit selectOnEdit} is true, what should be the
     * edit-selection behavior be? <P> Default setting of <code>"single"</code> will cause the edit row to be automatically
     * selected and any other selection in the grid to be dropped.<br> If set to <code>"multiple"</code>, selection will be
     * additive (as a record goes  into edit mode, it is selected in addition to any pre-existant selection). <P> If set to
     * <code>null</code> behavior is as follows:<ul> <li>For grids with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} set to <code>"simple"</code> edit rows will be
     * selected additively - this is the same behavior as if the <code>editSelectionType</code> was
     * <code>"multiple"</code></li> <li>Otherwise edit rows will be selected singly - this is the same behavior as if the
     * <code>editSelectionType</code> was <code>"single"</code></li> </ul>
     *
     * @return Current editSelectionType value. Default value is "single"
     */
    public SelectionStyle getEditSelectionType()  {
        return EnumUtil.getEnum(SelectionStyle.values(), getAttribute("editSelectionType"));
    }
    

    /**
     * The value to display for cells whose value is null or the empty string after applying {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter formatting} and valueMap (if any). <p> This is the grid-wide
     * attribute.  You may also set the emptyCellValue on a per-field basis.
     *
     * @param emptyCellValue New emptyCellValue value. Default value is "&amp;nbsp;"
     * @see com.smartgwt.client.widgets.grid.ListGridField#setEmptyCellValue
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_values" target="examples">Empty values Example</a>
     */
    public void setEmptyCellValue(String emptyCellValue) {
        setAttribute("emptyCellValue", emptyCellValue, true);
    }

    /**
     * The value to display for cells whose value is null or the empty string after applying {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter formatting} and valueMap (if any). <p> This is the grid-wide
     * attribute.  You may also set the emptyCellValue on a per-field basis.
     *
     * @return Current emptyCellValue value. Default value is "&amp;nbsp;"
     * @see com.smartgwt.client.widgets.grid.ListGridField#getEmptyCellValue
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_values" target="examples">Empty values Example</a>
     */
    public String getEmptyCellValue()  {
        return getAttributeAsString("emptyCellValue");
    }
    

    /**
     * The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
     *
     * @param emptyMessage New emptyMessage value. Default value is "No items to show."
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_grid" target="examples">Empty grid Example</a>
     */
    public void setEmptyMessage(String emptyMessage) {
        setAttribute("emptyMessage", emptyMessage, true);
    }

    /**
     * The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
     *
     * @return Current emptyMessage value. Default value is "No items to show."
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_grid" target="examples">Empty grid Example</a>
     */
    public String getEmptyMessage()  {
        return getAttributeAsString("emptyMessage");
    }
    

    /**
     * The CSS style name applied to the {@link com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessage emptyMessage} if
     * displayed.
     *
     * @param emptyMessageStyle New emptyMessageStyle value. Default value is "emptyMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setEmptyMessageStyle(String emptyMessageStyle) {
        setAttribute("emptyMessageStyle", emptyMessageStyle, true);
    }

    /**
     * The CSS style name applied to the {@link com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessage emptyMessage} if
     * displayed.
     *
     * @return Current emptyMessageStyle value. Default value is "emptyMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getEmptyMessageStyle()  {
        return getAttributeAsString("emptyMessageStyle");
    }
    

    /**
     * For performance reasons, even when {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights
     * fixedRecordHeights} is set, vertical clipping is not enforced by default for some kinds of content (such as images) on
     * all browsers. Set {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping enforceVClipping:true} to enforce
     * clipping for all types of content on all browsers. <P> This additional setting is likely to be phased out as browsers
     * improve.
     *
     * @param enforceVClipping New enforceVClipping value. Default value is false
     */
    public void setEnforceVClipping(Boolean enforceVClipping) {
        setAttribute("enforceVClipping", enforceVClipping, true);
    }

    /**
     * For performance reasons, even when {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights
     * fixedRecordHeights} is set, vertical clipping is not enforced by default for some kinds of content (such as images) on
     * all browsers. Set {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping enforceVClipping:true} to enforce
     * clipping for all types of content on all browsers. <P> This additional setting is likely to be phased out as browsers
     * improve.
     *
     * @return Current enforceVClipping value. Default value is false
     */
    public Boolean getEnforceVClipping()  {
        Boolean result = getAttributeAsBoolean("enforceVClipping");
        return result == null ? false : result;
    }
    

    /**
     * What to do when a user hits enter while editing a cell: <ul> <li>"nextCell": start editing the next editable cell in
     * this record (or the first     editable cell in the next record if focus is in the last editable cell in the row)
     * <li>"nextRow": start editing the same field in the next row (skipping any rows where      that would be a non-editable
     * cell. <li>"nextRowStart": start editing the first editable cell in the next row. <li>"done": hide the editor (editing is
     * complete) </ul> Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
     *
     * @param enterKeyEditAction New enterKeyEditAction value. Default value is "done"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setEnterKeyEditAction(EnterKeyEditAction enterKeyEditAction) {
        setAttribute("enterKeyEditAction", enterKeyEditAction == null ? null : enterKeyEditAction.getValue(), true);
    }

    /**
     * What to do when a user hits enter while editing a cell: <ul> <li>"nextCell": start editing the next editable cell in
     * this record (or the first     editable cell in the next record if focus is in the last editable cell in the row)
     * <li>"nextRow": start editing the same field in the next row (skipping any rows where      that would be a non-editable
     * cell. <li>"nextRowStart": start editing the first editable cell in the next row. <li>"done": hide the editor (editing is
     * complete) </ul> Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
     *
     * @return Current enterKeyEditAction value. Default value is "done"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public EnterKeyEditAction getEnterKeyEditAction()  {
        return EnumUtil.getEnum(EnterKeyEditAction.values(), getAttribute("enterKeyEditAction"));
    }
    

    /**
     * In a ListGrid that has a DataSource and has filter criteria that include values for fields declared as {@link
     * com.smartgwt.client.types.FieldType type "enum"} in the DataSource, by default a newly edited row will use those filter
     * criteria as initial values. <P> For example, if a ListGrid is showing all Accounts that have status:"Active" and a new
     * row is created, the new row will default to status:"Active" unless this flag is set to false.
     *
     * @param enumCriteriaAsInitialValues New enumCriteriaAsInitialValues value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setEnumCriteriaAsInitialValues(Boolean enumCriteriaAsInitialValues)  throws IllegalStateException {
        setAttribute("enumCriteriaAsInitialValues", enumCriteriaAsInitialValues, false);
    }

    /**
     * In a ListGrid that has a DataSource and has filter criteria that include values for fields declared as {@link
     * com.smartgwt.client.types.FieldType type "enum"} in the DataSource, by default a newly edited row will use those filter
     * criteria as initial values. <P> For example, if a ListGrid is showing all Accounts that have status:"Active" and a new
     * row is created, the new row will default to status:"Active" unless this flag is set to false.
     *
     * @return Current enumCriteriaAsInitialValues value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getEnumCriteriaAsInitialValues()  {
        Boolean result = getAttributeAsBoolean("enumCriteriaAsInitialValues");
        return result == null ? true : result;
    }
    

    /**
     * Height of the error icon, if we're showing icons when validation errors occur.
     *
     * @param errorIconHeight New errorIconHeight value. Default value is 16
     */
    public void setErrorIconHeight(Integer errorIconHeight) {
        setAttribute("errorIconHeight", errorIconHeight, true);
    }

    /**
     * Height of the error icon, if we're showing icons when validation errors occur.
     *
     * @return Current errorIconHeight value. Default value is 16
     */
    public Integer getErrorIconHeight()  {
        return getAttributeAsInt("errorIconHeight");
    }
    

    /**
     * Src of the image to show as an error icon, if we're showing icons when validation      errors occur.
     *
     * @param errorIconSrc New errorIconSrc value. Default value is "[SKIN]/ListGrid/validation_error_icon.png"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setErrorIconSrc(String errorIconSrc) {
        setAttribute("errorIconSrc", errorIconSrc, true);
    }

    /**
     * Src of the image to show as an error icon, if we're showing icons when validation      errors occur.
     *
     * @return Current errorIconSrc value. Default value is "[SKIN]/ListGrid/validation_error_icon.png"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getErrorIconSrc()  {
        return getAttributeAsString("errorIconSrc");
    }
    

    /**
     * Height of the error icon, if we're showing icons when validation errors occur.
     *
     * @param errorIconWidth New errorIconWidth value. Default value is 16
     */
    public void setErrorIconWidth(Integer errorIconWidth) {
        setAttribute("errorIconWidth", errorIconWidth, true);
    }

    /**
     * Height of the error icon, if we're showing icons when validation errors occur.
     *
     * @return Current errorIconWidth value. Default value is 16
     */
    public Integer getErrorIconWidth()  {
        return getAttributeAsInt("errorIconWidth");
    }
    

    /**
     * What to do when a user hits escape while editing a cell:<ul> <li>"cancel": close the editor and discard the current set
     * of edit values <li>"done": just close the editor (the edit is complete, but the edited values are retained). </ul> Note
     * that if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits} is true, this may cause a save
     * of the current edit values
     *
     * @param escapeKeyEditAction New escapeKeyEditAction value. Default value is "cancel"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setEscapeKeyEditAction(EscapeKeyEditAction escapeKeyEditAction) {
        setAttribute("escapeKeyEditAction", escapeKeyEditAction == null ? null : escapeKeyEditAction.getValue(), true);
    }

    /**
     * What to do when a user hits escape while editing a cell:<ul> <li>"cancel": close the editor and discard the current set
     * of edit values <li>"done": just close the editor (the edit is complete, but the edited values are retained). </ul> Note
     * that if {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits} is true, this may cause a save
     * of the current edit values
     *
     * @return Current escapeKeyEditAction value. Default value is "cancel"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public EscapeKeyEditAction getEscapeKeyEditAction()  {
        return EnumUtil.getEnum(EscapeKeyEditAction.values(), getAttribute("escapeKeyEditAction"));
    }
    

    /**
     * For {@link com.smartgwt.client.types.ExpansionMode expansionModes} that show another grid or tree, is that component
     * editable? <P>The default value for this property is <code>false</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionCanEdit New expansionCanEdit value. Default value is null
     */
    public void setExpansionCanEdit(Boolean expansionCanEdit) {
        setAttribute("expansionCanEdit", expansionCanEdit, true);
    }

    /**
     * For {@link com.smartgwt.client.types.ExpansionMode expansionModes} that show another grid or tree, is that component
     * editable? <P>The default value for this property is <code>false</code>.
     *
     * @return Current expansionCanEdit value. Default value is null
     */
    public Boolean getExpansionCanEdit()  {
        return getAttributeAsBoolean("expansionCanEdit");
    }
    

    /**
     * The method of {@link com.smartgwt.client.types.RecordComponentPoolingMode component-pooling} to employ for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords expansionComponents}. <P> The default mode is "destroy",
     * which means that automatically created expansionComponents are destroyed when rows are collapsed.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionComponentPoolingMode New expansionComponentPoolingMode value. Default value is "destroy"
     */
    public void setExpansionComponentPoolingMode(ExpansionComponentPoolingMode expansionComponentPoolingMode) {
        setAttribute("expansionComponentPoolingMode", expansionComponentPoolingMode == null ? null : expansionComponentPoolingMode.getValue(), true);
    }

    /**
     * The method of {@link com.smartgwt.client.types.RecordComponentPoolingMode component-pooling} to employ for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords expansionComponents}. <P> The default mode is "destroy",
     * which means that automatically created expansionComponents are destroyed when rows are collapsed.
     *
     * @return Current expansionComponentPoolingMode value. Default value is "destroy"
     */
    public ExpansionComponentPoolingMode getExpansionComponentPoolingMode()  {
        return EnumUtil.getEnum(ExpansionComponentPoolingMode.values(), getAttribute("expansionComponentPoolingMode"));
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.HTMLFlow} for displaying the contents of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDetailField a specified field} in a record's expanded section when {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>detailField</code>. <P> This component is an
     * {@link com.smartgwt.client.types.AutoChild} and as such may be customized via
     * <code>listGrid.expansionDetailFieldProperties</code> and <code>listGrid.expansionDetailFieldDefaults</code>. <P> Note,
     * however, that this is a multi-instance component (potentially one per record), so it is created using  createAutoChild()
     * not  addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public HTMLFlow getExpansionDetailField()  {
        return null;
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.layout.HLayout} appearing in a record's expanded section when
     * {@link com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>detailRelated</code>. This component
     * contains two other autoChild components, a {@link com.smartgwt.client.widgets.viewer.DetailViewer} for viewing fields
     * from the record which are not already present in the grid and a separate embedded {@link
     * com.smartgwt.client.widgets.grid.ListGrid} for displaying other data related to this record via record.detailDS.  See
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionDetails expansionDetails} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionRelated expansionRelated} for more information. <P> This component
     * is an {@link com.smartgwt.client.types.AutoChild} and as such may be customized via
     * <code>listGrid.expansionDetailRelatedProperties</code> and <code>listGrid.expansionDetailRelatedDefaults</code>. <P>
     * Note, however, that this is a multi-instance component (potentially one per record), so it is created using 
     * createAutoChild() not  addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public HLayout getExpansionDetailRelated()  {
        return null;
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.viewer.DetailViewer} for displaying the details of a record
     * in its expanded section when {@link com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is
     * <code>details</code>.  Note that only those fields which do not already appear in the grid are displayed in the expanded
     * section. <P> This component is an {@link com.smartgwt.client.types.AutoChild} and as such may be customized via
     * <code>listGrid.expansionDetailsProperties</code> and <code>listGrid.expansionDetailsDefaults</code>. <P> Note, however,
     * that this is a multi-instance component (potentially one per record), so it is created using  createAutoChild() not 
     * addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public DetailViewer getExpansionDetails()  {
        return null;
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.form.DynamicForm} for editing the details of a record in its
     * expanded section when {@link com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>editor</code>. 
     * Note that only those fields which do not already appear in the grid will appear in the expanded section. <P> According
     * to the value of {@link com.smartgwt.client.widgets.grid.ListGrid#getShowExpansionEditorSaveButton
     * showExpansionEditorSaveButton}, a save button is shown beneath the editor.  You can save the values in the editor by
     * clicking this button <P> This component is an {@link com.smartgwt.client.types.AutoChild} and as such may be customized
     * via <code>listGrid.expansionEditorProperties</code> and <code>listGrid.expansionEditorDefaults</code>. <P> Note,
     * however, that this is a multi-instance component (potentially one per record), so it is created using  createAutoChild()
     * not  addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public DynamicForm getExpansionEditor()  {
        return null;
    }
    

    /**
     * When {@link com.smartgwt.client.types.ExpansionMode} is <i>editor</i>, should the row be collapsed following a save
     * initiated by the expansion-component's {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionEditorSaveButton
     * save button}.
     * <p>
     * <b>Note :</b> This method should be called only after the widget has been rendered.
     *
     * @return Current expansionEditorCollapseOnSave value. Default value is true
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public Boolean getExpansionEditorCollapseOnSave() throws IllegalStateException {
        errorIfNotCreated("expansionEditorCollapseOnSave");
        Boolean result = getAttributeAsBoolean("expansionEditorCollapseOnSave");
        return result == null ? true : result;
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.IButton} for saving the values in the expanded portion of a
     * ListGrid row. <P> This component is an {@link com.smartgwt.client.types.AutoChild} and as such may be customized via
     * <code>listGrid.expansionEditorSaveButtonProperties</code> and <code>listGrid.expansionEditorSaveButtonDefaults</code>.
     * <P> Note, however, that this is a multi-instance component (potentially one per record), so it is created using 
     * createAutoChild() not  addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public IButton getExpansionEditorSaveButton()  {
        return null;
    }
    

    /**
     * The title for the {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionEditorSaveButton
     * expansionEditorSaveButton}.
     * <p>
     * <b>Note :</b> This method should be called only after the widget has been rendered.
     *
     * @return Current expansionEditorSaveButtonTitle value. Default value is "Save"
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public String getExpansionEditorSaveButtonTitle() throws IllegalStateException {
        errorIfNotCreated("expansionEditorSaveButtonTitle");
        return getAttributeAsString("expansionEditorSaveButtonTitle");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} is <i>editor</i>, the prompt to display in a
     * dialog when an expanded row is collapsed while it's nested editor has changed values.
     *
     * @param expansionEditorSaveDialogPrompt New expansionEditorSaveDialogPrompt value. Default value is "You have unsaved changes - do you want to save them now?"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExpansionEditorSaveDialogPrompt(String expansionEditorSaveDialogPrompt)  throws IllegalStateException {
        setAttribute("expansionEditorSaveDialogPrompt", expansionEditorSaveDialogPrompt, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} is <i>editor</i>, the prompt to display in a
     * dialog when an expanded row is collapsed while it's nested editor has changed values.
     *
     * @return Current expansionEditorSaveDialogPrompt value. Default value is "You have unsaved changes - do you want to save them now?"
     */
    public String getExpansionEditorSaveDialogPrompt()  {
        return getAttributeAsString("expansionEditorSaveDialogPrompt");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} is <i>editor</i>, whether a dialog should be
     * displayed when an expanded row is collapsed while it's nested editor has changed values.
     *
     * @param expansionEditorShowSaveDialog New expansionEditorShowSaveDialog value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExpansionEditorShowSaveDialog(Boolean expansionEditorShowSaveDialog)  throws IllegalStateException {
        setAttribute("expansionEditorShowSaveDialog", expansionEditorShowSaveDialog, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionMode expansionMode} is <i>editor</i>, whether a dialog should be
     * displayed when an expanded row is collapsed while it's nested editor has changed values.
     *
     * @return Current expansionEditorShowSaveDialog value. Default value is null
     */
    public Boolean getExpansionEditorShowSaveDialog()  {
        return getAttributeAsBoolean("expansionEditorShowSaveDialog");
    }
    

    /**
     * The field providing the facility to expand and collapse rows.
     * <p>
     * This component is an AutoChild named "expansionField".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Returns the specially generated expansion field used when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true. <P> Called during {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFields setFields()}, this method can be overridden to add advanced dynamic
     * defaults to the expansion field (call Super, modify the default field returned by Super, return the modified field). 
     * Normal customization can be handled by just setting {@link com.smartgwt.client.types.AutoChild} properties, as mentioned
     * under the docs for {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionField expansionField}. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public ListGridField getExpansionField() throws IllegalStateException {
        errorIfNotCreated("expansionField");
        return ListGridField.getOrCreateRef(getAttributeAsJavaScriptObject("expansionField"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property determines the image to display in the expansion field for collapsed rows. If unset, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} will be used.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionFieldFalseImage New expansionFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldImageHeight
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setExpansionFieldFalseImage(String expansionFieldFalseImage) {
        setAttribute("expansionFieldFalseImage", expansionFieldFalseImage, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property determines the image to display in the expansion field for collapsed rows. If unset, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} will be used.
     *
     * @return Current expansionFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldTrueImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageHeight
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getExpansionFieldFalseImage()  {
        return getAttributeAsString("expansionFieldFalseImage");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property may be set to govern the height of the expansion image displayed to indicate whether a row is expanded. If
     * unset, the expansionField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageHeight booleanImageHeight} for this grid.
     *
     * @param expansionFieldImageHeight New expansionFieldImageHeight value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExpansionFieldImageHeight(Integer expansionFieldImageHeight)  throws IllegalStateException {
        setAttribute("expansionFieldImageHeight", expansionFieldImageHeight, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property may be set to govern the height of the expansion image displayed to indicate whether a row is expanded. If
     * unset, the expansionField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageHeight booleanImageHeight} for this grid.
     *
     * @return Current expansionFieldImageHeight value. Default value is null
     */
    public Integer getExpansionFieldImageHeight()  {
        return getAttributeAsInt("expansionFieldImageHeight");
    }
    

    /**
     * Should a "_selected" suffix be added to the  {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldTrueImage
     * expansionFieldTrueImage} and {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldFalseImage
     * expansionFieldFalseImage} image URLs for selected rows? <P> This allows developers to provide separate expansion field
     * media for selected rows, in case the selected row style does not contrast well with the standard expansion field image
     * media. <P> If both this property and {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageShowRTL
     * expansionFieldImageShowRTL} are true, and the grid is in RTL mode, both suffixes will be applied to selected rows'
     * expansion field image (combined as "selected_rtl")
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionFieldImageShowSelected New expansionFieldImageShowSelected value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExpansionFieldImageShowSelected(boolean expansionFieldImageShowSelected)  throws IllegalStateException {
        setAttribute("expansionFieldImageShowSelected", expansionFieldImageShowSelected, false);
    }

    /**
     * Should a "_selected" suffix be added to the  {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldTrueImage
     * expansionFieldTrueImage} and {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldFalseImage
     * expansionFieldFalseImage} image URLs for selected rows? <P> This allows developers to provide separate expansion field
     * media for selected rows, in case the selected row style does not contrast well with the standard expansion field image
     * media. <P> If both this property and {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageShowRTL
     * expansionFieldImageShowRTL} are true, and the grid is in RTL mode, both suffixes will be applied to selected rows'
     * expansion field image (combined as "selected_rtl")
     *
     * @return Current expansionFieldImageShowSelected value. Default value is false
     */
    public boolean getExpansionFieldImageShowSelected()  {
        Boolean result = getAttributeAsBoolean("expansionFieldImageShowSelected");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property may be set to govern the width of the expansion image displayed to indicate whether a row is expanded. If
     * unset, the expansionField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageWidth booleanImageWidth} for this grid.
     *
     * @param expansionFieldImageWidth New expansionFieldImageWidth value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExpansionFieldImageWidth(Integer expansionFieldImageWidth)  throws IllegalStateException {
        setAttribute("expansionFieldImageWidth", expansionFieldImageWidth, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property may be set to govern the width of the expansion image displayed to indicate whether a row is expanded. If
     * unset, the expansionField image will be sized to match the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanImageWidth booleanImageWidth} for this grid.
     *
     * @return Current expansionFieldImageWidth value. Default value is null
     */
    public Integer getExpansionFieldImageWidth()  {
        return getAttributeAsInt("expansionFieldImageWidth");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property determines the image to display in the expansion field for expanded rows. If unset, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} will be used.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionFieldTrueImage New expansionFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setExpansionFieldImageHeight
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setExpansionFieldTrueImage(String expansionFieldTrueImage) {
        setAttribute("expansionFieldTrueImage", expansionFieldTrueImage, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is set to <code>true</code>,
     * this property determines the image to display in the expansion field for expanded rows. If unset, the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} will be used.
     *
     * @return Current expansionFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldFalseImage
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getExpansionFieldImageHeight
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getExpansionFieldTrueImage()  {
        return getAttributeAsString("expansionFieldTrueImage");
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.layout.VLayout} which fills a record's expanded section and
     * contains other builtin {@link com.smartgwt.client.types.ExpansionMode expansion-components}.  You can also override
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponent getExpansionComponent()} to provide components of
     * your own specification. <P> This component is an {@link com.smartgwt.client.types.AutoChild} and as such may be
     * customized via <code>listGrid.expansionLayoutProperties</code> and <code>listGrid.expansionLayoutDefaults</code>. <P>
     * Note, however, that this is a multi-instance component (potentially one per record), so it is created using 
     * createAutoChild() not  addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public VLayout getExpansionLayout()  {
        return null;
    }
    

    /**
     * The {@link com.smartgwt.client.types.ExpansionMode} for records in this grid. Default <code>null</code> value means no
     * expansion.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param expansionMode New expansionMode value. Default value is null
     */
    public void setExpansionMode(ExpansionMode expansionMode) {
        setAttribute("expansionMode", expansionMode == null ? null : expansionMode.getValue(), true);
    }

    /**
     * The {@link com.smartgwt.client.types.ExpansionMode} for records in this grid. Default <code>null</code> value means no
     * expansion.
     *
     * @return Current expansionMode value. Default value is null
     */
    public ExpansionMode getExpansionMode()  {
        return EnumUtil.getEnum(ExpansionMode.values(), getAttribute("expansionMode"));
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid} for displaying data related to a record in its
     * expanded section when {@link com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>related</code>.
     * The {@link com.smartgwt.client.data.DataSource} containing the related data is provided by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRelatedDataSource getRelatedDataSource()} which, by default, returns the
     * DataSource referred to in {@link com.smartgwt.client.widgets.grid.ListGridRecord#getDetailDS ListGridRecord.detailDS}.
     * <P> This component is an {@link com.smartgwt.client.types.AutoChild} and as such may be customized via
     * <code>listGrid.expansionRelatedProperties</code> and <code>listGrid.expansionRelatedDefaults</code>. <P> Note, however,
     * that this is a multi-instance component (potentially one per record), so it is created using  createAutoChild() not 
     * addAutoChild(), and no default single instance is created by name on the grid.
     *
     * @return null
     */
    public ListGrid getExpansionRelated()  {
        return null;
    }
    

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, background color
     * to use  for even-numbered rows, to create a "banded" or "ledger" effect.  Odd-numbered rows will  use the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportDefaultBGColor exportDefaultBGColor}. <p> See {@link
     * com.smartgwt.client.docs.ExportBGColor} for an overview.
     *
     * @param exportAlternateRowBGColor New exportAlternateRowBGColor value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public void setExportAlternateRowBGColor(String exportAlternateRowBGColor)  throws IllegalStateException {
        setAttribute("exportAlternateRowBGColor", exportAlternateRowBGColor, false);
    }

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, background color
     * to use  for even-numbered rows, to create a "banded" or "ledger" effect.  Odd-numbered rows will  use the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportDefaultBGColor exportDefaultBGColor}. <p> See {@link
     * com.smartgwt.client.docs.ExportBGColor} for an overview.
     *
     * @return Current exportAlternateRowBGColor value. Default value is null
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public String getExportAlternateRowBGColor()  {
        return getAttributeAsString("exportAlternateRowBGColor");
    }
    

    /**
     * Default background color to use when exporting data to Excel/OpenOffice format using {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportData exportData()} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}. <p> If unset (the default), cells that
     * are not provided a background color by more specific APIs will be the default background color used by the spreadsheet
     * program where they are viewed. <p> See {@link com.smartgwt.client.docs.ExportBGColor} for an overview.
     *
     * @param exportDefaultBGColor New exportDefaultBGColor value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public void setExportDefaultBGColor(String exportDefaultBGColor)  throws IllegalStateException {
        setAttribute("exportDefaultBGColor", exportDefaultBGColor, false);
    }

    /**
     * Default background color to use when exporting data to Excel/OpenOffice format using {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportData exportData()} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}. <p> If unset (the default), cells that
     * are not provided a background color by more specific APIs will be the default background color used by the spreadsheet
     * program where they are viewed. <p> See {@link com.smartgwt.client.docs.ExportBGColor} for an overview.
     *
     * @return Current exportDefaultBGColor value. Default value is null
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public String getExportDefaultBGColor()  {
        return getAttributeAsString("exportDefaultBGColor");
    }
    

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether field
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getAlign horizontal header alignments} and  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCellAlign data value alignments} should be replicated in the resulting
     * spreadsheet.  <p> If this attribute is not set, cells will be assigned a default alignment by the spreadsheet, which is
     * typically right-aligned for numeric and date values, and left-aligned for  everything else (including dates and numbers
     * that have been exported as strings, as would be the case, for example, if {@link
     * com.smartgwt.client.data.DSRequest#getExportDatesAsFormattedString DSRequest.exportDatesAsFormattedString} is set)
     *
     * @param exportFieldAlignments New exportFieldAlignments value. Default value is false
     */
    public void setExportFieldAlignments(boolean exportFieldAlignments) {
        setAttribute("exportFieldAlignments", exportFieldAlignments, true);
    }

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether field
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getAlign horizontal header alignments} and  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCellAlign data value alignments} should be replicated in the resulting
     * spreadsheet.  <p> If this attribute is not set, cells will be assigned a default alignment by the spreadsheet, which is
     * typically right-aligned for numeric and date values, and left-aligned for  everything else (including dates and numbers
     * that have been exported as strings, as would be the case, for example, if {@link
     * com.smartgwt.client.data.DSRequest#getExportDatesAsFormattedString DSRequest.exportDatesAsFormattedString} is set)
     *
     * @return Current exportFieldAlignments value. Default value is false
     */
    public boolean getExportFieldAlignments()  {
        Boolean result = getAttributeAsBoolean("exportFieldAlignments");
        return result == null ? false : result;
    }
    

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether widths
     * of fields should be replicated in the resulting spreadsheet. <p> Because Excel's unit of measurement for field widths is
     * based on the default system font, there is no exact way to translate field widths in pixels to Excel column widths.  The
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExportWidthScale exportWidthScale} property can be set to adjust
     * scaling; it's default value errs on the side of making Excel's columns slightly wider than the ListGrid field's actual
     * width to avoid clipping. <p> Note that you can switch off width export for individual fields with the  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportFieldWidth ListGridField.exportFieldWidth} flag.
     *
     * @param exportFieldWidths New exportFieldWidths value. Default value is false
     */
    public void setExportFieldWidths(boolean exportFieldWidths) {
        setAttribute("exportFieldWidths", exportFieldWidths, true);
    }

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether widths
     * of fields should be replicated in the resulting spreadsheet. <p> Because Excel's unit of measurement for field widths is
     * based on the default system font, there is no exact way to translate field widths in pixels to Excel column widths.  The
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getExportWidthScale exportWidthScale} property can be set to adjust
     * scaling; it's default value errs on the side of making Excel's columns slightly wider than the ListGrid field's actual
     * width to avoid clipping. <p> Note that you can switch off width export for individual fields with the  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportFieldWidth ListGridField.exportFieldWidth} flag.
     *
     * @return Current exportFieldWidths value. Default value is false
     */
    public boolean getExportFieldWidths()  {
        Boolean result = getAttributeAsBoolean("exportFieldWidths");
        return result == null ? false : result;
    }
    

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, causes the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight headerHeight} and {@link
     * com.smartgwt.client.widgets.grid.HeaderSpan#getHeight headerSpan heights} to be applied to the corresponding cells in
     * the spreadsheet.
     *
     * @param exportHeaderHeights New exportHeaderHeights value. Default value is false
     */
    public void setExportHeaderHeights(boolean exportHeaderHeights) {
        setAttribute("exportHeaderHeights", exportHeaderHeights, true);
    }

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, causes the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight headerHeight} and {@link
     * com.smartgwt.client.widgets.grid.HeaderSpan#getHeight headerSpan heights} to be applied to the corresponding cells in
     * the spreadsheet.
     *
     * @return Current exportHeaderHeights value. Default value is false
     */
    public boolean getExportHeaderHeights()  {
        Boolean result = getAttributeAsBoolean("exportHeaderHeights");
        return result == null ? false : result;
    }
    

    /**
     * Width to size non-visible fields (which may be specified with {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getExportFields exportFields} or {@link
     * com.smartgwt.client.data.DSRequest#getExportFields DSRequest.exportFields}) during {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportData exportData()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}.
     *
     * @param exportHiddenFieldWidth New exportHiddenFieldWidth value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGridField#setExportFieldWidth
     */
    public void setExportHiddenFieldWidth(int exportHiddenFieldWidth) {
        setAttribute("exportHiddenFieldWidth", exportHiddenFieldWidth, true);
    }

    /**
     * Width to size non-visible fields (which may be specified with {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getExportFields exportFields} or {@link
     * com.smartgwt.client.data.DSRequest#getExportFields DSRequest.exportFields}) during {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportData exportData()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}.
     *
     * @return Current exportHiddenFieldWidth value. Default value is 100
     * @see com.smartgwt.client.widgets.grid.ListGridField#getExportFieldWidth
     */
    public int getExportHiddenFieldWidth()  {
        return getAttributeAsInt("exportHiddenFieldWidth");
    }
    

    /**
     * Dictates whether numeric values should be exported as raw numbers instead of formatted values when using {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}. <P> This property is only consulted if
     * <code>exportRawValues</code> is not set to true at the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportRawValues grid} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues field} level. That property causes all values,
     * including numeric values, to be exported unformatted. <P> This is useful for cases where an explicit ListGrid formatter
     * function simply displays the number as a formatted string for the user (for example "1,234"). Exporting that formatted
     * string rather than the underlying numeric value causes spreadsheet applications such as Excel to lose some
     * functionality. <P> If this property is not explicitly set, numeric values will be exported as raw numbers for {@link
     * com.smartgwt.client.data.DSRequest#getExportAs XLS and OOXML export} only. <P> May be overridden at the field level via
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getExportRawNumbers ListGridField.exportRawNumbers}.
     *
     * @param exportRawNumbers New exportRawNumbers value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExportRawNumbers(Boolean exportRawNumbers)  throws IllegalStateException {
        setAttribute("exportRawNumbers", exportRawNumbers, false);
    }

    /**
     * Dictates whether numeric values should be exported as raw numbers instead of formatted values when using {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}. <P> This property is only consulted if
     * <code>exportRawValues</code> is not set to true at the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportRawValues grid} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues field} level. That property causes all values,
     * including numeric values, to be exported unformatted. <P> This is useful for cases where an explicit ListGrid formatter
     * function simply displays the number as a formatted string for the user (for example "1,234"). Exporting that formatted
     * string rather than the underlying numeric value causes spreadsheet applications such as Excel to lose some
     * functionality. <P> If this property is not explicitly set, numeric values will be exported as raw numbers for {@link
     * com.smartgwt.client.data.DSRequest#getExportAs XLS and OOXML export} only. <P> May be overridden at the field level via
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getExportRawNumbers ListGridField.exportRawNumbers}.
     *
     * @return Current exportRawNumbers value. Default value is null
     */
    public Boolean getExportRawNumbers()  {
        return getAttributeAsBoolean("exportRawNumbers");
    }
    

    /**
     * Dictates whether the data in this grid should be exported raw by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}.  If set to true, data will not be
     * processed by field-formatters during exports. Decreases the time taken for large exports.  This property can also be set
     * at the {@link com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues field level}.
     *
     * @param exportRawValues New exportRawValues value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setExportRawValues(Boolean exportRawValues)  throws IllegalStateException {
        setAttribute("exportRawValues", exportRawValues, false);
    }

    /**
     * Dictates whether the data in this grid should be exported raw by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}.  If set to true, data will not be
     * processed by field-formatters during exports. Decreases the time taken for large exports.  This property can also be set
     * at the {@link com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues field level}.
     *
     * @return Current exportRawValues value. Default value is null
     */
    public Boolean getExportRawValues()  {
        return getAttributeAsBoolean("exportRawValues");
    }
    

    /**
     * Scaling factor to translate from ListGrid field widths in pixels to Excel/OpenOffice units for field width, which are
     * 1/256th of the width of the widest digit character in the default font for the spreadsheet.  See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportFieldWidths exportFieldWidths} for where this is used.
     *
     * @param exportWidthScale New exportWidthScale value. Default value is 0.12
     */
    public void setExportWidthScale(double exportWidthScale) {
        setAttribute("exportWidthScale", exportWidthScale, true);
    }

    /**
     * Scaling factor to translate from ListGrid field widths in pixels to Excel/OpenOffice units for field width, which are
     * 1/256th of the width of the widest digit character in the default font for the spreadsheet.  See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExportFieldWidths exportFieldWidths} for where this is used.
     *
     * @return Current exportWidthScale value. Default value is 0.12
     */
    public double getExportWidthScale()  {
        return getAttributeAsDouble("exportWidthScale");
    }
    

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether titles
     * in the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeader ListGrid header} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans} should be allowed to wrap. <p> Excel will wrap at
     * the column boundary automatically; for explicit control over wrapping, insert "&lt;br&gt;" tags into your titles. <p>
     * See also {@link com.smartgwt.client.widgets.grid.ListGrid#getExportFieldWidths exportFieldWidths} for replicating the
     * widths of fields in the exported spreadsheet.
     *
     * @param exportWrapHeaderTitles New exportWrapHeaderTitles value. Default value is false
     */
    public void setExportWrapHeaderTitles(boolean exportWrapHeaderTitles) {
        setAttribute("exportWrapHeaderTitles", exportWrapHeaderTitles, true);
    }

    /**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, whether titles
     * in the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeader ListGrid header} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans} should be allowed to wrap. <p> Excel will wrap at
     * the column boundary automatically; for explicit control over wrapping, insert "&lt;br&gt;" tags into your titles. <p>
     * See also {@link com.smartgwt.client.widgets.grid.ListGrid#getExportFieldWidths exportFieldWidths} for replicating the
     * widths of fields in the exported spreadsheet.
     *
     * @return Current exportWrapHeaderTitles value. Default value is false
     */
    public boolean getExportWrapHeaderTitles()  {
        Boolean result = getAttributeAsBoolean("exportWrapHeaderTitles");
        return result == null ? false : result;
    }
    

    /**
     * <b>Note: This property only has an effect in Internet Explorer</b> <P> Advanced property to improve performance for
     * dynamic styling of gridRenderer cells in Internet Explorer, at the expense of slightly slower initial drawing, and some 
     * limitations on supported styling options. <P> <code>fastCellUpdates</code> speeds up the dynamic styling system used by
     * rollovers, selections, and custom styling that calls {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#refreshCellStyle GridRenderer.refreshCellStyle()}, at the cost of slightly
     * slower draw() and redraw() times. <P> Notes: <ul> <li>When this property is set, ListGrid cells may be styled using the 
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle}. See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle getBaseStyle()} for      more information.</li> <li>If any cell
     * styles specify a a background image URL, the URL will be resolved relative     to the page location rather than the
     * location of the CSS stylesheet. This means cell     styles with a background URL should either supply a fully qualified
     * path, or the     background image media should be made available at a second location for IE.</li> <li>fastCellUpdates
     * will not work if the styles involved are in an external stylesheet loaded     from a remote host. Either the stylesheet
     * containing cell styles needs to be loaded     from the same host as the main page, or the cell styles need to be inlined
     * in the html      of the bootstrap page.</li> <li>fastCellUpdates will not work if the css styles for cells are defined
     * in     a <code>.css</code> file loaded via <code>@import</code>. Instead the <code>.css</code>     file should be loaded
     * via a <code>&lt;link ...&gt;</code> tag.</li> </ul>
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.GridRenderer#getFastCellUpdates GridRenderer.fastCellUpdates}. Has no effect in browsers other than Internet Explorer.
     *
     * @param fastCellUpdates whether to enable fastCellUpdates. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFastCellUpdates(Boolean fastCellUpdates)  throws IllegalStateException {
        setAttribute("fastCellUpdates", fastCellUpdates, false);
    }
    

    /**
     * If we're showing the filterEditor ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor
     * showFilterEditor} is true), and we're re-filtering on every keypress ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterOnKeypress filterOnKeypress} is true), this property is the delay in
     * milliseconds between the user changing the filter and the filter request being kicked off. If multiple changes are made
     * to the filter within this fetch delay, only the most recent will actually cause a re-filter
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param fetchDelay New fetchDelay value. Default value is 300
     */
    public void setFetchDelay(int fetchDelay) {
        setAttribute("fetchDelay", fetchDelay, true);
    }

    /**
     * If we're showing the filterEditor ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor
     * showFilterEditor} is true), and we're re-filtering on every keypress ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterOnKeypress filterOnKeypress} is true), this property is the delay in
     * milliseconds between the user changing the filter and the filter request being kicked off. If multiple changes are made
     * to the filter within this fetch delay, only the most recent will actually cause a re-filter
     *
     * @return Current fetchDelay value. Default value is 300
     */
    public int getFetchDelay()  {
        return getAttributeAsInt("fetchDelay");
    }
    

    /**
     * Names of properties on {@link com.smartgwt.client.widgets.grid.ListGridField} for which the {@link
     * com.smartgwt.client.widgets.FieldPicker} should show an editing interface, for convenience. <P> For example, specify
     * ["frozen", "decimalPrecision"] to allow end users to modify {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen ListGridField.frozen} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDecimalPrecision ListGridField.decimalPrecision} respectively.
     *
     * @param fieldPickerFieldProperties New fieldPickerFieldProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFieldPickerFieldProperties(String... fieldPickerFieldProperties)  throws IllegalStateException {
        setAttribute("fieldPickerFieldProperties", fieldPickerFieldProperties, false);
    }

    /**
     * Names of properties on {@link com.smartgwt.client.widgets.grid.ListGridField} for which the {@link
     * com.smartgwt.client.widgets.FieldPicker} should show an editing interface, for convenience. <P> For example, specify
     * ["frozen", "decimalPrecision"] to allow end users to modify {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen ListGridField.frozen} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDecimalPrecision ListGridField.decimalPrecision} respectively.
     *
     * @return Current fieldPickerFieldProperties value. Default value is null
     */
    public String[] getFieldPickerFieldProperties()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfString(getAttributeAsJavaScriptObject("fieldPickerFieldProperties"));
    }
    

    /**
     * When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
     *
     * @param fieldPickerShowSampleValues New fieldPickerShowSampleValues value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFieldPickerShowSampleValues(Boolean fieldPickerShowSampleValues)  throws IllegalStateException {
        setAttribute("fieldPickerShowSampleValues", fieldPickerShowSampleValues, false);
    }

    /**
     * When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
     *
     * @return Current fieldPickerShowSampleValues value. Default value is true
     */
    public Boolean getFieldPickerShowSampleValues()  {
        Boolean result = getAttributeAsBoolean("fieldPickerShowSampleValues");
        return result == null ? true : result;
    }
    

    /**
     * Instance of {@link com.smartgwt.client.widgets.FieldPickerWindow} used if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseAdvancedFieldPicker useAdvancedFieldPicker} is set.
     * <p>
     * This component is an AutoChild named "fieldPickerWindow".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current fieldPickerWindow value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public FieldPickerWindow getFieldPickerWindow() throws IllegalStateException {
        errorIfNotCreated("fieldPickerWindow");
        return (FieldPickerWindow)FieldPickerWindow.getByJSObject(getAttributeAsJavaScriptObject("fieldPickerWindow"));
    }
    

    /**
     * An array of field objects, specifying the order, layout, formatting, and sorting behavior of each field in the listGrid
     * object.  In ListGrids, the fields array specifies columns.  Each field in the fields array is a ListGridField object.
     * Any listGrid that will display data should have at least one visible field. <p> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} is also set, this value acts as a set of overrides
     * as explained in {@link com.smartgwt.client.widgets.DataBoundComponent#getFields DataBoundComponent.fields}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Sets the fields array and/or field widths to newFields and sizes, respectively.<br><br> If newFields is specified, it is assumed that the new fields may have nothing in common with the old fields, and the component is substantially rebuilt.  Furthermore, it's invalid to modify any of the existing {@link com.smartgwt.client.widgets.grid.ListGridField}s after they've been passed to this function. Consider the following methods for more efficient, more incremental changes: {@link com.smartgwt.client.widgets.grid.ListGrid#resizeField resizeField()}, {@link com.smartgwt.client.widgets.grid.ListGrid#reorderField reorderField()}, {@link com.smartgwt.client.widgets.grid.ListGrid#showField showField()}, {@link com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()}, or {@link com.smartgwt.client.widgets.grid.ListGrid#setFieldProperties setFieldProperties()}.
     *
     * @param fields array of fields to draw. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFields
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_lg_fields" target="examples">ListGrid fields Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_merged_fields" target="examples">Merged fields Example</a>
     */
    public void setFields(ListGridField... fields) {
        setAttribute("fields", fields, true);
    }

    /**
     * An array of field objects, specifying the order, layout, formatting, and sorting behavior of each field in the listGrid
     * object.  In ListGrids, the fields array specifies columns.  Each field in the fields array is a ListGridField object.
     * Any listGrid that will display data should have at least one visible field. <p> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} is also set, this value acts as a set of overrides
     * as explained in {@link com.smartgwt.client.widgets.DataBoundComponent#getFields DataBoundComponent.fields}.
     *
     * @return Get the array of all <b>currently visible</b> fields for this ListGrid. <P> This list fields is only valid once the
     * ListGrid has been {@link com.smartgwt.client.widgets.Canvas#draw drawn} or once {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFields setFields()} has been called explicitly.  If called earlier, only
     * the list of directly specified fields will be returned (the Array passed to create()). <P> This Array should be treated
     * as <b>read-only</b>.  To modify the set of visible fields, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#showField showField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} and related APIs.  To update properties of individual
     * fields, use {@link com.smartgwt.client.widgets.grid.ListGrid#setFieldProperties setFieldProperties()} or more specific
     * APIs such as {@link com.smartgwt.client.widgets.grid.ListGrid#setFieldTitle setFieldTitle()}. <P> To get the Array of
     * all fields, including fields that are not currently visible or were specified implicitly, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllFields getAllFields()}. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFields
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_lg_fields" target="examples">ListGrid fields Example</a>
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_databinding_merged_fields" target="examples">Merged fields Example</a>
     */
    public ListGridField[] getFields()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfListGridField(getAttributeAsJavaScriptObject("fields"));
    }
    

    /**
     * Initial {@link com.smartgwt.client.docs.ListGridFieldState field state} for the grid. <p> {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be used to initialize all view properties of the
     * grid. When doing so, <code>fieldState</code> is not needed because <code>viewState</code> includes it as well. If both
     * are provided, <code>fieldState</code> has priority for field state.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Sets some presentation properties (visibility, width, userFormula and userSummary) of the listGrid fields based on the {@link com.smartgwt.client.docs.ListGridFieldState} object passed in.<br> Used to restore previous state retrieved from the grid by a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getFieldState getFieldState()}.
     *
     * @param fieldState state to apply to the listGrid's fields. Default value is null
     * @see com.smartgwt.client.docs.ListGridFieldState ListGridFieldState 
     */
    public void setFieldState(String fieldState) {
        setAttribute("fieldState", fieldState, true);
    }

    /**
     * Initial {@link com.smartgwt.client.docs.ListGridFieldState field state} for the grid. <p> {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be used to initialize all view properties of the
     * grid. When doing so, <code>fieldState</code> is not needed because <code>viewState</code> includes it as well. If both
     * are provided, <code>fieldState</code> has priority for field state.
     *
     * @return Returns a snapshot of the current presentation of this listGrid's fields as a {@link
     * com.smartgwt.client.docs.ListGridFieldState} object. <P> This object can later be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFieldState setFieldState()} to reset this grid's fields to the current
     * state. <P> Note that the information stored includes the current width and visibility of each of this grid's fields, as
     * well as any {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddFormulaFields formula} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAddSummaryFields summary fields} added by the user. Default value is null
     * @see com.smartgwt.client.docs.ListGridFieldState ListGridFieldState 
     */
    public String getFieldState()  {
        return getAttributeAsString("fieldState");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields this.canPickFields} is true, this attribute
     * will be shown as the title for the menu item which contains a submenu with items allowing the user to show and hide
     * fields in the grid.
     *
     * @param fieldVisibilitySubmenuTitle New fieldVisibilitySubmenuTitle value. Default value is "Columns"
     */
    public void setFieldVisibilitySubmenuTitle(String fieldVisibilitySubmenuTitle) {
        setAttribute("fieldVisibilitySubmenuTitle", fieldVisibilitySubmenuTitle, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanPickFields this.canPickFields} is true, this attribute
     * will be shown as the title for the menu item which contains a submenu with items allowing the user to show and hide
     * fields in the grid.
     *
     * @return Current fieldVisibilitySubmenuTitle value. Default value is "Columns"
     */
    public String getFieldVisibilitySubmenuTitle()  {
        return getAttributeAsString("fieldVisibilitySubmenuTitle");
    }
    

    /**
     * The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
     *
     * @param filterButtonPrompt New filterButtonPrompt value. Default value is "Filter"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFilterButtonPrompt(String filterButtonPrompt)  throws IllegalStateException {
        setAttribute("filterButtonPrompt", filterButtonPrompt, false);
    }

    /**
     * The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
     *
     * @return Current filterButtonPrompt value. Default value is "Filter"
     */
    public String getFilterButtonPrompt()  {
        return getAttributeAsString("filterButtonPrompt");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, this attribute may be
     * used to customize the filter button shown to the right of the filterEditor row.
     *
     * @param filterButtonProperties New filterButtonProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setFilterButtonProperties(Button filterButtonProperties)  throws IllegalStateException {
        if (filterButtonProperties != null) {
            if (filterButtonProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, "setFilterButtonProperties", "Button");
            }                                                                       
            filterButtonProperties.setConfigOnly(true);
        }
        JavaScriptObject config = filterButtonProperties == null ? null : filterButtonProperties.getConfig();
        setAttribute("filterButtonProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, this attribute may be
     * used to customize the filter button shown to the right of the filterEditor row.
     *
     * @return Current filterButtonProperties value. Default value is null
     */
    public Button getFilterButtonProperties()  {
        Button properties = new Button();
        properties.setConfigOnly(true);
        properties.setConfig(getAttributeAsJavaScriptObject("filterButtonProperties"));
        return properties;
    }
    

    /**
     * If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be
     * filtered every time the user puts focus in a different field in the filter editor.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param filterByCell New filterByCell value. Default value is null
     */
    public void setFilterByCell(Boolean filterByCell) {
        setAttribute("filterByCell", filterByCell, true);
    }

    /**
     * If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be
     * filtered every time the user puts focus in a different field in the filter editor.
     *
     * @return Current filterByCell value. Default value is null
     */
    public Boolean getFilterByCell()  {
        return getAttributeAsBoolean("filterByCell");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is set to true, the
     * <code>filterEditor</code> is automatically created as an AutoChild.<br> Developers may customize the AutoChild using
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditorProperties filterEditorProperties}.
     * <p>
     * This component is an AutoChild named "filterEditor".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current filterEditor value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public RecordEditor getFilterEditor() throws IllegalStateException {
        errorIfNotCreated("filterEditor");
        return (RecordEditor)RecordEditor.getByJSObject(getAttributeAsJavaScriptObject("filterEditor"));
    }
    

    /**
     * Height for the filterEditor, if shown.
     *
     * @param filterEditorHeight New filterEditorHeight value. Default value is 22
     */
    public void setFilterEditorHeight(int filterEditorHeight) {
        setAttribute("filterEditorHeight", filterEditorHeight, true);
    }

    /**
     * Height for the filterEditor, if shown.
     *
     * @return Current filterEditorHeight value. Default value is 22
     */
    public int getFilterEditorHeight()  {
        return getAttributeAsInt("filterEditorHeight");
    }
    

    /**
     * Properties to apply to the automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor
     * filterEditor} if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true.
     *
     * @param filterEditorProperties New filterEditorProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setFilterEditorProperties(RecordEditor filterEditorProperties)  throws IllegalStateException {
        if (filterEditorProperties != null) {
            if (filterEditorProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, "setFilterEditorProperties", "RecordEditor");
            }                                                                       
            filterEditorProperties.setConfigOnly(true);
        }
        JavaScriptObject config = filterEditorProperties == null ? null : filterEditorProperties.getConfig();
        setAttribute("filterEditorProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Properties to apply to the automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor
     * filterEditor} if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true.
     *
     * @return Current filterEditorProperties value. Default value is null
     */
    public RecordEditor getFilterEditorProperties()  {
        RecordEditor properties = new RecordEditor();
        properties.setConfigOnly(true);
        properties.setConfig(getAttributeAsJavaScriptObject("filterEditorProperties"));
        return properties;
    }
    

    /**
     * Causes filtering to be performed against the local data set, even when a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} is provided. <p> When using this mode, data must be
     * provided to the grid via {@link com.smartgwt.client.widgets.grid.ListGrid#setData setData()}, and must be provided as  
     * a RecordList.   <p> Note that a {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} must be
     * provided for filtering to occur even when filtering locally. <P> If this property is set to true, the supplied data is
     * applied as the  {@link com.smartgwt.client.data.ResultSet#getAllRows complete dataset} of a {@link
     * com.smartgwt.client.data.ResultSet}, which is then  filtered according to the specified criteria, and the results
     * displayed. If false, a  normal databound fetch will occur, retrieving records that match the specified criteria  from
     * this component's {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}. <p>
     * <code>filterLocalData</code> includes both calls to {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()} and {@link com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()} as well as automatic
     * filtering when the {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filterEditor} is enabled. <p> If
     * this property is not explicitly set, default behavior will filter against the dataSource unless the grid has a specified
     * {@link com.smartgwt.client.docs.DataPath dataPath}, in which case filtering will occur locally. <p> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} to cause saves to ignore the DataSource and affect
     * the local data set only.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param filterLocalData New filterLocalData value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFilterLocalData(Boolean filterLocalData)  throws IllegalStateException {
        setAttribute("filterLocalData", filterLocalData, false);
    }

    /**
     * Causes filtering to be performed against the local data set, even when a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} is provided. <p> When using this mode, data must be
     * provided to the grid via {@link com.smartgwt.client.widgets.grid.ListGrid#setData setData()}, and must be provided as  
     * a RecordList.   <p> Note that a {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} must be
     * provided for filtering to occur even when filtering locally. <P> If this property is set to true, the supplied data is
     * applied as the  {@link com.smartgwt.client.data.ResultSet#getAllRows complete dataset} of a {@link
     * com.smartgwt.client.data.ResultSet}, which is then  filtered according to the specified criteria, and the results
     * displayed. If false, a  normal databound fetch will occur, retrieving records that match the specified criteria  from
     * this component's {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}. <p>
     * <code>filterLocalData</code> includes both calls to {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()} and {@link com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()} as well as automatic
     * filtering when the {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filterEditor} is enabled. <p> If
     * this property is not explicitly set, default behavior will filter against the dataSource unless the grid has a specified
     * {@link com.smartgwt.client.docs.DataPath dataPath}, in which case filtering will occur locally. <p> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} to cause saves to ignore the DataSource and affect
     * the local data set only.
     *
     * @return Current filterLocalData value. Default value is null
     */
    public Boolean getFilterLocalData()  {
        return getAttributeAsBoolean("filterLocalData");
    }
    

    /**
     * If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be
     * filtered every time the user modifies the value in a field of the filter-editor. Can also be set at the field level.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param filterOnKeypress New filterOnKeypress value. Default value is null
     */
    public void setFilterOnKeypress(Boolean filterOnKeypress) {
        setAttribute("filterOnKeypress", filterOnKeypress, true);
    }

    /**
     * If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be
     * filtered every time the user modifies the value in a field of the filter-editor. Can also be set at the field level.
     *
     * @return Current filterOnKeypress value. Default value is null
     */
    public Boolean getFilterOnKeypress()  {
        return getAttributeAsBoolean("filterOnKeypress");
    }
    

    /**
     * Text for the menu item shown in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu
     * headerContextMenu} when {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators}
     * is enabled.
     *
     * @param filterUsingText New filterUsingText value. Default value is "Filter using"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setFilterUsingText(String filterUsingText)  throws IllegalStateException {
        setAttribute("filterUsingText", filterUsingText, false);
    }

    /**
     * Text for the menu item shown in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu
     * headerContextMenu} when {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators}
     * is enabled.
     *
     * @return Current filterUsingText value. Default value is "Filter using"
     */
    public String getFilterUsingText()  {
        return getAttributeAsString("filterUsingText");
    }
    

    /**
     * Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? <P> If we allow
     * columns to expand, the column width is treated as a minimum. <P> NOTE: the header does not automatically respond to
     * expanded field widths. If your grid is showing a header we'd recommend developers consider setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} rather than using this attribute.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param fixedFieldWidths New fixedFieldWidths value. Default value is true
     */
    public void setFixedFieldWidths(Boolean fixedFieldWidths) {
        setAttribute("fixedFieldWidths", fixedFieldWidths, true);
    }

    /**
     * Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? <P> If we allow
     * columns to expand, the column width is treated as a minimum. <P> NOTE: the header does not automatically respond to
     * expanded field widths. If your grid is showing a header we'd recommend developers consider setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} rather than using this attribute.
     *
     * @return Current fixedFieldWidths value. Default value is true
     */
    public Boolean getFixedFieldWidths()  {
        Boolean result = getAttributeAsBoolean("fixedFieldWidths");
        return result == null ? true : result;
    }
    

    /**
     * Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? <P> If we allow rows
     * to expand, the row height as derived from {@link com.smartgwt.client.widgets.grid.GridRenderer#getRowHeight
     * getRowHeight()} or the default {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} is treated as
     * a minimum. <P> Setting <code>fixedRecordHeights</code> to false enables the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling} system. <P> <b>NOTE:</b><ul> <li>Setting
     * fixedRecordHeights to false for {@link com.smartgwt.client.widgets.cube.CubeGrid} is not supported, though a similar
     * option for the row headers is available as {@link com.smartgwt.client.widgets.cube.CubeGrid#getAutoSizeHeaders
     * CubeGrid.autoSizeHeaders}. <li>By default, for performance reasons, clipping is not enforced for some kinds of content
     * (such as images) on all browsers.  Set {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping
     * enforceVClipping:true} to enforce clipping for all types of content on all browsers. </ul>
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param fixedRecordHeights New fixedRecordHeights value. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_values" target="examples">Cell Values Example</a>
     */
    public void setFixedRecordHeights(Boolean fixedRecordHeights) {
        setAttribute("fixedRecordHeights", fixedRecordHeights, true);
    }

    /**
     * Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? <P> If we allow rows
     * to expand, the row height as derived from {@link com.smartgwt.client.widgets.grid.GridRenderer#getRowHeight
     * getRowHeight()} or the default {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} is treated as
     * a minimum. <P> Setting <code>fixedRecordHeights</code> to false enables the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling} system. <P> <b>NOTE:</b><ul> <li>Setting
     * fixedRecordHeights to false for {@link com.smartgwt.client.widgets.cube.CubeGrid} is not supported, though a similar
     * option for the row headers is available as {@link com.smartgwt.client.widgets.cube.CubeGrid#getAutoSizeHeaders
     * CubeGrid.autoSizeHeaders}. <li>By default, for performance reasons, clipping is not enforced for some kinds of content
     * (such as images) on all browsers.  Set {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping
     * enforceVClipping:true} to enforce clipping for all types of content on all browsers. </ul>
     *
     * @return Current fixedRecordHeights value. Default value is true
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_values" target="examples">Cell Values Example</a>
     */
    public Boolean getFixedRecordHeights()  {
        Boolean result = getAttributeAsBoolean("fixedRecordHeights");
        return result == null ? true : result;
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInFormulaBuilder showHeaderSpanTitlesInFormulaBuilder}
     * is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid in
     * the FormulaBuilder and SummaryBuilder.
     *
     * @param formulaBuilderSpanTitleSeparator New formulaBuilderSpanTitleSeparator value. Default value is " - "
     */
    public void setFormulaBuilderSpanTitleSeparator(String formulaBuilderSpanTitleSeparator) {
        setAttribute("formulaBuilderSpanTitleSeparator", formulaBuilderSpanTitleSeparator, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInFormulaBuilder showHeaderSpanTitlesInFormulaBuilder}
     * is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid in
     * the FormulaBuilder and SummaryBuilder.
     *
     * @return Current formulaBuilderSpanTitleSeparator value. Default value is " - "
     */
    public String getFormulaBuilderSpanTitleSeparator()  {
        return getAttributeAsString("formulaBuilderSpanTitleSeparator");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze a currently unfrozen field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Freeze " + the field's summary title.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param freezeFieldText New freezeFieldText value. Default value is "Freeze ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setFreezeFieldText(String freezeFieldText) {
        setAttribute("freezeFieldText", freezeFieldText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze a currently unfrozen field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Freeze " + the field's summary title.
     *
     * @return Current freezeFieldText value. Default value is "Freeze ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getFreezeFieldText()  {
        return getAttributeAsString("freezeFieldText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze fields on the left of the scrollable body.
     *
     * @param freezeOnLeftText New freezeOnLeftText value. Default value is "Freeze on left"
     */
    public void setFreezeOnLeftText(String freezeOnLeftText) {
        setAttribute("freezeOnLeftText", freezeOnLeftText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze fields on the left of the scrollable body.
     *
     * @return Current freezeOnLeftText value. Default value is "Freeze on left"
     */
    public String getFreezeOnLeftText()  {
        return getAttributeAsString("freezeOnLeftText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze fields on the right of the scrollable body.
     *
     * @param freezeOnRightText New freezeOnRightText value. Default value is "Freeze on right"
     */
    public void setFreezeOnRightText(String freezeOnRightText) {
        setAttribute("freezeOnRightText", freezeOnRightText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to freeze fields on the right of the scrollable body.
     *
     * @return Current freezeOnRightText value. Default value is "Freeze on right"
     */
    public String getFreezeOnRightText()  {
        return getAttributeAsString("freezeOnRightText");
    }
    

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom baseStyle to all cells in those
     * frozen fields. If unset, the standard base style will be used for both frozen and unfrozen cells.
     *
     * @param frozenBaseStyle New frozenBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#setFrozen
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public void setFrozenBaseStyle(String frozenBaseStyle) {
        setAttribute("frozenBaseStyle", frozenBaseStyle, true);
    }

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom baseStyle to all cells in those
     * frozen fields. If unset, the standard base style will be used for both frozen and unfrozen cells.
     *
     * @return Current frozenBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#getFrozen
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public String getFrozenBaseStyle()  {
        return getAttributeAsString("frozenBaseStyle");
    }
    

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom headerBaseStyle to the frozen
     * set of fields. If unset, the standard headerBaseStyle will be used for both frozen and unfrozen cells.
     *
     * @param frozenHeaderBaseStyle New frozenHeaderBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#setFrozen
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public void setFrozenHeaderBaseStyle(String frozenHeaderBaseStyle)  throws IllegalStateException {
        setAttribute("frozenHeaderBaseStyle", frozenHeaderBaseStyle, false);
    }

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom headerBaseStyle to the frozen
     * set of fields. If unset, the standard headerBaseStyle will be used for both frozen and unfrozen cells.
     *
     * @return Current frozenHeaderBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderBaseStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#getFrozen
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public String getFrozenHeaderBaseStyle()  {
        return getAttributeAsString("frozenHeaderBaseStyle");
    }
    

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom headerTitleStyle to the frozen
     * set of fields. If unset, the standard headerTitleStyle will be used for both frozen and unfrozen cells.
     *
     * @param frozenHeaderTitleStyle New frozenHeaderTitleStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderTitleStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#setFrozen
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public void setFrozenHeaderTitleStyle(String frozenHeaderTitleStyle)  throws IllegalStateException {
        setAttribute("frozenHeaderTitleStyle", frozenHeaderTitleStyle, false);
    }

    /**
     * If this listGrid contains any frozen fields, this property can be used to apply a custom headerTitleStyle to the frozen
     * set of fields. If unset, the standard headerTitleStyle will be used for both frozen and unfrozen cells.
     *
     * @return Current frozenHeaderTitleStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleStyle
     * @see com.smartgwt.client.widgets.grid.ListGridField#getFrozen
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public String getFrozenHeaderTitleStyle()  {
        return getAttributeAsString("frozenHeaderTitleStyle");
    }
    
    
    

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a click event.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param generateClickOnEnter New generateClickOnEnter value. Default value is false
     */
    public void setGenerateClickOnEnter(Boolean generateClickOnEnter) {
        setAttribute("generateClickOnEnter", generateClickOnEnter, true);
    }

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a click event.
     *
     * @return Current generateClickOnEnter value. Default value is false
     */
    public Boolean getGenerateClickOnEnter()  {
        Boolean result = getAttributeAsBoolean("generateClickOnEnter");
        return result == null ? false : result;
    }
    

    /**
     * If true, when the user navigates to a cell using arrow keys and hits space, the cell will respond to a click event.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param generateClickOnSpace New generateClickOnSpace value. Default value is true
     */
    public void setGenerateClickOnSpace(Boolean generateClickOnSpace) {
        setAttribute("generateClickOnSpace", generateClickOnSpace, true);
    }

    /**
     * If true, when the user navigates to a cell using arrow keys and hits space, the cell will respond to a click event.
     *
     * @return Current generateClickOnSpace value. Default value is true
     */
    public Boolean getGenerateClickOnSpace()  {
        Boolean result = getAttributeAsBoolean("generateClickOnSpace");
        return result == null ? true : result;
    }
    

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a double click
     * event.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param generateDoubleClickOnEnter New generateDoubleClickOnEnter value. Default value is true
     */
    public void setGenerateDoubleClickOnEnter(Boolean generateDoubleClickOnEnter) {
        setAttribute("generateDoubleClickOnEnter", generateDoubleClickOnEnter, true);
    }

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a double click
     * event.
     *
     * @return Current generateDoubleClickOnEnter value. Default value is true
     */
    public Boolean getGenerateDoubleClickOnEnter()  {
        Boolean result = getAttributeAsBoolean("generateDoubleClickOnEnter");
        return result == null ? true : result;
    }
    

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Space, the cell will respond to a double click
     * event.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param generateDoubleClickOnSpace New generateDoubleClickOnSpace value. Default value is false
     */
    public void setGenerateDoubleClickOnSpace(Boolean generateDoubleClickOnSpace) {
        setAttribute("generateDoubleClickOnSpace", generateDoubleClickOnSpace, true);
    }

    /**
     * If true, when the user navigates to a cell using arrow keys and hits Space, the cell will respond to a double click
     * event.
     *
     * @return Current generateDoubleClickOnSpace value. Default value is false
     */
    public Boolean getGenerateDoubleClickOnSpace()  {
        Boolean result = getAttributeAsBoolean("generateDoubleClickOnSpace");
        return result == null ? false : result;
    }
    

    /**
     * Array of components that make up this grid. This array controls which standard and/or custom
     *  parts will be displayed within this ListGrid.
     *  <P>
     * ListGrid is a subclass of {@link com.smartgwt.client.widgets.layout.VLayout} and consists of a number of member
     * components. The
     *  standard set of members are automatically generated by the grid, and include (for example)
     *  the header (a Toolbar of buttons for each field) and the body
     *  (a GridRenderer displaying the actual data contained in the grid).<br>
     * The default value of <code>gridComponents</code> is an Array of {@link com.smartgwt.client.types.ListGridComponent}s
     * listing
     *  the standard components in their default order:
     *  
     *  
     *  <pre>
     *     [ListGridComponent.FILTER_EDITOR, ListGridComponent.HEADER, ListGridComponent.BODY,
     *      ListGridComponent.SUMMARY_ROW]
     *  </pre>
     *  
     * 
     *  You can override <code>gridComponents</code> to change the order of standard components.
     *  You can also omit standard components this way, although it more efficient to
     * use the related "show" property if available (eg {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor
     * showFilterEditor}). Note that
     *  this array must contain an entry for the <code>"body"</code> - listGrids with no body showing
     *  are unsupported.<br>
     *  <i>Advanced note:</i> The live components generated for each of these standard
     *  {@link com.smartgwt.client.types.ListGridComponent} types may differ across different listGrids. For example if this
     * grid has any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, the "body" entry will
     * actually
     *  be created as an HLayout containing two GridRenderers (one for frozen fields,
     *  and one for unfrozen fields). This is really an implementation detail - the "body" entry
     *  in the gridComponents array simply specifies where the UI for the body should render within
     *  the ListGrid layout.
     *  <P>
     *  By embedding a Canvas directly in this list you can add arbitrary additional components to the
     *  listGrid as members, and have them be displayed alongside the standard automatically generated
     *  parts of the ListGrid.
     *  <P>
     *  Note that having added controls to gridComponents, you can still call APIs directly on
     *  those controls to change their appearance, and you can also show() and hide() them if
     *  they should not be shown in some circumstances.
     *  <P>
     *  Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
     *
     * @param gridComponents New gridComponents value. Default value is (see below)
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setGridComponents(ListGridComponent... gridComponents)  throws IllegalStateException {
        setAttribute("gridComponents", gridComponents, false);
    }

    /**
     * Array of components that make up this grid. This array controls which standard and/or custom
     *  parts will be displayed within this ListGrid.
     *  <P>
     * ListGrid is a subclass of {@link com.smartgwt.client.widgets.layout.VLayout} and consists of a number of member
     * components. The
     *  standard set of members are automatically generated by the grid, and include (for example)
     *  the header (a Toolbar of buttons for each field) and the body
     *  (a GridRenderer displaying the actual data contained in the grid).<br>
     * The default value of <code>gridComponents</code> is an Array of {@link com.smartgwt.client.types.ListGridComponent}s
     * listing
     *  the standard components in their default order:
     *  
     *  
     *  <pre>
     *     [ListGridComponent.FILTER_EDITOR, ListGridComponent.HEADER, ListGridComponent.BODY,
     *      ListGridComponent.SUMMARY_ROW]
     *  </pre>
     *  
     * 
     *  You can override <code>gridComponents</code> to change the order of standard components.
     *  You can also omit standard components this way, although it more efficient to
     * use the related "show" property if available (eg {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor
     * showFilterEditor}). Note that
     *  this array must contain an entry for the <code>"body"</code> - listGrids with no body showing
     *  are unsupported.<br>
     *  <i>Advanced note:</i> The live components generated for each of these standard
     *  {@link com.smartgwt.client.types.ListGridComponent} types may differ across different listGrids. For example if this
     * grid has any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, the "body" entry will
     * actually
     *  be created as an HLayout containing two GridRenderers (one for frozen fields,
     *  and one for unfrozen fields). This is really an implementation detail - the "body" entry
     *  in the gridComponents array simply specifies where the UI for the body should render within
     *  the ListGrid layout.
     *  <P>
     *  By embedding a Canvas directly in this list you can add arbitrary additional components to the
     *  listGrid as members, and have them be displayed alongside the standard automatically generated
     *  parts of the ListGrid.
     *  <P>
     *  Note that having added controls to gridComponents, you can still call APIs directly on
     *  those controls to change their appearance, and you can also show() and hide() them if
     *  they should not be shown in some circumstances.
     *  <P>
     *  Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
     *
     * @return Current gridComponents value. Default value is (see below)
     */
    public ListGridComponent[] getGridComponents()  {
        final String[] strings = getAttributeAsStringArray("gridComponents");
        return EnumUtil.getEnums(ListGridComponent.values(), strings, strings == null ? null : new ListGridComponent[strings.length]);
    }

    /**
     * Array of components that make up this grid. This array controls which standard and/or custom
     *  parts will be displayed within this ListGrid.
     *  <P>
     * ListGrid is a subclass of {@link com.smartgwt.client.widgets.layout.VLayout} and consists of a number of member
     * components. The
     *  standard set of members are automatically generated by the grid, and include (for example)
     *  the header (a Toolbar of buttons for each field) and the body
     *  (a GridRenderer displaying the actual data contained in the grid).<br>
     * The default value of <code>gridComponents</code> is an Array of {@link com.smartgwt.client.types.ListGridComponent}s
     * listing
     *  the standard components in their default order:
     *  
     *  
     *  <pre>
     *     [ListGridComponent.FILTER_EDITOR, ListGridComponent.HEADER, ListGridComponent.BODY,
     *      ListGridComponent.SUMMARY_ROW]
     *  </pre>
     *  
     * 
     *  You can override <code>gridComponents</code> to change the order of standard components.
     *  You can also omit standard components this way, although it more efficient to
     * use the related "show" property if available (eg {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor
     * showFilterEditor}). Note that
     *  this array must contain an entry for the <code>"body"</code> - listGrids with no body showing
     *  are unsupported.<br>
     *  <i>Advanced note:</i> The live components generated for each of these standard
     *  {@link com.smartgwt.client.types.ListGridComponent} types may differ across different listGrids. For example if this
     * grid has any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, the "body" entry will
     * actually
     *  be created as an HLayout containing two GridRenderers (one for frozen fields,
     *  and one for unfrozen fields). This is really an implementation detail - the "body" entry
     *  in the gridComponents array simply specifies where the UI for the body should render within
     *  the ListGrid layout.
     *  <P>
     *  By embedding a Canvas directly in this list you can add arbitrary additional components to the
     *  listGrid as members, and have them be displayed alongside the standard automatically generated
     *  parts of the ListGrid.
     *  <P>
     *  Note that having added controls to gridComponents, you can still call APIs directly on
     *  those controls to change their appearance, and you can also show() and hide() them if
     *  they should not be shown in some circumstances.
     *  <P>
     *  Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
     *
     * @param gridComponents New gridComponents value. Default value is (see below)
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setGridComponents(Object... gridComponents)  throws IllegalStateException {
        setAttribute("gridComponents", gridComponents, false);
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, this attribute will be
     * set to true on the record object representing the grid summary row.
     *
     * @param gridSummaryRecordProperty New gridSummaryRecordProperty value. Default value is "isGridSummary"
     */
    public void setGridSummaryRecordProperty(String gridSummaryRecordProperty) {
        setAttribute("gridSummaryRecordProperty", gridSummaryRecordProperty, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, this attribute will be
     * set to true on the record object representing the grid summary row.
     *
     * @return Current gridSummaryRecordProperty value. Default value is "isGridSummary"
     */
    public String getGridSummaryRecordProperty()  {
        return getAttributeAsString("gridSummaryRecordProperty");
    }
    

    /**
     * When grouping is requested with this number of records or more, an asynchronous approach is used to avoid the browser
     * showing a "script is running slowly.." message prompting the user to stop execution of JavaScript. <p> Note that {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByMaxRecords groupByMaxRecords} must be set at least as high as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold groupByAsyncThreshold} or asynchronous grouping will
     * never be used. <p> During async grouping, interactivity is blocked and the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAsynchGroupingPrompt asynchGroupingPrompt} is shown to the user, then
     * hidden when grouping completes; {@link com.smartgwt.client.widgets.grid.ListGrid#addGroupByCompleteHandler
     * ListGrid.groupByComplete()} then fires. <p> Note that this async processing covers grouping <b>only</b> - it does not
     * cover whole grid or per-group summaries, client-side sort or filter, or other operations that may cause the browser to
     * show the "script is running slowly" prompt when working with very large sets of records in a grid. <p> At this time,
     * there is no generally effective way to avoid this warning dialog appearing with very large datasets in Microsoft's
     * Internet Explorer (IE).  IE's severely flawed detection algorithm for runaway scripts has been shown to interrupt
     * computations after only 0.2 seconds elapsed time even if the computation would have finished in 0.3 seconds. 
     * Optimizations that reduce execution time can sometimes trigger the "script running slowly" dialog sooner.  Since not
     * every operation can reasonably be made asynchronous, the current recommendation is to avoid working with overly large
     * datasets until the affected versions of IE are obsoleted.
     *
     * @param groupByAsyncThreshold New groupByAsyncThreshold value. Default value is 50
     */
    public void setGroupByAsyncThreshold(int groupByAsyncThreshold) {
        setAttribute("groupByAsyncThreshold", groupByAsyncThreshold, true);
    }

    /**
     * When grouping is requested with this number of records or more, an asynchronous approach is used to avoid the browser
     * showing a "script is running slowly.." message prompting the user to stop execution of JavaScript. <p> Note that {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByMaxRecords groupByMaxRecords} must be set at least as high as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold groupByAsyncThreshold} or asynchronous grouping will
     * never be used. <p> During async grouping, interactivity is blocked and the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAsynchGroupingPrompt asynchGroupingPrompt} is shown to the user, then
     * hidden when grouping completes; {@link com.smartgwt.client.widgets.grid.ListGrid#addGroupByCompleteHandler
     * ListGrid.groupByComplete()} then fires. <p> Note that this async processing covers grouping <b>only</b> - it does not
     * cover whole grid or per-group summaries, client-side sort or filter, or other operations that may cause the browser to
     * show the "script is running slowly" prompt when working with very large sets of records in a grid. <p> At this time,
     * there is no generally effective way to avoid this warning dialog appearing with very large datasets in Microsoft's
     * Internet Explorer (IE).  IE's severely flawed detection algorithm for runaway scripts has been shown to interrupt
     * computations after only 0.2 seconds elapsed time even if the computation would have finished in 0.3 seconds. 
     * Optimizations that reduce execution time can sometimes trigger the "script running slowly" dialog sooner.  Since not
     * every operation can reasonably be made asynchronous, the current recommendation is to avoid working with overly large
     * datasets until the affected versions of IE are obsoleted.
     *
     * @return Current groupByAsyncThreshold value. Default value is 50
     */
    public int getGroupByAsyncThreshold()  {
        return getAttributeAsInt("groupByAsyncThreshold");
    }
    

    /**
     * List of fields to group grid records. If only a single field is used, that field may be specified as a string. After
     * initialization, use {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()} to update the grouping field
     * list, instead of modifying groupByField directly.
     *
     * @param groupByField New groupByField value. Default value is see below
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_grouping_dynamic" target="examples">Dynamic Grouping Example</a>
     */
    public void setGroupByField(String groupByField)  throws IllegalStateException {
        setAttribute("groupByField", groupByField, false);
    }

    /**
     * List of fields to group grid records. If only a single field is used, that field may be specified as a string. After
     * initialization, use {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()} to update the grouping field
     * list, instead of modifying groupByField directly.
     *
     * @param groupByField New groupByField value. Default value is see below
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_grouping_dynamic" target="examples">Dynamic Grouping Example</a>
     */
    public void setGroupByField(String... groupByField)  throws IllegalStateException {
        setAttribute("groupByField", groupByField, false);
    }
    

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this attribute may be set to an
     * array of groupBy field names for which group summaries should appear. <P> This is particularly useful for listGrids
     * grouped by more than one field as it allows developers to display the group summary for a particular nested group
     * without showing a summary for every level of the tree.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByFieldSummaries groupByFieldSummaries} attribute
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param groupByFieldSummaries new value for this.groupByFieldSummaries. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowGroupSummary
     */
    public void setGroupByFieldSummaries(String... groupByFieldSummaries) {
        setAttribute("groupByFieldSummaries", groupByFieldSummaries, true);
    }

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this attribute may be set to an
     * array of groupBy field names for which group summaries should appear. <P> This is particularly useful for listGrids
     * grouped by more than one field as it allows developers to display the group summary for a particular nested group
     * without showing a summary for every level of the tree.
     *
     * @return Current groupByFieldSummaries value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary
     */
    public String[] getGroupByFieldSummaries()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfString(getAttributeAsJavaScriptObject("groupByFieldSummaries"));
    }
    

    /**
     * Maximum number of records to which a groupBy can be applied. If there are more records, grouping will not be available
     * via the default header context menu, and calls to {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()}
     * will be ignored. <P> The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of all
     * records that match the current filter criteria before records can be grouped.  The default maximum represents a number
     * of records which are safe to load in legacy browsers such as Internet Explorer 8 (modern browsers can handle far more),
     * and is also a good upper limit from the perspective of loading data from a database. <P> Going beyond this limit can
     * cause "script running slowly" errors from legacy browsers (as well as high database load).  To build an interface for
     * grouping that handles arbitrary data volume, use a TreeGrid with {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getLoadDataOnDemand TreeGrid.loadDataOnDemand} with server-side grouping code.
     *
     * @param groupByMaxRecords New groupByMaxRecords value. Default value is 1000
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setGroupByMaxRecords(int groupByMaxRecords) {
        setAttribute("groupByMaxRecords", groupByMaxRecords, true);
    }

    /**
     * Maximum number of records to which a groupBy can be applied. If there are more records, grouping will not be available
     * via the default header context menu, and calls to {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()}
     * will be ignored. <P> The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of all
     * records that match the current filter criteria before records can be grouped.  The default maximum represents a number
     * of records which are safe to load in legacy browsers such as Internet Explorer 8 (modern browsers can handle far more),
     * and is also a good upper limit from the perspective of loading data from a database. <P> Going beyond this limit can
     * cause "script running slowly" errors from legacy browsers (as well as high database load).  To build an interface for
     * grouping that handles arbitrary data volume, use a TreeGrid with {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getLoadDataOnDemand TreeGrid.loadDataOnDemand} with server-side grouping code.
     *
     * @return Current groupByMaxRecords value. Default value is 1000
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public int getGroupByMaxRecords()  {
        return getAttributeAsInt("groupByMaxRecords");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy this.canGroupBy} is true, this string will be
     * shown as the title for the menu item to toggle the group by setting for a field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Group by " + the field's summary title.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param groupByText New groupByText value. Default value is "Group by ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setGroupByText(String groupByText) {
        setAttribute("groupByText", groupByText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy this.canGroupBy} is true, this string will be
     * shown as the title for the menu item to toggle the group by setting for a field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Group by " + the field's summary title.
     *
     * @return If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy this.canGroupBy} is true, this string will be
     * shown as the title for the menu item to toggle the group by setting for a field.<br> Default implementation evaluates
     * and returns the dynamic {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByText groupByText} string. Default value is "Group by ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getGroupByText()  {
        return getAttributeAsString("groupByText");
    }
    

    /**
     * The URL of the base icon for the group icons in this listGrid. Default value may  be overridden by the {@link
     * com.smartgwt.client.docs.Skinning current skin}.
     *
     * @param groupIcon New groupIcon value. Default value is "[SKINIMG]/TreeGrid/opener.gif"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setGroupIcon(String groupIcon) {
        setAttribute("groupIcon", groupIcon, true);
    }

    /**
     * The URL of the base icon for the group icons in this listGrid. Default value may  be overridden by the {@link
     * com.smartgwt.client.docs.Skinning current skin}.
     *
     * @return Current groupIcon value. Default value is "[SKINIMG]/TreeGrid/opener.gif"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getGroupIcon()  {
        return getAttributeAsString("groupIcon");
    }
    

    /**
     * Default width and height of group icons for this ListGrid.
     *
     * @param groupIconSize New groupIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setGroupIconSize(int groupIconSize) {
        setAttribute("groupIconSize", groupIconSize, true);
    }

    /**
     * Default width and height of group icons for this ListGrid.
     *
     * @return Current groupIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public int getGroupIconSize()  {
        return getAttributeAsInt("groupIconSize");
    }
    

    /**
     * Default number of pixels by which to indent subgroups relative to parent group.
     *
     * @param groupIndentSize New groupIndentSize value. Default value is 20
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeHTML
     */
    public void setGroupIndentSize(int groupIndentSize) {
        setAttribute("groupIndentSize", groupIndentSize, true);
    }

    /**
     * Default number of pixels by which to indent subgroups relative to parent group.
     *
     * @return Current groupIndentSize value. Default value is 20
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeHTML
     */
    public int getGroupIndentSize()  {
        return getAttributeAsInt("groupIndentSize");
    }
    

    /**
     * Default number of pixels by which to indent all groups.
     *
     * @param groupLeadingIndent New groupLeadingIndent value. Default value is 10
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeHTML
     */
    public void setGroupLeadingIndent(int groupLeadingIndent) {
        setAttribute("groupLeadingIndent", groupLeadingIndent, true);
    }

    /**
     * Default number of pixels by which to indent all groups.
     *
     * @return Current groupLeadingIndent value. Default value is 10
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeHTML
     */
    public int getGroupLeadingIndent()  {
        return getAttributeAsInt("groupLeadingIndent");
    }
    

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle Base style} for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy group} rows. <P> Note that this property has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeStyle groupNodeStyle} is non null.
     *
     * @param groupNodeBaseStyle New groupNodeBaseStyle value. Default value is null
     */
    public void setGroupNodeBaseStyle(String groupNodeBaseStyle) {
        setAttribute("groupNodeBaseStyle", groupNodeBaseStyle, true);
    }

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle Base style} for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy group} rows. <P> Note that this property has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeStyle groupNodeStyle} is non null.
     *
     * @return Current groupNodeBaseStyle value. Default value is null
     */
    public String getGroupNodeBaseStyle()  {
        return getAttributeAsString("groupNodeBaseStyle");
    }
    

    /**
     * The CSS style that {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy group} rows will have. <P> Note that this is
     * not a {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle base style}, so, if this property is set, group
     * nodes will not show stateful styling (different styles for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles alternateRecordStyles}, etc). To enable stateful
     * styling for groupNodes, set this property to <code>null</code> and specify a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeBaseStyle groupNodeBaseStyle}
     *
     * @param groupNodeStyle New groupNodeStyle value. Default value is "groupNode"
     */
    public void setGroupNodeStyle(String groupNodeStyle) {
        setAttribute("groupNodeStyle", groupNodeStyle, true);
    }

    /**
     * The CSS style that {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy group} rows will have. <P> Note that this is
     * not a {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle base style}, so, if this property is set, group
     * nodes will not show stateful styling (different styles for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles alternateRecordStyles}, etc). To enable stateful
     * styling for groupNodes, set this property to <code>null</code> and specify a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupNodeBaseStyle groupNodeBaseStyle}
     *
     * @return Current groupNodeStyle value. Default value is "groupNode"
     */
    public String getGroupNodeStyle()  {
        return getAttributeAsString("groupNodeStyle");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst sortByGroupFirst} is active, the sorting
     * direction applied for implicit  sorting by the field(s) used for grouping. Default of null means that sort direction  is
     * based on the current direction of user-configured sort, or is "ascending" if the  user has not sorted the data.
     *
     * @param groupSortDirection New groupSortDirection value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortByGroupFirst
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupSortNormalizer
     */
    public void setGroupSortDirection(SortDirection groupSortDirection) {
        setAttribute("groupSortDirection", groupSortDirection == null ? null : groupSortDirection.getValue(), true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst sortByGroupFirst} is active, the sorting
     * direction applied for implicit  sorting by the field(s) used for grouping. Default of null means that sort direction  is
     * based on the current direction of user-configured sort, or is "ascending" if the  user has not sorted the data.
     *
     * @return Current groupSortDirection value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupSortNormalizer
     */
    public SortDirection getGroupSortDirection()  {
        return EnumUtil.getEnum(SortDirection.values(), getAttribute("groupSortDirection"));
    }
    
    

    /**
     * Initial group state for the grid. <P> {@link com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be
     * used to initialize all view properties of the grid. When doing so, <code>groupState</code> is not needed because
     * <code>viewState</code> includes it as well. If both are provided, <code>groupState</code> has priority for group state.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Reset this grid's grouping to match the {@link com.smartgwt.client.docs.ListGridGroupState} object passed in.<br> Used to restore previous state retrieved from the grid by a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupState getGroupState()}.
     *
     * @param groupState Object describing the desired grouping state of                                              the grid. Default value is null
     * @see com.smartgwt.client.docs.ListGridGroupState ListGridGroupState 
     */
    public void setGroupState(String groupState) {
        setAttribute("groupState", groupState, true);
    }

    /**
     * Initial group state for the grid. <P> {@link com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be
     * used to initialize all view properties of the grid. When doing so, <code>groupState</code> is not needed because
     * <code>viewState</code> includes it as well. If both are provided, <code>groupState</code> has priority for group state.
     *
     * @return Returns a snapshot of the current grouping state of this ListGrid.<br> This object can be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setGroupState setGroupState()} to reset this grid's grouping to the current
     * state (assuming the same data / fields are present in the grid).<br>. Default value is null
     * @see com.smartgwt.client.docs.ListGridGroupState ListGridGroupState 
     */
    public String getGroupState()  {
        return getAttributeAsString("groupState");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this attribute will
     * be set to true on each record object representing a group-level summary row.
     *
     * @param groupSummaryRecordProperty New groupSummaryRecordProperty value. Default value is "isGroupSummary"
     */
    public void setGroupSummaryRecordProperty(String groupSummaryRecordProperty) {
        setAttribute("groupSummaryRecordProperty", groupSummaryRecordProperty, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this attribute will
     * be set to true on each record object representing a group-level summary row.
     *
     * @return Current groupSummaryRecordProperty value. Default value is "isGroupSummary"
     */
    public String getGroupSummaryRecordProperty()  {
        return getAttributeAsString("groupSummaryRecordProperty");
    }
    

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGridRecord#getCustomStyle ListGridRecord.customStyle} for the group-level
     * summary row displayed when {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is
     * true.
     *
     * @param groupSummaryStyle New groupSummaryStyle value. Default value is "gridSummaryCell"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setGroupSummaryStyle(String groupSummaryStyle)  throws IllegalStateException {
        setAttribute("groupSummaryStyle", groupSummaryStyle, false);
    }

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGridRecord#getCustomStyle ListGridRecord.customStyle} for the group-level
     * summary row displayed when {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is
     * true.
     *
     * @return Current groupSummaryStyle value. Default value is "gridSummaryCell"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getGroupSummaryStyle()  {
        return getAttributeAsString("groupSummaryStyle");
    }
    
    

    /**
     * Custom properties for the automatically generated <code>groupTitleColumn</code>. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn showGroupTitleColumn} for an overview of the
     * groupTitleColumn.
     *
     * @param groupTitleColumnProperties New groupTitleColumnProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setGroupTitleColumnProperties(ListGridField groupTitleColumnProperties)  throws IllegalStateException {
        JavaScriptObject config = JSOHelper.createObject();
        if (groupTitleColumnProperties != null) {
            JSOHelper.addProperties(config, groupTitleColumnProperties.getJsObj());
        }
        setAttribute("groupTitleColumnProperties", groupTitleColumnProperties == null ? null : config, false);
    }

    /**
     * Custom properties for the automatically generated <code>groupTitleColumn</code>. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn showGroupTitleColumn} for an overview of the
     * groupTitleColumn.
     *
     * @return Current groupTitleColumnProperties value. Default value is null
     */
    public ListGridField getGroupTitleColumnProperties()  {
        return ListGridField.getOrCreateRef(getAttributeAsJavaScriptObject("groupTitleColumnProperties"));
    }
    

    /**
     * When a list grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped}, each group shows under an auto
     * generated header node. By default the title of the group will be shown, with a hanging indent in this node, and will
     * span all columns in the grid. Setting this property causes the titles of auto-generated group nodes to appear as though
     * they were values of the designated field instead of spanning all columns and record values in the designated
     * groupTitleField will appear indented under the group title in a manner similar to how a TreeGrid shows a Tree. <P> Note
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, the
     * header nodes will not show a single spanning title value by default - instead they will show the summary values for each
     * field. In this case, if groupTitleField is unset, a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn groupTitleColumn} can be automatically generated to
     * show the title for each group.
     *
     * @param groupTitleField New groupTitleField value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setGroupTitleField(String groupTitleField)  throws IllegalStateException {
        setAttribute("groupTitleField", groupTitleField, false);
    }

    /**
     * When a list grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped}, each group shows under an auto
     * generated header node. By default the title of the group will be shown, with a hanging indent in this node, and will
     * span all columns in the grid. Setting this property causes the titles of auto-generated group nodes to appear as though
     * they were values of the designated field instead of spanning all columns and record values in the designated
     * groupTitleField will appear indented under the group title in a manner similar to how a TreeGrid shows a Tree. <P> Note
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, the
     * header nodes will not show a single spanning title value by default - instead they will show the summary values for each
     * field. In this case, if groupTitleField is unset, a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn groupTitleColumn} can be automatically generated to
     * show the title for each group.
     *
     * @return Current groupTitleField value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public String getGroupTitleField()  {
        return getAttributeAsString("groupTitleField");
    }
    

    /**
     * The data tree that results from a call to  {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()}. This
     * will be a {@link com.smartgwt.client.widgets.tree.ResultTree} if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource} is present, otherwise it will be a {@link
     * com.smartgwt.client.widgets.tree.Tree}.
     * <p>
     * This component is an AutoChild named "groupTree".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current groupTree value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public Tree getGroupTree()  {
        return Tree.getOrCreateRef(getAttributeAsJavaScriptObject("groupTree"));
    }
    

    /**
     * A Toolbar used to manager the headers shown for each column of the grid.
     * <p>
     * This component is an AutoChild named "header".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current header value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public Layout getHeader() throws IllegalStateException {
        errorIfNotCreated("header");
        return (Layout)Layout.getByJSObject(getAttributeAsJavaScriptObject("header"));
    }
    

    /**
     * Event on a ListGrid header that triggers auto fitting to data and/or title. <P> Note that if sorting is enabled for the
     * field and the headerAutoFitEvent is "click", both sorting and autofit occur on a click. <P> Only has an impact when
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} or  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} is set to
     * <code>true</code>.
     *
     * @param headerAutoFitEvent New headerAutoFitEvent value. Default value is "doubleClick"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderAutoFitEvent(AutoFitEvent headerAutoFitEvent)  throws IllegalStateException {
        setAttribute("headerAutoFitEvent", headerAutoFitEvent == null ? null : headerAutoFitEvent.getValue(), false);
    }

    /**
     * Event on a ListGrid header that triggers auto fitting to data and/or title. <P> Note that if sorting is enabled for the
     * field and the headerAutoFitEvent is "click", both sorting and autofit occur on a click. <P> Only has an impact when
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields canAutoFitFields} or  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} is set to
     * <code>true</code>.
     *
     * @return Current headerAutoFitEvent value. Default value is "doubleClick"
     */
    public AutoFitEvent getHeaderAutoFitEvent()  {
        return EnumUtil.getEnum(AutoFitEvent.values(), getAttribute("headerAutoFitEvent"));
    }
    

    /**
     * BackgroundColor for the header toolbar. Typically this is set to match the color of the header buttons.
     *
     * @param headerBackgroundColor New headerBackgroundColor value. Default value is "#CCCCCC"
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setHeaderBackgroundColor(String headerBackgroundColor) {
        setAttribute("headerBackgroundColor", headerBackgroundColor, true);
    }

    /**
     * BackgroundColor for the header toolbar. Typically this is set to match the color of the header buttons.
     *
     * @return Current headerBackgroundColor value. Default value is "#CCCCCC"
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getHeaderBackgroundColor()  {
        return getAttributeAsString("headerBackgroundColor");
    }
    

    /**
     * Set the CSS style used for the header as a whole.
     *
     * @param headerBarStyle New headerBarStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setHeaderBarStyle(String headerBarStyle)  throws IllegalStateException {
        setAttribute("headerBarStyle", headerBarStyle, false);
    }

    /**
     * Set the CSS style used for the header as a whole.
     *
     * @return Current headerBarStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getHeaderBarStyle()  {
        return getAttributeAsString("headerBarStyle");
    }
    

    /**
     * {@link com.smartgwt.client.widgets.Button#getBaseStyle Button.baseStyle} to apply to the buttons in the header, and the
     * sorter, for this ListGrid. Note that, depending on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor Class} of the header buttons, you may also need to
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleStyle headerTitleStyle}.
     *
     * @param headerBaseStyle New headerBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setClipHeaderTitles
     * @see com.smartgwt.client.widgets.grid.ListGrid#setWrapHeaderTitles
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setHeaderBaseStyle(String headerBaseStyle)  throws IllegalStateException {
        setAttribute("headerBaseStyle", headerBaseStyle, false);
    }

    /**
     * {@link com.smartgwt.client.widgets.Button#getBaseStyle Button.baseStyle} to apply to the buttons in the header, and the
     * sorter, for this ListGrid. Note that, depending on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor Class} of the header buttons, you may also need to
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleStyle headerTitleStyle}.
     *
     * @return Current headerBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles
     * @see com.smartgwt.client.widgets.grid.ListGrid#getWrapHeaderTitles
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getHeaderBaseStyle()  {
        return getAttributeAsString("headerBaseStyle");
    }
    
    
    

    /**
     * Properties to apply to all header buttons. Overrides defaults applied via  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonDefaults headerButtonDefaults}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerButtonProperties New headerButtonProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setHeaderButtonProperties(Button headerButtonProperties)  throws IllegalStateException {
        if (headerButtonProperties != null) {
            if (headerButtonProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, "setHeaderButtonProperties", "Button");
            }                                                                       
            headerButtonProperties.setConfigOnly(true);
        }
        JavaScriptObject config = headerButtonProperties == null ? null : headerButtonProperties.getConfig();
        setAttribute("headerButtonProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Properties to apply to all header buttons. Overrides defaults applied via  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonDefaults headerButtonDefaults}.
     *
     * @return Current headerButtonProperties value. Default value is null
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public Button getHeaderButtonProperties()  {
        Button properties = new Button();
        properties.setConfigOnly(true);
        properties.setConfig(getAttributeAsJavaScriptObject("headerButtonProperties"));
        return properties;
    }
    

    /**
     * The context menu displayed for column headers.
     * <p>
     * This component is an AutoChild named "headerContextMenu".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current headerContextMenu value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public Canvas getHeaderContextMenu() throws IllegalStateException {
        errorIfNotCreated("headerContextMenu");
        return (Canvas)Canvas.getByJSObject(getAttributeAsJavaScriptObject("headerContextMenu"));
    }
    

    /**
     * The height of this listGrid's header, in pixels.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Modify the height of a listGrid. To hide the header set height to zero.
     *
     * @param headerHeight new height for the header. Default value is 22
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     */
    public void setHeaderHeight(int headerHeight) {
        setAttribute("headerHeight", headerHeight, true);
    }

    /**
     * The height of this listGrid's header, in pixels.
     *
     * @return Current headerHeight value. Default value is 22
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     */
    public int getHeaderHeight()  {
        return getAttributeAsInt("headerHeight");
    }
    

    /**
     * This property may be set to customize the alignment for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @param headerHoverAlign New headerHoverAlign value. Default value is null
     */
    public void setHeaderHoverAlign(Alignment headerHoverAlign) {
        setAttribute("headerHoverAlign", headerHoverAlign == null ? null : headerHoverAlign.getValue(), true);
    }

    /**
     * This property may be set to customize the alignment for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @return Current headerHoverAlign value. Default value is null
     */
    public Alignment getHeaderHoverAlign()  {
        return EnumUtil.getEnum(Alignment.values(), getAttribute("headerHoverAlign"));
    }
    

    /**
     * Optional default height for the hover shown on {@link com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler
     * ListGrid.headerHover()}.
     *
     * @param headerHoverHeight New headerHoverHeight value. Default value is null
     */
    public void setHeaderHoverHeight(Integer headerHoverHeight) {
        setAttribute("headerHoverHeight", headerHoverHeight, true);
    }

    /**
     * Optional default height for the hover shown on {@link com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler
     * ListGrid.headerHover()}.
     *
     * @return Current headerHoverHeight value. Default value is null
     */
    public Integer getHeaderHoverHeight()  {
        return getAttributeAsInt("headerHoverHeight");
    }
    

    /**
     * This property may be set to customize the opacity for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @param headerHoverOpacity New headerHoverOpacity value. Default value is null
     */
    public void setHeaderHoverOpacity(Integer headerHoverOpacity) {
        setAttribute("headerHoverOpacity", headerHoverOpacity, true);
    }

    /**
     * This property may be set to customize the opacity for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @return Current headerHoverOpacity value. Default value is null
     */
    public Integer getHeaderHoverOpacity()  {
        return getAttributeAsInt("headerHoverOpacity");
    }
    

    /**
     * This property may be set to customize the css style for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @param headerHoverStyle New headerHoverStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setHeaderHoverStyle(String headerHoverStyle) {
        setAttribute("headerHoverStyle", headerHoverStyle, true);
    }

    /**
     * This property may be set to customize the css style for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @return Current headerHoverStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getHeaderHoverStyle()  {
        return getAttributeAsString("headerHoverStyle");
    }
    

    /**
     * This property may be set to customize the vertical alignment for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @param headerHoverVAlign New headerHoverVAlign value. Default value is null
     */
    public void setHeaderHoverVAlign(VerticalAlignment headerHoverVAlign) {
        setAttribute("headerHoverVAlign", headerHoverVAlign == null ? null : headerHoverVAlign.getValue(), true);
    }

    /**
     * This property may be set to customize the vertical alignment for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @return Current headerHoverVAlign value. Default value is null
     */
    public VerticalAlignment getHeaderHoverVAlign()  {
        return EnumUtil.getEnum(VerticalAlignment.values(), getAttribute("headerHoverVAlign"));
    }
    

    /**
     * Optional default width for the hover shown on {@link com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler
     * ListGrid.headerHover()}.
     *
     * @param headerHoverWidth New headerHoverWidth value. Default value is null
     */
    public void setHeaderHoverWidth(Integer headerHoverWidth) {
        setAttribute("headerHoverWidth", headerHoverWidth, true);
    }

    /**
     * Optional default width for the hover shown on {@link com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler
     * ListGrid.headerHover()}.
     *
     * @return Current headerHoverWidth value. Default value is null
     */
    public Integer getHeaderHoverWidth()  {
        return getAttributeAsInt("headerHoverWidth");
    }
    

    /**
     * This property may be set to customize the <code>wrap</code> attribute for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @param headerHoverWrap New headerHoverWrap value. Default value is null
     */
    public void setHeaderHoverWrap(Boolean headerHoverWrap) {
        setAttribute("headerHoverWrap", headerHoverWrap, true);
    }

    /**
     * This property may be set to customize the <code>wrap</code> attribute for the hover shown on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler ListGrid.headerHover()}.
     *
     * @return Current headerHoverWrap value. Default value is null
     */
    public Boolean getHeaderHoverWrap()  {
        return getAttributeAsBoolean("headerHoverWrap");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, when the user
     * rolls over the header buttons in this grid the headerMenuButton will be shown over the header button in question. When
     * clicked this button will display the standard header context menu (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#displayHeaderContextMenu displayHeaderContextMenu()}). <P> {@link
     * com.smartgwt.client.docs.HeaderMenuButton Several properties} exist to customize the appearance of the headerMenuButton.
     * Also see the {@link com.smartgwt.client.types.AutoChild} documentation for information on how to make free-form
     * modifications to autoChild widgets
     * <p>
     * This component is an AutoChild named "headerMenuButton".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current headerMenuButton value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public StatefulCanvas getHeaderMenuButton() throws IllegalStateException {
        errorIfNotCreated("headerMenuButton");
        return (StatefulCanvas)StatefulCanvas.getByJSObject(getAttributeAsJavaScriptObject("headerMenuButton"));
    }
    
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the auto-generated <code>headerMenuButton</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerMenuButtonHeight New headerMenuButtonHeight value. Default value is "100%"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRotatedHeaderMenuButtonHeight
     */
    public void setHeaderMenuButtonHeight(int headerMenuButtonHeight)  throws IllegalStateException {
        setAttribute("headerMenuButtonHeight", headerMenuButtonHeight, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the auto-generated <code>headerMenuButton</code>
     *
     * @return Current headerMenuButtonHeight value. Default value is "100%"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRotatedHeaderMenuButtonHeight
     */
    public int getHeaderMenuButtonHeight()  {
        return getAttributeAsInt("headerMenuButtonHeight");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the icon shown on the auto-generated <code>headerMenuButton</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerMenuButtonIcon New headerMenuButtonIcon value. Default value is "[SKIN]/ListGrid/headerMenuButton_icon.gif"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.URL URL 
     */
    public void setHeaderMenuButtonIcon(String headerMenuButtonIcon)  throws IllegalStateException {
        setAttribute("headerMenuButtonIcon", headerMenuButtonIcon, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the icon shown on the auto-generated <code>headerMenuButton</code>
     *
     * @return Current headerMenuButtonIcon value. Default value is "[SKIN]/ListGrid/headerMenuButton_icon.gif"
     * @see com.smartgwt.client.docs.URL URL 
     */
    public String getHeaderMenuButtonIcon()  {
        return getAttributeAsString("headerMenuButtonIcon");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the icon shown on the auto-generated <code>headerMenuButton</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerMenuButtonIconHeight New headerMenuButtonIconHeight value. Default value is 7
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderMenuButtonIconHeight(int headerMenuButtonIconHeight)  throws IllegalStateException {
        setAttribute("headerMenuButtonIconHeight", headerMenuButtonIconHeight, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the icon shown on the auto-generated <code>headerMenuButton</code>
     *
     * @return Current headerMenuButtonIconHeight value. Default value is 7
     */
    public int getHeaderMenuButtonIconHeight()  {
        return getAttributeAsInt("headerMenuButtonIconHeight");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the icon shown on the auto-generated <code>headerMenuButton</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerMenuButtonIconWidth New headerMenuButtonIconWidth value. Default value is 7
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderMenuButtonIconWidth(int headerMenuButtonIconWidth)  throws IllegalStateException {
        setAttribute("headerMenuButtonIconWidth", headerMenuButtonIconWidth, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the icon shown on the auto-generated <code>headerMenuButton</code>
     *
     * @return Current headerMenuButtonIconWidth value. Default value is 7
     */
    public int getHeaderMenuButtonIconWidth()  {
        return getAttributeAsInt("headerMenuButtonIconWidth");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the auto-generated <code>headerMenuButton</code>
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerMenuButtonWidth New headerMenuButtonWidth value. Default value is 16
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRotatedHeaderMenuButtonWidth
     */
    public void setHeaderMenuButtonWidth(int headerMenuButtonWidth)  throws IllegalStateException {
        setAttribute("headerMenuButtonWidth", headerMenuButtonWidth, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the auto-generated <code>headerMenuButton</code>
     *
     * @return Current headerMenuButtonWidth value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRotatedHeaderMenuButtonWidth
     */
    public int getHeaderMenuButtonWidth()  {
        return getAttributeAsInt("headerMenuButtonWidth");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowColor Canvas.shadowColor} for the header shadow.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerShadowColor New headerShadowColor value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public void setHeaderShadowColor(String headerShadowColor)  throws IllegalStateException {
        setAttribute("headerShadowColor", headerShadowColor, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowColor Canvas.shadowColor} for the header shadow.
     *
     * @return Current headerShadowColor value. Default value is null
     * @see com.smartgwt.client.docs.CSSColor CSSColor 
     */
    public String getHeaderShadowColor()  {
        return getAttributeAsString("headerShadowColor");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowHOffset Canvas.shadowHOffset} for the header shadow
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerShadowHOffset New headerShadowHOffset value. Default value is 0
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderShadowHOffset(int headerShadowHOffset)  throws IllegalStateException {
        setAttribute("headerShadowHOffset", headerShadowHOffset, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowHOffset Canvas.shadowHOffset} for the header shadow
     *
     * @return Current headerShadowHOffset value. Default value is 0
     */
    public int getHeaderShadowHOffset()  {
        return getAttributeAsInt("headerShadowHOffset");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowSoftness Canvas.shadowSoftness} for the header shadow
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerShadowSoftness New headerShadowSoftness value. Default value is 1
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderShadowSoftness(int headerShadowSoftness)  throws IllegalStateException {
        setAttribute("headerShadowSoftness", headerShadowSoftness, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowSoftness Canvas.shadowSoftness} for the header shadow
     *
     * @return Current headerShadowSoftness value. Default value is 1
     */
    public int getHeaderShadowSoftness()  {
        return getAttributeAsInt("headerShadowSoftness");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowVOffset Canvas.shadowVOffset} for the header shadow
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param headerShadowVOffset New headerShadowVOffset value. Default value is 1
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderShadowVOffset(int headerShadowVOffset)  throws IllegalStateException {
        setAttribute("headerShadowVOffset", headerShadowVOffset, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderShadow showHeaderShadow} is true, the {@link
     * com.smartgwt.client.widgets.Canvas#getShadowVOffset Canvas.shadowVOffset} for the header shadow
     *
     * @return Current headerShadowVOffset value. Default value is 1
     */
    public int getHeaderShadowVOffset()  {
        return getAttributeAsInt("headerShadowVOffset");
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans} are created via the {@link
     * com.smartgwt.client.types.AutoChild} pattern, hence <code>headerSpanConstructor</code>, <code>headerSpanDefaults</code>
     * and <code>headerSpanProperties</code> are valid.
     *
     * @return null
     */
    public StatefulCanvas getHeaderSpan()  {
        return null;
    }
    
    

    /**
     * Default height for a {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpan} with no height
     * specified. <P> If <code>headerSpanHeight</code> is not specified (the default), headerSpans will be 1/2 of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight headerHeight}.
     *
     * @param headerSpanHeight New headerSpanHeight value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHeaderSpanHeight(Integer headerSpanHeight)  throws IllegalStateException {
        setAttribute("headerSpanHeight", headerSpanHeight, false);
    }

    /**
     * Default height for a {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpan} with no height
     * specified. <P> If <code>headerSpanHeight</code> is not specified (the default), headerSpans will be 1/2 of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight headerHeight}.
     *
     * @return Current headerSpanHeight value. Default value is null
     */
    public Integer getHeaderSpanHeight()  {
        return getAttributeAsInt("headerSpanHeight");
    }
    

    /**
     * Header spans are a second level of headers that appear above the normal ListGrid headers,
     *  spanning one or more listGrid fields in a manner similar to a column-spanning cell in an
     *  HTML table.
     *  <P>
     *  A header span can be created by simply naming the fields the header should span.  The
     *  example below creates a headerSpan that spans the first two fields of the ListGrid.
     *  
     *  
     *  <pre>
     *       ListGrid grid = new ListGrid();
     *       grid.setHeaderHeight(40);
     *       grid.setFields(new ListGridField[] {
     *           new ListGridField("field1"),
     *           new ListGridField("field2"),
     *           new ListGridField("field3")
     *       });
     *       grid.setHeaderSpans(new HeaderSpan[] {
     *           new HeaderSpan("Field 1 and 2", new String[] {"field1", "field2"})
     *       });
     *  </pre>
     *  
     *  Header spans can be nested, allowing fields to be grouped by multiple levels of
     * granularity. See {@link com.smartgwt.client.widgets.grid.HeaderSpan#getSpans HeaderSpan.spans} for further information
     * on nesting spans.
     *  <P>
     *  Header spans will automatically react to resizing of the headers they span, and will be
     *  hidden automatically when all of the spanned fields are hidden.
     *  <P>
     * Header spans appear in the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeader header} area of the ListGrid,
     * sharing space
     * with the existing headers, so it's typical to set {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderHeight
     * headerHeight} to
     *  approximately double its normal height when using headerSpans, or if using nested header
     *  spans, the default header height multiplied by the number of levels of header spans to be
     *  shown.
     *  <P>
     *  See {@link com.smartgwt.client.widgets.grid.HeaderSpan} for many properties that allow the control of the appearance of
     *  headerSpans.
     *  
     *  <P>
     *  Neither headerSpans themselves nor the fields within them may be drag reordered, but other
     *  unspanned headers may be.
     *  <P>
     *  A span can only span adjacent fields - if a span is defined and the spanned fields don't
     *  sit next to each other in the specified fields array, the fields array will be automatically
     * reordered to match the order specified in the span's {@link com.smartgwt.client.widgets.grid.HeaderSpan#getFields
     * HeaderSpan.fields} array.
     *  <P>
     *  Note that headerSpans primarily provide a visual cue for grouping multiple headers
     *  together.  If you have an OLAP, data "cube" or multi-dimensional data model, the
     *  {@link com.smartgwt.client.widgets.cube.CubeGrid} component is the right choice.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Update the headerSpans configuration on the grid dynamically.
     *
     * @param headerSpans same configuration block as that passed to                                          {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}. Default value is null
     */
    public void setHeaderSpans(HeaderSpan... headerSpans) {
        setAttribute("headerSpans", headerSpans, true);
    }
    
    

    /**
     * {@link com.smartgwt.client.widgets.StretchImgButton#getTitleStyle StretchImgButton.titleStyle} to apply to the buttons
     * in the header, and the sorter, for this ListGrid. Note that this will typically only have an effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor headerButtonConstructor} is set to {@link
     * com.smartgwt.client.widgets.StretchImgButton} or a subclass thereof.
     *
     * @param headerTitleStyle New headerTitleStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setHeaderTitleStyle(String headerTitleStyle)  throws IllegalStateException {
        setAttribute("headerTitleStyle", headerTitleStyle, false);
    }

    /**
     * {@link com.smartgwt.client.widgets.StretchImgButton#getTitleStyle StretchImgButton.titleStyle} to apply to the buttons
     * in the header, and the sorter, for this ListGrid. Note that this will typically only have an effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor headerButtonConstructor} is set to {@link
     * com.smartgwt.client.widgets.StretchImgButton} or a subclass thereof.
     *
     * @return Current headerTitleStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getHeaderTitleStyle()  {
        return getAttributeAsString("headerTitleStyle");
    }
    

    /**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getRotateHeaderTitles rotated titles}, specifies vertical
     * alignment in the column headers: "top", "center", or "bottom".  Can be overridden for individual fields by setting
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getValign ListGridField.valign}.
     *
     * @param headerTitleVAlign New headerTitleVAlign value. Default value is Canvas.BOTTOM
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValign
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRotateHeaderTitles
     * @see com.smartgwt.client.widgets.grid.ListGridField#setRotateTitle
     */
    public void setHeaderTitleVAlign(Boolean headerTitleVAlign)  throws IllegalStateException {
        setAttribute("headerTitleVAlign", headerTitleVAlign, false);
    }

    /**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getRotateHeaderTitles rotated titles}, specifies vertical
     * alignment in the column headers: "top", "center", or "bottom".  Can be overridden for individual fields by setting
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getValign ListGridField.valign}.
     *
     * @return Current headerTitleVAlign value. Default value is Canvas.BOTTOM
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValign
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRotateHeaderTitles
     * @see com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle
     */
    public Boolean getHeaderTitleVAlign()  {
        return getAttributeAsBoolean("headerTitleVAlign");
    }
    

    /**
     * If true, causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow} component to be hidden if
     * it has no data after summaries have been recalculated
     *
     * @param hideEmptySummaryRow New hideEmptySummaryRow value. Default value is null
     */
    public void setHideEmptySummaryRow(Boolean hideEmptySummaryRow) {
        setAttribute("hideEmptySummaryRow", hideEmptySummaryRow, true);
    }

    /**
     * If true, causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow} component to be hidden if
     * it has no data after summaries have been recalculated
     *
     * @return Current hideEmptySummaryRow value. Default value is null
     */
    public Boolean getHideEmptySummaryRow()  {
        return getAttributeAsBoolean("hideEmptySummaryRow");
    }
    

    /**
     * If set, end users can create advanced hiliting rules that will use the {@link
     * com.smartgwt.client.data.Hilite#getReplacementValue Hilite.replacementValue} feature to cause values in hilited cells to
     * be replaced with a user-entered value.  For example, a user could create a hilite rule that replaces numeric values
     * ranging from 0.5 to 1.0 with the text "LOW". <p> Specifically, when the "Add Advanced Rule" button is pressed and
     * <code>hiliteCanReplaceValue</code> is true, the user will see a text entry field titled "Replace value with" ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteReplaceValueFieldTitle hiliteReplaceValueFieldTitle}) and if they
     * enter a value, that value will appear in the grid cell in lieu of the cell's original value.
     *
     * @param hiliteCanReplaceValue New hiliteCanReplaceValue value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteCanReplaceValue(Boolean hiliteCanReplaceValue)  throws IllegalStateException {
        setAttribute("hiliteCanReplaceValue", hiliteCanReplaceValue, false);
    }

    /**
     * If set, end users can create advanced hiliting rules that will use the {@link
     * com.smartgwt.client.data.Hilite#getReplacementValue Hilite.replacementValue} feature to cause values in hilited cells to
     * be replaced with a user-entered value.  For example, a user could create a hilite rule that replaces numeric values
     * ranging from 0.5 to 1.0 with the text "LOW". <p> Specifically, when the "Add Advanced Rule" button is pressed and
     * <code>hiliteCanReplaceValue</code> is true, the user will see a text entry field titled "Replace value with" ({@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteReplaceValueFieldTitle hiliteReplaceValueFieldTitle}) and if they
     * enter a value, that value will appear in the grid cell in lieu of the cell's original value.
     *
     * @return Current hiliteCanReplaceValue value. Default value is null
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public Boolean getHiliteCanReplaceValue()  {
        return getAttributeAsBoolean("hiliteCanReplaceValue");
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInHiliteEditor showHeaderSpanTitlesInHiliteEditor} is
     * true, this string will be inserted between the headerSpan title and the field title in the hiliteEditor field chooser
     * grid.
     *
     * @param hiliteEditorSpanTitleSeparator New hiliteEditorSpanTitleSeparator value. Default value is " - "
     */
    public void setHiliteEditorSpanTitleSeparator(String hiliteEditorSpanTitleSeparator) {
        setAttribute("hiliteEditorSpanTitleSeparator", hiliteEditorSpanTitleSeparator, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInHiliteEditor showHeaderSpanTitlesInHiliteEditor} is
     * true, this string will be inserted between the headerSpan title and the field title in the hiliteEditor field chooser
     * grid.
     *
     * @return Current hiliteEditorSpanTitleSeparator value. Default value is " - "
     */
    public String getHiliteEditorSpanTitleSeparator()  {
        return getAttributeAsString("hiliteEditorSpanTitleSeparator");
    }
    

    /**
     * If set to true, custom HTML applied as part of hiliting will be applied after {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter formatting} for each cell. If false, hilite HTML will be
     * applied before formatting. <P> This applies to the following hilite properties: <ul> <li>{@link
     * com.smartgwt.client.data.Hilite#getReplacementValue Hilite.replacementValue}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlBefore Hilite.htmlBefore}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlAfter Hilite.htmlAfter}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlValue Hilite.htmlValue}</li> </ul> <P> May be overridden per field via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteHTMLAfterFormat ListGridField.hiliteHTMLAfterFormat}
     *
     * @param hiliteHTMLAfterFormat New hiliteHTMLAfterFormat value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHiliteHTMLAfterFormat(boolean hiliteHTMLAfterFormat)  throws IllegalStateException {
        setAttribute("hiliteHTMLAfterFormat", hiliteHTMLAfterFormat, false);
    }

    /**
     * If set to true, custom HTML applied as part of hiliting will be applied after {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter formatting} for each cell. If false, hilite HTML will be
     * applied before formatting. <P> This applies to the following hilite properties: <ul> <li>{@link
     * com.smartgwt.client.data.Hilite#getReplacementValue Hilite.replacementValue}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlBefore Hilite.htmlBefore}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlAfter Hilite.htmlAfter}</li> <li>{@link
     * com.smartgwt.client.data.Hilite#getHtmlValue Hilite.htmlValue}</li> </ul> <P> May be overridden per field via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteHTMLAfterFormat ListGridField.hiliteHTMLAfterFormat}
     *
     * @return Current hiliteHTMLAfterFormat value. Default value is true
     */
    public boolean getHiliteHTMLAfterFormat()  {
        Boolean result = getAttributeAsBoolean("hiliteHTMLAfterFormat");
        return result == null ? true : result;
    }
    

    /**
     * Height for hilite icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconSize
     * hiliteIconSize}. Can be overridden at the field level
     *
     * @param hiliteIconHeight New hiliteIconHeight value. Default value is null
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconHeight(Integer hiliteIconHeight) {
        setAttribute("hiliteIconHeight", hiliteIconHeight, true);
    }

    /**
     * Height for hilite icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconSize
     * hiliteIconSize}. Can be overridden at the field level
     *
     * @return Current hiliteIconHeight value. Default value is null
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public Integer getHiliteIconHeight()  {
        return getAttributeAsInt("hiliteIconHeight");
    }
    

    /**
     * How much padding should there be on the left of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite
     * icons} by default? Can be overridden at the field level
     *
     * @param hiliteIconLeftPadding New hiliteIconLeftPadding value. Default value is 2
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconLeftPadding(int hiliteIconLeftPadding) {
        setAttribute("hiliteIconLeftPadding", hiliteIconLeftPadding, true);
    }

    /**
     * How much padding should there be on the left of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite
     * icons} by default? Can be overridden at the field level
     *
     * @return Current hiliteIconLeftPadding value. Default value is 2
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public int getHiliteIconLeftPadding()  {
        return getAttributeAsInt("hiliteIconLeftPadding");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hiliteIcons} are present, where the hilite icon
     * will be placed  relative to the field value.  See {@link com.smartgwt.client.types.HiliteIconPosition}. Can be
     * overridden at the field level.
     *
     * @param hiliteIconPosition New hiliteIconPosition value. Default value is "before"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconPosition(HiliteIconPosition hiliteIconPosition)  throws IllegalStateException {
        setAttribute("hiliteIconPosition", hiliteIconPosition == null ? null : hiliteIconPosition.getValue(), false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hiliteIcons} are present, where the hilite icon
     * will be placed  relative to the field value.  See {@link com.smartgwt.client.types.HiliteIconPosition}. Can be
     * overridden at the field level.
     *
     * @return Current hiliteIconPosition value. Default value is "before"
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public HiliteIconPosition getHiliteIconPosition()  {
        return EnumUtil.getEnum(HiliteIconPosition.values(), getAttribute("hiliteIconPosition"));
    }
    

    /**
     * How much padding should there be on the right of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite
     * icons} by default? Can be overridden at the field level
     *
     * @param hiliteIconRightPadding New hiliteIconRightPadding value. Default value is 2
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconRightPadding(int hiliteIconRightPadding) {
        setAttribute("hiliteIconRightPadding", hiliteIconRightPadding, true);
    }

    /**
     * How much padding should there be on the right of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite
     * icons} by default? Can be overridden at the field level
     *
     * @return Current hiliteIconRightPadding value. Default value is 2
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public int getHiliteIconRightPadding()  {
        return getAttributeAsInt("hiliteIconRightPadding");
    }
    

    /**
     * Specifies a list of icons that can be used in {@link com.smartgwt.client.widgets.DataBoundComponent#editHilites
     * hilites}. <P> <code>hiliteIcons</code> should be specified as an Array of {@link com.smartgwt.client.docs.SCImgURL}.
     * When present, the hilite editing interface shown when {@link com.smartgwt.client.widgets.DataBoundComponent#editHilites
     * DataBoundComponent.editHilites()} is called  will offer the user a drop down for picking one of these icons when
     * defining either a  simple or advanced hilite rule. <P> If the user picks an icon, the created hiliting rule will have
     * {@link com.smartgwt.client.data.Hilite#getIcon Hilite.icon} set to  the chosen icon.  {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getHiliteIconPosition DataBoundComponent.hiliteIconPosition} controls
     * where the icon will  appear for that field -- the default is that it appears in front of the normal cell content. This
     * can also be overridden at the field level.
     *
     * @param hiliteIcons New hiliteIcons value. Default value is ["[SKINIMG]/Dialog/notify.png", "[SKINIMG]/Dialog/warn.png", "[SKINIMG]/actions/approve.png"]
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIcons(String... hiliteIcons)  throws IllegalStateException {
        setAttribute("hiliteIcons", hiliteIcons, false);
    }

    /**
     * Specifies a list of icons that can be used in {@link com.smartgwt.client.widgets.DataBoundComponent#editHilites
     * hilites}. <P> <code>hiliteIcons</code> should be specified as an Array of {@link com.smartgwt.client.docs.SCImgURL}.
     * When present, the hilite editing interface shown when {@link com.smartgwt.client.widgets.DataBoundComponent#editHilites
     * DataBoundComponent.editHilites()} is called  will offer the user a drop down for picking one of these icons when
     * defining either a  simple or advanced hilite rule. <P> If the user picks an icon, the created hiliting rule will have
     * {@link com.smartgwt.client.data.Hilite#getIcon Hilite.icon} set to  the chosen icon.  {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getHiliteIconPosition DataBoundComponent.hiliteIconPosition} controls
     * where the icon will  appear for that field -- the default is that it appears in front of the normal cell content. This
     * can also be overridden at the field level.
     *
     * @return Current hiliteIcons value. Default value is ["[SKINIMG]/Dialog/notify.png", "[SKINIMG]/Dialog/warn.png", "[SKINIMG]/actions/approve.png"]
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public String[] getHiliteIcons()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfString(getAttributeAsJavaScriptObject("hiliteIcons"));
    }
    

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite icons} for this
     * component. Can be overridden at the component level via explicit  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconWidth hiliteIconWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconHeight hiliteIconHeight}, or at the field level via  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconSize hiliteIconSize}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconWidth hiliteIconWidth} and  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconHeight hiliteIconHeight}
     *
     * @param hiliteIconSize New hiliteIconSize value. Default value is 12
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHiliteIconWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHiliteIconHeight
     * @see com.smartgwt.client.widgets.grid.ListGridField#setHiliteIconSize
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconSize(int hiliteIconSize) {
        setAttribute("hiliteIconSize", hiliteIconSize, true);
    }

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIcons hilite icons} for this
     * component. Can be overridden at the component level via explicit  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconWidth hiliteIconWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconHeight hiliteIconHeight}, or at the field level via  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconSize hiliteIconSize}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconWidth hiliteIconWidth} and  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconHeight hiliteIconHeight}
     *
     * @return Current hiliteIconSize value. Default value is 12
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconHeight
     * @see com.smartgwt.client.widgets.grid.ListGridField#getHiliteIconSize
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public int getHiliteIconSize()  {
        return getAttributeAsInt("hiliteIconSize");
    }
    

    /**
     * Width for hilite icons for this component. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconSize
     * hiliteIconSize}. Can be overridden at the field level.
     *
     * @param hiliteIconWidth New hiliteIconWidth value. Default value is null
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public void setHiliteIconWidth(Integer hiliteIconWidth) {
        setAttribute("hiliteIconWidth", hiliteIconWidth, true);
    }

    /**
     * Width for hilite icons for this component. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteIconSize
     * hiliteIconSize}. Can be overridden at the field level.
     *
     * @return Current hiliteIconWidth value. Default value is null
     * @see com.smartgwt.client.docs.Hiliting Hiliting overview and related methods
     */
    public Integer getHiliteIconWidth()  {
        return getAttributeAsInt("hiliteIconWidth");
    }
    

    /**
     * Title used for the text box shown when {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteCanReplaceValue
     * hiliteCanReplaceValue} is set.
     *
     * @param hiliteReplaceValueFieldTitle New hiliteReplaceValueFieldTitle value. Default value is "Replace value with"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setHiliteReplaceValueFieldTitle(String hiliteReplaceValueFieldTitle)  throws IllegalStateException {
        setAttribute("hiliteReplaceValueFieldTitle", hiliteReplaceValueFieldTitle, false);
    }

    /**
     * Title used for the text box shown when {@link com.smartgwt.client.widgets.grid.ListGrid#getHiliteCanReplaceValue
     * hiliteCanReplaceValue} is set.
     *
     * @return Current hiliteReplaceValueFieldTitle value. Default value is "Replace value with"
     */
    public String getHiliteReplaceValueFieldTitle()  {
        return getAttributeAsString("hiliteReplaceValueFieldTitle");
    }
    

    /**
     * When the grid body gets keyboard focus, should we highlight the current focus row, using the rollover cell style? <P>
     * This property may be explicitly set to control this behavior independently of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver}. Otherwise (if this property is null), we will
     * show the roll-over styling for the keyboard focus row if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver} is true.
     *
     * @param hiliteRowOnFocus New hiliteRowOnFocus value. Default value is null
     */
    public void setHiliteRowOnFocus(Boolean hiliteRowOnFocus) {
        setAttribute("hiliteRowOnFocus", hiliteRowOnFocus, true);
    }

    /**
     * When the grid body gets keyboard focus, should we highlight the current focus row, using the rollover cell style? <P>
     * This property may be explicitly set to control this behavior independently of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver}. Otherwise (if this property is null), we will
     * show the roll-over styling for the keyboard focus row if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver} is true.
     *
     * @return Current hiliteRowOnFocus value. Default value is null
     */
    public Boolean getHiliteRowOnFocus()  {
        return getAttributeAsBoolean("hiliteRowOnFocus");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHoverComponents showHoverComponents} is true, the builtin
     * mode to use when automatically creating a hover component for rows in this grid. <P> A number of builtin modes are
     * provided - see {@link com.smartgwt.client.types.HoverMode}.  You can also override {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellHoverComponent getCellHoverComponent()} to provide a custom hover
     * widget - in that case, this attribute is ignored.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param hoverMode New hoverMode value. Default value is null
     */
    public void setHoverMode(HoverMode hoverMode) {
        setAttribute("hoverMode", hoverMode == null ? null : hoverMode.getValue(), true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHoverComponents showHoverComponents} is true, the builtin
     * mode to use when automatically creating a hover component for rows in this grid. <P> A number of builtin modes are
     * provided - see {@link com.smartgwt.client.types.HoverMode}.  You can also override {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellHoverComponent getCellHoverComponent()} to provide a custom hover
     * widget - in that case, this attribute is ignored.
     *
     * @return Current hoverMode value. Default value is null
     */
    public HoverMode getHoverMode()  {
        return EnumUtil.getEnum(HoverMode.values(), getAttribute("hoverMode"));
    }
    

    /**
     * Style to apply to hovers shown over this grid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param hoverStyle New hoverStyle value. Default value is "gridHover"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowHover
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setHoverStyle(String hoverStyle) {
        setAttribute("hoverStyle", hoverStyle, true);
    }

    /**
     * Style to apply to hovers shown over this grid.
     *
     * @return Current hoverStyle value. Default value is "gridHover"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowHover
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getHoverStyle()  {
        return getAttributeAsString("hoverStyle");
    }
    

    /**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths}, padding in pixels
     * left on each side of fields that show images.
     *
     * @param iconPadding New iconPadding value. Default value is 2
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setIconPadding(Integer iconPadding)  throws IllegalStateException {
        setAttribute("iconPadding", iconPadding, false);
    }

    /**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths}, padding in pixels
     * left on each side of fields that show images.
     *
     * @return Current iconPadding value. Default value is 2
     */
    public Integer getIconPadding()  {
        return getAttributeAsInt("iconPadding");
    }
    

    /**
     * Default size of thumbnails shown for fieldTypes image and imageFile.  Overrideable on a per-field basis via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageSize ListGridField.imageSize} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageWidth ListGridField.imageWidth}/{@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageHeight ListGridField.imageHeight}
     *
     * @param imageSize New imageSize value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setImageSize(int imageSize) {
        setAttribute("imageSize", imageSize, true);
    }

    /**
     * Default size of thumbnails shown for fieldTypes image and imageFile.  Overrideable on a per-field basis via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageSize ListGridField.imageSize} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageWidth ListGridField.imageWidth}/{@link
     * com.smartgwt.client.widgets.grid.ListGridField#getImageHeight ListGridField.imageHeight}
     *
     * @return Current imageSize value. Default value is 16
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getImageSize()  {
        return getAttributeAsInt("imageSize");
    }
    
    

    /**
     * When assembling a value for a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddSummaryFields summary field}, if
     * a referenced field is hilited, should the hilite HTML be included in the summary field value? <P> To control hilites
     * showing in group summaries, see {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHilitesInGroupSummary
     * showHilitesInGroupSummary}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param includeHilitesInSummaryFields New includeHilitesInSummaryFields value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#shouldIncludeHiliteInSummaryField
     */
    public void setIncludeHilitesInSummaryFields(boolean includeHilitesInSummaryFields) {
        setAttribute("includeHilitesInSummaryFields", includeHilitesInSummaryFields, true);
    }

    /**
     * When assembling a value for a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddSummaryFields summary field}, if
     * a referenced field is hilited, should the hilite HTML be included in the summary field value? <P> To control hilites
     * showing in group summaries, see {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHilitesInGroupSummary
     * showHilitesInGroupSummary}.
     *
     * @return Current includeHilitesInSummaryFields value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#shouldIncludeHiliteInSummaryField
     */
    public boolean getIncludeHilitesInSummaryFields()  {
        Boolean result = getAttributeAsBoolean("includeHilitesInSummaryFields");
        return result == null ? true : result;
    }
    

    /**
     * Property name on a record that will be checked to determine whether a record should be included when calculating totals
     * for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary}.
     *
     * @param includeInSummaryProperty New includeInSummaryProperty value. Default value is "includeInSummary"
     */
    public void setIncludeInSummaryProperty(String includeInSummaryProperty) {
        setAttribute("includeInSummaryProperty", includeInSummaryProperty, true);
    }

    /**
     * Property name on a record that will be checked to determine whether a record should be included when calculating totals
     * for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary}.
     *
     * @return Current includeInSummaryProperty value. Default value is "includeInSummary"
     */
    public String getIncludeInSummaryProperty()  {
        return getAttributeAsString("includeInSummaryProperty");
    }
    
    

    /**
     * An array of {@link com.smartgwt.client.data.SortSpecifier} objects used to set up the initial sort configuration for
     * this grid. If specified, this will be used instead of any {@link com.smartgwt.client.widgets.grid.ListGrid#getSortField
     * sortField} specified.
     *
     * @param initialSort New initialSort value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setInitialSort(SortSpecifier... initialSort)  throws IllegalStateException {
        setAttribute("initialSort", initialSort, false);
    }

    /**
     * An array of {@link com.smartgwt.client.data.SortSpecifier} objects used to set up the initial sort configuration for
     * this grid. If specified, this will be used instead of any {@link com.smartgwt.client.widgets.grid.ListGrid#getSortField
     * sortField} specified.
     *
     * @return Current initialSort value. Default value is null
     */
    public SortSpecifier[] getInitialSort()  {
        return com.smartgwt.client.util.ConvertTo.arrayOfSortSpecifier(getAttributeAsJavaScriptObject("initialSort"));
    }
    

    /**
     * If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will
     * be an instant redraw of the grid content so that the user doesn't see any blank space.  For drag scrolling or other
     * types of scrolling, the {@link com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}
     * applies.
     *
     * @param instantScrollTrackRedraw New instantScrollTrackRedraw value. Default value is true
     */
    public void setInstantScrollTrackRedraw(Boolean instantScrollTrackRedraw) {
        setAttribute("instantScrollTrackRedraw", instantScrollTrackRedraw, true);
    }

    /**
     * If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will
     * be an instant redraw of the grid content so that the user doesn't see any blank space.  For drag scrolling or other
     * types of scrolling, the {@link com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}
     * applies.
     *
     * @return Current instantScrollTrackRedraw value. Default value is true
     */
    public Boolean getInstantScrollTrackRedraw()  {
        Boolean result = getAttributeAsBoolean("instantScrollTrackRedraw");
        return result == null ? true : result;
    }
    

    /**
     * Value to display to the user if showing summary values (through {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} or {@link
     * com.smartgwt.client.types.ListGridFieldType listGridFieldType:"summary"}), and the summary function returns
     * <code>"null"</code> (implying it was unable to calculate a valid summary value). This property will only be used in the
     * default formatting behavior. If an explicit formatter has been specified - via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter setCellFormatter()} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFormatGridSummary formatGridSummary()}, for example - this property
     * has no effect.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param invalidSummaryValue New invalidSummaryValue value. Default value is "&amp;nbsp;"
     */
    public void setInvalidSummaryValue(String invalidSummaryValue) {
        setAttribute("invalidSummaryValue", invalidSummaryValue, true);
    }

    /**
     * Value to display to the user if showing summary values (through {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} or {@link
     * com.smartgwt.client.types.ListGridFieldType listGridFieldType:"summary"}), and the summary function returns
     * <code>"null"</code> (implying it was unable to calculate a valid summary value). This property will only be used in the
     * default formatting behavior. If an explicit formatter has been specified - via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter setCellFormatter()} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFormatGridSummary formatGridSummary()}, for example - this property
     * has no effect.
     *
     * @return Current invalidSummaryValue value. Default value is "&amp;nbsp;"
     */
    public String getInvalidSummaryValue()  {
        return getAttributeAsString("invalidSummaryValue");
    }
    

    /**
     * True if this listGrid is grouped, false otherwise
     * <p>
     * <b>Note :</b> This method should be called only after the widget has been rendered.
     *
     * @return Current isGrouped value. Default value is false
     * @throws IllegalStateException if this widget has not yet been rendered.
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public boolean getIsGrouped() throws IllegalStateException {
        errorIfNotCreated("isGrouped");
        Boolean result = getAttributeAsBoolean("isGrouped");
        return result == null ? false : result;
    }
    

    /**
     * If <code>record[this.isSeparatorProperty]</code> is set for some record, the record will be displayed as a simple
     * separator row.
     *
     * @param isSeparatorProperty New isSeparatorProperty value. Default value is "isSeparator"
     */
    public void setIsSeparatorProperty(String isSeparatorProperty) {
        setAttribute("isSeparatorProperty", isSeparatorProperty, true);
    }

    /**
     * If <code>record[this.isSeparatorProperty]</code> is set for some record, the record will be displayed as a simple
     * separator row.
     *
     * @return Current isSeparatorProperty value. Default value is "isSeparator"
     */
    public String getIsSeparatorProperty()  {
        return getAttributeAsString("isSeparatorProperty");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, when
     * auto-fitting fields to the title width via {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths
     * autoFitFieldWidths} or {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth
     * ListGridField.autoFitWidth}, should the button be sized such that there is enough space for the header menu button to
     * show without covering the field title? <P> May be explicitly specified at the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getLeaveHeaderMenuButtonSpace field level} or at the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getLeaveHeaderMenuButtonSpace grid level}. If not explicitly specified space
     * will be left for fields with {@link com.smartgwt.client.widgets.grid.ListGridField#getAlign ListGridField.align} set to
     * <code>"left"</code> or <code>"right"</code>, but not for fields with align set to <code>"center"</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param leaveHeaderMenuButtonSpace New leaveHeaderMenuButtonSpace value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortArrowMenuButtonSpaceOffset
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortNumeralMenuButtonSpaceOffset
     */
    public void setLeaveHeaderMenuButtonSpace(Boolean leaveHeaderMenuButtonSpace) {
        setAttribute("leaveHeaderMenuButtonSpace", leaveHeaderMenuButtonSpace, true);
    }
    

    /**
     * Whether to leave a gap for the vertical scrollbar, even when it's not present. <P> Note that if leaveScrollbarGap is
     * false and vertical scrolling is introduced, fields will be resized to fit the smaller body area if possible, in order to
     * avoid horizontal scrolling also being required.
     *
     * @param leaveScrollbarGap New leaveScrollbarGap value. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public void setLeaveScrollbarGap(Boolean leaveScrollbarGap) {
        setAttribute("leaveScrollbarGap", leaveScrollbarGap, true);
    }

    /**
     * Whether to leave a gap for the vertical scrollbar, even when it's not present. <P> Note that if leaveScrollbarGap is
     * false and vertical scrolling is introduced, fields will be resized to fit the smaller body area if possible, in order to
     * avoid horizontal scrolling also being required.
     *
     * @return Current leaveScrollbarGap value. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public Boolean getLeaveScrollbarGap()  {
        Boolean result = getAttributeAsBoolean("leaveScrollbarGap");
        return result == null ? true : result;
    }
    

    /**
     * Property name on a record that will hold the link text for that record. <P> This property is configurable to avoid
     * possible collision with data values in the record. <P> Use {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getLinkTextProperty ListGridField.linkTextProperty} if you have more than
     * one link field and
     *
     * @param linkTextProperty New linkTextProperty value. Default value is "linkText"
     * @see com.smartgwt.client.types.ListGridFieldType
     * @see com.smartgwt.client.types.FieldType
     * @see com.smartgwt.client.widgets.grid.ListGridField#setLinkText
     * @see com.smartgwt.client.widgets.grid.ListGridField#setLinkTextProperty
     */
    public void setLinkTextProperty(String linkTextProperty) {
        setAttribute("linkTextProperty", linkTextProperty, true);
    }

    /**
     * Property name on a record that will hold the link text for that record. <P> This property is configurable to avoid
     * possible collision with data values in the record. <P> Use {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getLinkTextProperty ListGridField.linkTextProperty} if you have more than
     * one link field and
     *
     * @return Current linkTextProperty value. Default value is "linkText"
     * @see com.smartgwt.client.types.ListGridFieldType
     * @see com.smartgwt.client.types.FieldType
     * @see com.smartgwt.client.widgets.grid.ListGridField#getLinkText
     * @see com.smartgwt.client.widgets.grid.ListGridField#getLinkTextProperty
     */
    public String getLinkTextProperty()  {
        return getAttributeAsString("linkTextProperty");
    }
    

    /**
     * If the user is editing the last record in this listGrid, and attempts to navigate beyond the last row either by tabbing
     * off the last editable field, or using the down arrow key, this property determines what action to take:<ul> <li>"next":
     * start editing a new record at the end of the list. <li>"done": hide the editor <li>"stop": leave focus in the cell being
     * edited <li>"none": no action </ul> <P> See the {@link com.smartgwt.client.docs.Editing Grid Editing overview} and also
     * the {@link com.smartgwt.client.docs.UnsavedRecords Editing Unsaved Records overview} for context about how newly added
     * records behave.
     *
     * @param listEndEditAction New listEndEditAction value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_new_row" target="examples">Enter new rows Example</a>
     */
    public void setListEndEditAction(RowEndEditAction listEndEditAction) {
        setAttribute("listEndEditAction", listEndEditAction == null ? null : listEndEditAction.getValue(), true);
    }

    /**
     * If the user is editing the last record in this listGrid, and attempts to navigate beyond the last row either by tabbing
     * off the last editable field, or using the down arrow key, this property determines what action to take:<ul> <li>"next":
     * start editing a new record at the end of the list. <li>"done": hide the editor <li>"stop": leave focus in the cell being
     * edited <li>"none": no action </ul> <P> See the {@link com.smartgwt.client.docs.Editing Grid Editing overview} and also
     * the {@link com.smartgwt.client.docs.UnsavedRecords Editing Unsaved Records overview} for context about how newly added
     * records behave.
     *
     * @return Current listEndEditAction value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_new_row" target="examples">Enter new rows Example</a>
     */
    public RowEndEditAction getListEndEditAction()  {
        return EnumUtil.getEnum(RowEndEditAction.values(), getAttribute("listEndEditAction"));
    }
    

    /**
     * The string to display in the body of a listGrid while data is being loaded. Use <code>"&#36;{loadingImage}"</code> to
     * include {@link com.smartgwt.client.widgets.Canvas#loadingImageSrc a loading image}.
     *
     * @param loadingDataMessage New loadingDataMessage value. Default value is "${loadingImage}&amp;nbsp;Loading data..."
     * @see com.smartgwt.client.widgets.grid.ListGrid#setLoadingDataMessageStyle
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setLoadingDataMessage(String loadingDataMessage) {
        setAttribute("loadingDataMessage", loadingDataMessage, true);
    }

    /**
     * The string to display in the body of a listGrid while data is being loaded. Use <code>"&#36;{loadingImage}"</code> to
     * include {@link com.smartgwt.client.widgets.Canvas#loadingImageSrc a loading image}.
     *
     * @return Current loadingDataMessage value. Default value is "${loadingImage}&amp;nbsp;Loading data..."
     * @see com.smartgwt.client.widgets.grid.ListGrid#getLoadingDataMessageStyle
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getLoadingDataMessage()  {
        return getAttributeAsString("loadingDataMessage");
    }
    

    /**
     * The CSS style name applied to the loadingDataMessage string if displayed.
     *
     * @param loadingDataMessageStyle New loadingDataMessageStyle value. Default value is "loadingDataMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setLoadingDataMessageStyle(String loadingDataMessageStyle) {
        setAttribute("loadingDataMessageStyle", loadingDataMessageStyle, true);
    }

    /**
     * The CSS style name applied to the loadingDataMessage string if displayed.
     *
     * @return Current loadingDataMessageStyle value. Default value is "loadingDataMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getLoadingDataMessageStyle()  {
        return getAttributeAsString("loadingDataMessageStyle");
    }
    

    /**
     * If you have a databound listGrid and you scroll out of the currently loaded dataset, by default you will see blank rows
     * until the server returns the data for those rows.  The loadingMessage attribute allows you to specify arbitrary html
     * that will be shown in each such "blank" record while the data for that record is loading.
     *
     * @param loadingMessage New loadingMessage value. Default value is "&amp;nbsp;"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setLoadingMessage(String loadingMessage)  throws IllegalStateException {
        setAttribute("loadingMessage", loadingMessage, false);
    }

    /**
     * If you have a databound listGrid and you scroll out of the currently loaded dataset, by default you will see blank rows
     * until the server returns the data for those rows.  The loadingMessage attribute allows you to specify arbitrary html
     * that will be shown in each such "blank" record while the data for that record is loading.
     *
     * @return Current loadingMessage value. Default value is "&amp;nbsp;"
     */
    public String getLoadingMessage()  {
        return getAttributeAsString("loadingMessage");
    }
    

    /**
     * When {@link com.smartgwt.client.util.AutoTest#getElement AutoTest.getElement()} is used to parse locator strings
     * generated by {@link com.smartgwt.client.util.AutoTest#getLocator AutoTest.getLocator()} for a cell in this grid, how
     * should the column be identified? <br> Note that getLocator() will actually store all available information about the
     * column in the generated string -- this attribute effects how a stored string will be parsed only. <P> Valid options
     * area: <ul> <li><code>"fieldName"</code> Attempt to identify by fieldName.</li> <li><code>"index"</code> Attempt to
     * identify by colNum (index in the fields array).</li> </ul> If unset, default behavior is to identify by fieldName (if
     * available), otherwise by index.
     *
     * @param locateColumnsBy New locateColumnsBy value. Default value is null
     * @see com.smartgwt.client.types.LocatorStrategy
     */
    public void setLocateColumnsBy(String locateColumnsBy) {
        setAttribute("locateColumnsBy", locateColumnsBy, true);
    }

    /**
     * When {@link com.smartgwt.client.util.AutoTest#getElement AutoTest.getElement()} is used to parse locator strings
     * generated by {@link com.smartgwt.client.util.AutoTest#getLocator AutoTest.getLocator()} for a cell in this grid, how
     * should the column be identified? <br> Note that getLocator() will actually store all available information about the
     * column in the generated string -- this attribute effects how a stored string will be parsed only. <P> Valid options
     * area: <ul> <li><code>"fieldName"</code> Attempt to identify by fieldName.</li> <li><code>"index"</code> Attempt to
     * identify by colNum (index in the fields array).</li> </ul> If unset, default behavior is to identify by fieldName (if
     * available), otherwise by index.
     *
     * @return Current locateColumnsBy value. Default value is null
     * @see com.smartgwt.client.types.LocatorStrategy
     */
    public String getLocateColumnsBy()  {
        return getAttributeAsString("locateColumnsBy");
    }
    

    /**
     * When {@link com.smartgwt.client.util.AutoTest#getElement AutoTest.getElement()} is used to parse locator strings
     * generated by {@link com.smartgwt.client.util.AutoTest#getLocator AutoTest.getLocator()} for a cell in this grid, how
     * should the row be identified? <br> Note that getLocator() will actually store all available information about the row in
     * the generated string -- this attribute effects how a stored string will be parsed only. <P> Valid options area: <ul>
     * <li><code>"primaryKey"</code> Only applies to databound grids: If the cell in question has  a primary key cell value,
     * use it to identify cells in autoTest locator strings.</li> <li><code>"titleField"</code> If the cell in question has a
     * value for the  {@link com.smartgwt.client.widgets.grid.ListGrid#getTitleField titleField}, use it to identify cells in
     * autoTest  locator strings</li> <li><code>"targetCellValue"</code> Identify rows by storing the cell value for the target
     * row / field in autoTest locator strings</li> <li><code>"index"</code>The rowNum will be used to identify the row.</li>
     * </ul> If unset, default behavior is to identify by primary key (if available), otherwise by titleField (if available),
     * otherwise by cell value (if available), and lastly by index.
     *
     * @param locateRowsBy New locateRowsBy value. Default value is null
     * @see com.smartgwt.client.types.LocatorStrategy
     */
    public void setLocateRowsBy(String locateRowsBy) {
        setAttribute("locateRowsBy", locateRowsBy, true);
    }

    /**
     * When {@link com.smartgwt.client.util.AutoTest#getElement AutoTest.getElement()} is used to parse locator strings
     * generated by {@link com.smartgwt.client.util.AutoTest#getLocator AutoTest.getLocator()} for a cell in this grid, how
     * should the row be identified? <br> Note that getLocator() will actually store all available information about the row in
     * the generated string -- this attribute effects how a stored string will be parsed only. <P> Valid options area: <ul>
     * <li><code>"primaryKey"</code> Only applies to databound grids: If the cell in question has  a primary key cell value,
     * use it to identify cells in autoTest locator strings.</li> <li><code>"titleField"</code> If the cell in question has a
     * value for the  {@link com.smartgwt.client.widgets.grid.ListGrid#getTitleField titleField}, use it to identify cells in
     * autoTest  locator strings</li> <li><code>"targetCellValue"</code> Identify rows by storing the cell value for the target
     * row / field in autoTest locator strings</li> <li><code>"index"</code>The rowNum will be used to identify the row.</li>
     * </ul> If unset, default behavior is to identify by primary key (if available), otherwise by titleField (if available),
     * otherwise by cell value (if available), and lastly by index.
     *
     * @return Current locateRowsBy value. Default value is null
     * @see com.smartgwt.client.types.LocatorStrategy
     */
    public String getLocateRowsBy()  {
        return getAttributeAsString("locateRowsBy");
    }
    

    /**
     * When the length of the field specified by {@link com.smartgwt.client.data.DataSourceField#getLength
     * DataSourceField.length} exceeds this value, the ListGrid shows an edit field of type {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getLongTextEditorType longTextEditorType} rather than the standard text field
     * when the field enters inline edit mode.
     *
     * @param longTextEditorThreshold New longTextEditorThreshold value. Default value is 255
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setLongTextEditorThreshold(int longTextEditorThreshold) {
        setAttribute("longTextEditorThreshold", longTextEditorThreshold, true);
    }

    /**
     * When the length of the field specified by {@link com.smartgwt.client.data.DataSourceField#getLength
     * DataSourceField.length} exceeds this value, the ListGrid shows an edit field of type {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getLongTextEditorType longTextEditorType} rather than the standard text field
     * when the field enters inline edit mode.
     *
     * @return Current longTextEditorThreshold value. Default value is 255
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public int getLongTextEditorThreshold()  {
        return getAttributeAsInt("longTextEditorThreshold");
    }
    

    /**
     * When the length of the field specified by {@link com.smartgwt.client.data.DataSourceField#getLength
     * DataSourceField.length} exceeds <code>this.longTextEditorThreshold</code> show an edit field of this type rather than
     * the standard text field when the field enters inline edit mode.
     *
     * @param longTextEditorType New longTextEditorType value. Default value is "PopUpTextAreaItem"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setLongTextEditorType(String longTextEditorType) {
        setAttribute("longTextEditorType", longTextEditorType, true);
    }

    /**
     * When the length of the field specified by {@link com.smartgwt.client.data.DataSourceField#getLength
     * DataSourceField.length} exceeds <code>this.longTextEditorThreshold</code> show an edit field of this type rather than
     * the standard text field when the field enters inline edit mode.
     *
     * @return Current longTextEditorType value. Default value is "PopUpTextAreaItem"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getLongTextEditorType()  {
        return getAttributeAsString("longTextEditorType");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandMultipleRecords canExpandMultipleRecords} are both true, this
     * property dictates the number of records which can be expanded simultaneously.  If the expanded record count hits the
     * value of this property, further attempts to expand records will result in a popup warning (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMaxExpandedRecordsPrompt maxExpandedRecordsPrompt}) and expansion will be
     * cancelled. <P> The default value is null, meaning there is no limit on the number of expanded records.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param maxExpandedRecords New maxExpandedRecords value. Default value is null
     */
    public void setMaxExpandedRecords(Integer maxExpandedRecords) {
        setAttribute("maxExpandedRecords", maxExpandedRecords, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandMultipleRecords canExpandMultipleRecords} are both true, this
     * property dictates the number of records which can be expanded simultaneously.  If the expanded record count hits the
     * value of this property, further attempts to expand records will result in a popup warning (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMaxExpandedRecordsPrompt maxExpandedRecordsPrompt}) and expansion will be
     * cancelled. <P> The default value is null, meaning there is no limit on the number of expanded records.
     *
     * @return Current maxExpandedRecords value. Default value is null
     */
    public Integer getMaxExpandedRecords()  {
        return getAttributeAsInt("maxExpandedRecords");
    }
    

    /**
     * This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code when the message is
     * displayed. Note that the local variable <code>count</code> will be available and set to this.maxExpandedRecords. The
     * string will be executed in the scope of the ListGrid so <code>this</code> may also be used to determine other
     * information about this grid. <P> Default value returns <P> <code> <i>This grid is limited to <code>[{@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMaxExpandedRecords maxExpandedRecords}]</code> simultaneously expanded
     * records.  Please collapse some expanded records and retry.</i> </code>
     *
     * @param maxExpandedRecordsPrompt New maxExpandedRecordsPrompt value. Default value is "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry."
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setMaxExpandedRecordsPrompt(String maxExpandedRecordsPrompt)  throws IllegalStateException {
        setAttribute("maxExpandedRecordsPrompt", maxExpandedRecordsPrompt, false);
    }

    /**
     * This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code when the message is
     * displayed. Note that the local variable <code>count</code> will be available and set to this.maxExpandedRecords. The
     * string will be executed in the scope of the ListGrid so <code>this</code> may also be used to determine other
     * information about this grid. <P> Default value returns <P> <code> <i>This grid is limited to <code>[{@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMaxExpandedRecords maxExpandedRecords}]</code> simultaneously expanded
     * records.  Please collapse some expanded records and retry.</i> </code>
     *
     * @return Current maxExpandedRecordsPrompt value. Default value is "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry."
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getMaxExpandedRecordsPrompt()  {
        return getAttributeAsString("maxExpandedRecordsPrompt");
    }
    

    /**
     * Minimum size, in pixels, for ListGrid headers.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Updates {@link com.smartgwt.client.widgets.grid.ListGrid#getMinFieldWidth minFieldWidth} and redraws any columns as needed.
     *
     * @param minFieldWidth New minFieldWidth value. Default value is 15
     */
    public void setMinFieldWidth(int minFieldWidth) {
        setAttribute("minFieldWidth", minFieldWidth, true);
    }

    /**
     * Minimum size, in pixels, for ListGrid headers.
     *
     * @return Current minFieldWidth value. Default value is 15
     */
    public int getMinFieldWidth()  {
        return getAttributeAsInt("minFieldWidth");
    }
    

    /**
     * Minimum height for the entire list (smaller than this doesn't tend to work very well). If not set, this value will be
     * defaulted when {@link com.smartgwt.client.widgets.Canvas#draw draw} is called to something reasonable based on whether
     * we're showing the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter editor}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeader header}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary summary rows}, and/or the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowEmptyMessage empty message}. <P> Note that any top or bottom CSS
     * padding specified by {@link com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessageStyle emptyMessageStyle} will be
     * taken into account, increasing <code>minHeight</code> so that the empty message can be shown without overflow.
     *
     * @param minHeight New minHeight value. Default value is varies
     * @see com.smartgwt.client.widgets.Canvas#setMinHeight
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     */
    public void setMinHeight(int minHeight) {
        setAttribute("minHeight", minHeight, true);
    }

    /**
     * Minimum height for the entire list (smaller than this doesn't tend to work very well). If not set, this value will be
     * defaulted when {@link com.smartgwt.client.widgets.Canvas#draw draw} is called to something reasonable based on whether
     * we're showing the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter editor}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeader header}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary summary rows}, and/or the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowEmptyMessage empty message}. <P> Note that any top or bottom CSS
     * padding specified by {@link com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessageStyle emptyMessageStyle} will be
     * taken into account, increasing <code>minHeight</code> so that the empty message can be shown without overflow.
     *
     * @return Current minHeight value. Default value is varies
     * @see com.smartgwt.client.widgets.Canvas#getMinHeight
     * @see com.smartgwt.client.docs.Sizing Sizing overview and related methods
     */
    public int getMinHeight()  {
        return getAttributeAsInt("minHeight");
    }
    

    /**
     * Minimum height for ListGrid cells, settable by the skin, based on the size of the  checkbox media used for boolean
     * fields plus minimal surrounding padding.   <code>minimumCellHeight</code> is used by {@link
     * com.smartgwt.client.widgets.Canvas#resizeControls Canvas.resizeControls()} to  avoid shrinking ListGrid rows so much
     * that correct display is impossible.   Do not set minimumCellHeight on a per-instance basis - it's only for use in custom
     * skins.
     *
     * @param minimumCellHeight New minimumCellHeight value. Default value is 20
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setMinimumCellHeight(int minimumCellHeight)  throws IllegalStateException {
        setAttribute("minimumCellHeight", minimumCellHeight, false);
    }

    /**
     * Minimum height for ListGrid cells, settable by the skin, based on the size of the  checkbox media used for boolean
     * fields plus minimal surrounding padding.   <code>minimumCellHeight</code> is used by {@link
     * com.smartgwt.client.widgets.Canvas#resizeControls Canvas.resizeControls()} to  avoid shrinking ListGrid rows so much
     * that correct display is impossible.   Do not set minimumCellHeight on a per-instance basis - it's only for use in custom
     * skins.
     *
     * @return Current minimumCellHeight value. Default value is 20
     */
    public int getMinimumCellHeight()  {
        return getAttributeAsInt("minimumCellHeight");
    }
    

    /**
     * If a summary format string contains an invalid field reference, replace the reference with the missingSummaryFieldValue.
     * The default value is "-".
     *
     * @param missingSummaryFieldValue New missingSummaryFieldValue value. Default value is "-"
     */
    public void setMissingSummaryFieldValue(String missingSummaryFieldValue) {
        setAttribute("missingSummaryFieldValue", missingSummaryFieldValue, true);
    }

    /**
     * If a summary format string contains an invalid field reference, replace the reference with the missingSummaryFieldValue.
     * The default value is "-".
     *
     * @return Current missingSummaryFieldValue value. Default value is "-"
     */
    public String getMissingSummaryFieldValue()  {
        return getAttributeAsString("missingSummaryFieldValue");
    }
    

    /**
     * If this property is true, any mouse click outside of the open cell editors      will end editing mode, hiding the cell
     * editors and saving any changes to those      cell values.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param modalEditing New modalEditing value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_modal" target="examples">Modal editing Example</a>
     */
    public void setModalEditing(Boolean modalEditing) {
        setAttribute("modalEditing", modalEditing, true);
    }

    /**
     * If this property is true, any mouse click outside of the open cell editors      will end editing mode, hiding the cell
     * editors and saving any changes to those      cell values.
     *
     * @return Current modalEditing value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_editing_modal" target="examples">Modal editing Example</a>
     */
    public Boolean getModalEditing()  {
        return getAttributeAsBoolean("modalEditing");
    }
    

    /**
     * Class-level defaults to apply to the {@link com.smartgwt.client.widgets.MultiGroupDialog} which gets automatically 
     * generated when {@link com.smartgwt.client.widgets.grid.ListGrid#configureGrouping configureGrouping()} is called.
     *
     * @param multiGroupDialogDefaults New multiGroupDialogDefaults value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setMultiGroupDialogDefaults(MultiGroupDialog multiGroupDialogDefaults)  throws IllegalStateException {
        if (multiGroupDialogDefaults != null) {
            if (multiGroupDialogDefaults.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, "setMultiGroupDialogDefaults", "MultiGroupDialog");
            }                                                                       
            multiGroupDialogDefaults.setConfigOnly(true);
        }
        JavaScriptObject config = multiGroupDialogDefaults == null ? null : multiGroupDialogDefaults.getConfig();
        setAttribute("multiGroupDialogDefaults", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Class-level defaults to apply to the {@link com.smartgwt.client.widgets.MultiGroupDialog} which gets automatically 
     * generated when {@link com.smartgwt.client.widgets.grid.ListGrid#configureGrouping configureGrouping()} is called.
     *
     * @return Current multiGroupDialogDefaults value. Default value is null
     */
    public MultiGroupDialog getMultiGroupDialogDefaults()  {
        MultiGroupDialog properties = new MultiGroupDialog();
        properties.setConfigOnly(true);
        properties.setConfig(getAttributeAsJavaScriptObject("multiGroupDialogDefaults"));
        return properties;
    }
    

    /**
     * Properties to apply to the {@link com.smartgwt.client.widgets.MultiGroupDialog} which gets automatically  generated when
     * {@link com.smartgwt.client.widgets.grid.ListGrid#configureGrouping configureGrouping()} is called.
     *
     * @param multiGroupDialogProperties New multiGroupDialogProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setMultiGroupDialogProperties(MultiGroupDialog multiGroupDialogProperties)  throws IllegalStateException {
        if (multiGroupDialogProperties != null) {
            if (multiGroupDialogProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, "setMultiGroupDialogProperties", "MultiGroupDialog");
            }                                                                       
            multiGroupDialogProperties.setConfigOnly(true);
        }
        JavaScriptObject config = multiGroupDialogProperties == null ? null : multiGroupDialogProperties.getConfig();
        setAttribute("multiGroupDialogProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Properties to apply to the {@link com.smartgwt.client.widgets.MultiGroupDialog} which gets automatically  generated when
     * {@link com.smartgwt.client.widgets.grid.ListGrid#configureGrouping configureGrouping()} is called.
     *
     * @return Current multiGroupDialogProperties value. Default value is null
     */
    public MultiGroupDialog getMultiGroupDialogProperties()  {
        MultiGroupDialog properties = new MultiGroupDialog();
        properties.setConfigOnly(true);
        properties.setConfig(getAttributeAsJavaScriptObject("multiGroupDialogProperties"));
        return properties;
    }
    
    
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true, this property allows the
     * user to navigate through the cells of a grid using Tab and Shift+Tab keypresses. When a user tabs to the end of the row,
     * the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowEndEditAction rowEndEditAction} is used to determine whether
     * to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab
     * order.
     *
     * @param navigateOnTab New navigateOnTab value. Default value is true
     */
    public void setNavigateOnTab(boolean navigateOnTab) {
        setAttribute("navigateOnTab", navigateOnTab, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true, this property allows the
     * user to navigate through the cells of a grid using Tab and Shift+Tab keypresses. When a user tabs to the end of the row,
     * the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowEndEditAction rowEndEditAction} is used to determine whether
     * to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab
     * order.
     *
     * @return Current navigateOnTab value. Default value is true
     */
    public boolean getNavigateOnTab()  {
        Boolean result = getAttributeAsBoolean("navigateOnTab");
        return result == null ? true : result;
    }
    

    /**
     * If true, validation will not occur as a result of cell editing for this grid.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param neverValidate New neverValidate value. Default value is null
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public void setNeverValidate(Boolean neverValidate) {
        setAttribute("neverValidate", neverValidate, true);
    }

    /**
     * If true, validation will not occur as a result of cell editing for this grid.
     *
     * @return Current neverValidate value. Default value is null
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public Boolean getNeverValidate()  {
        return getAttributeAsBoolean("neverValidate");
    }
    

    /**
     * "Normal" baseStyle for this listGrid. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} is set to null. <P> If <code>baseStyle</code> is unset, this property will be used as a base cell style if
     * the grid is showing fixed height rows, and the specified cellHeight matches {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight normalCellHeight} (and in Internet Explorer, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} is false). Otherwise {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} will be used. <P> Having separate styles
     * defined for fixed vs. variable height rows allows the developer to specify css which is designed to render at a specific
     * height (typically using background images, which won't scale), without breaking support for styling rows of variable
     * height. <P> See {@link com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are combined
     * with the base style to generate stateful cell styles.
     *
     * @param normalBaseStyle New normalBaseStyle value. Default value is "cell"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setNormalBaseStyle(String normalBaseStyle)  throws IllegalStateException {
        setAttribute("normalBaseStyle", normalBaseStyle, false);
    }

    /**
     * "Normal" baseStyle for this listGrid. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} is set to null. <P> If <code>baseStyle</code> is unset, this property will be used as a base cell style if
     * the grid is showing fixed height rows, and the specified cellHeight matches {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight normalCellHeight} (and in Internet Explorer, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} is false). Otherwise {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} will be used. <P> Having separate styles
     * defined for fixed vs. variable height rows allows the developer to specify css which is designed to render at a specific
     * height (typically using background images, which won't scale), without breaking support for styling rows of variable
     * height. <P> See {@link com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are combined
     * with the base style to generate stateful cell styles.
     *
     * @return Current normalBaseStyle value. Default value is "cell"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getNormalBaseStyle()  {
        return getAttributeAsString("normalBaseStyle");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} is unset, base style will be derived from
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} if this grid has fixed row heights
     * and the specified {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} matches this value.
     * Otherwise {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} will be used.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param normalCellHeight New normalCellHeight value. Default value is 20
     */
    public void setNormalCellHeight(int normalCellHeight) {
        setAttribute("normalCellHeight", normalCellHeight, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} is unset, base style will be derived from
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} if this grid has fixed row heights
     * and the specified {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} matches this value.
     * Otherwise {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle tallBaseStyle} will be used.
     *
     * @return Current normalCellHeight value. Default value is 20
     */
    public int getNormalCellHeight()  {
        return getAttributeAsInt("normalCellHeight");
    }
    

    /**
     * Default alias to use for groups with no value
     *
     * @param nullGroupTitle New nullGroupTitle value. Default value is '-none-'
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setNullGroupTitle(String nullGroupTitle) {
        setAttribute("nullGroupTitle", nullGroupTitle, true);
    }

    /**
     * Default alias to use for groups with no value
     *
     * @return Current nullGroupTitle value. Default value is '-none-'
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public String getNullGroupTitle()  {
        return getAttributeAsString("nullGroupTitle");
    }
    

    /**
     * The CSS style name applied to the {@link com.smartgwt.client.widgets.DataBoundComponent#getOfflineMessage
     * offlineMessage} if displayed.
     *
     * @param offlineMessageStyle New offlineMessageStyle value. Default value is "offlineMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setOfflineMessageStyle(String offlineMessageStyle) {
        setAttribute("offlineMessageStyle", offlineMessageStyle, true);
    }

    /**
     * The CSS style name applied to the {@link com.smartgwt.client.widgets.DataBoundComponent#getOfflineMessage
     * offlineMessage} if displayed.
     *
     * @return Current offlineMessageStyle value. Default value is "offlineMessage"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getOfflineMessageStyle()  {
        return getAttributeAsString("offlineMessageStyle");
    }
    

    /**
     * <b>Note :</b> This API is non-functional (always returns null) and exists only to make
     * you aware that this MultiAutoChild exists.  See {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}
     * for details.
     * <p>
     * Inline icon shown inside {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter editor} fields when
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} is enabled.
     *
     * @return null
     */
    public FormItemIcon getOperatorIcon()  {
        return null;
    }
    
    

    /**
     * Name of a CSS Style to use as the {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} for a cell
     * that is currently a selection origin for shifted incremental cell selection. Only has an effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true. <P>
     *
     * @param originBaseStyle New originBaseStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setOriginBaseStyle(String originBaseStyle) {
        setAttribute("originBaseStyle", originBaseStyle, true);
    }

    /**
     * Name of a CSS Style to use as the {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} for a cell
     * that is currently a selection origin for shifted incremental cell selection. Only has an effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true. <P>
     *
     * @return Current originBaseStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getOriginBaseStyle()  {
        return getAttributeAsString("originBaseStyle");
    }
    

    /**
     * Since {@link com.smartgwt.client.widgets.grid.ListGrid#getBody body} is configured with overflow: auto by default, no
     * overflow is expected for the {@link com.smartgwt.client.widgets.grid.ListGrid} itself so by default it has overflow:
     * hidden.
     *
     * @param overflow New overflow value. Default value is Canvas.HIDDEN
     * @see com.smartgwt.client.widgets.layout.Layout#setOverflow
     */
    public void setOverflow(Overflow overflow) {
        setAttribute("overflow", overflow == null ? null : overflow.getValue(), true);
    }

    /**
     * Since {@link com.smartgwt.client.widgets.grid.ListGrid#getBody body} is configured with overflow: auto by default, no
     * overflow is expected for the {@link com.smartgwt.client.widgets.grid.ListGrid} itself so by default it has overflow:
     * hidden.
     *
     * @return Current overflow value. Default value is Canvas.HIDDEN
     * @see com.smartgwt.client.widgets.layout.Layout#getOverflow
     */
    public Overflow getOverflow()  {
        return EnumUtil.getEnum(Overflow.values(), getAttribute("overflow"));
    }
    

    /**
     * Should recycled {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents record components}, be pooled
     * per column or per record. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * showRecordComponentsByCell} is true. <P> When {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode recordComponentPoolingMode} is "recycle" and you
     * have components of different types in different columns, set this property to true to ensure that components intended
     * for one column are not recycled for use in another column that should have a different component. <P> If no components
     * applicable to a particular column are available in the pool, the system calls {@link
     * com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent createRecordComponent}.
     *
     * @param poolComponentsPerColumn New poolComponentsPerColumn value. Default value is true
     */
    public void setPoolComponentsPerColumn(Boolean poolComponentsPerColumn) {
        setAttribute("poolComponentsPerColumn", poolComponentsPerColumn, true);
    }

    /**
     * Should recycled {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents record components}, be pooled
     * per column or per record. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * showRecordComponentsByCell} is true. <P> When {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode recordComponentPoolingMode} is "recycle" and you
     * have components of different types in different columns, set this property to true to ensure that components intended
     * for one column are not recycled for use in another column that should have a different component. <P> If no components
     * applicable to a particular column are available in the pool, the system calls {@link
     * com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent createRecordComponent}.
     *
     * @return Current poolComponentsPerColumn value. Default value is true
     */
    public Boolean getPoolComponentsPerColumn()  {
        Boolean result = getAttributeAsBoolean("poolComponentsPerColumn");
        return result == null ? true : result;
    }
    

    /**
     * Should cells be written out with css that will preserve whitespace? <P> If true, depending on the value of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapCells}, the css generated for cells will use the <a
     * href='https://www.w3.org/wiki/CSS/Properties/white-space#Values' target='_blank'>white-space</a> property values of
     * <code>pre</code> or <code>pre-wrap</code>. This avoids collapsing sequences of whitespace without requiring special
     * <i>&amp;nbsp;</i> characters.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param preserveWhitespace New preserveWhitespace value. Default value is false
     */
    public void setPreserveWhitespace(Boolean preserveWhitespace) {
        setAttribute("preserveWhitespace", preserveWhitespace, true);
    }

    /**
     * Should cells be written out with css that will preserve whitespace? <P> If true, depending on the value of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapCells}, the css generated for cells will use the <a
     * href='https://www.w3.org/wiki/CSS/Properties/white-space#Values' target='_blank'>white-space</a> property values of
     * <code>pre</code> or <code>pre-wrap</code>. This avoids collapsing sequences of whitespace without requiring special
     * <i>&amp;nbsp;</i> characters.
     *
     * @return Current preserveWhitespace value. Default value is false
     */
    public Boolean getPreserveWhitespace()  {
        Boolean result = getAttributeAsBoolean("preserveWhitespace");
        return result == null ? false : result;
    }
    

    /**
     * Whether cell contents should wrap during printing.  Equivalent to {@link com.smartgwt.client.types.Autofit}, but
     * specific to printed output.
     *
     * @param printAutoFit New printAutoFit value. Default value is true
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintAutoFit(Boolean printAutoFit) {
        setAttribute("printAutoFit", printAutoFit, true);
    }

    /**
     * Whether cell contents should wrap during printing.  Equivalent to {@link com.smartgwt.client.types.Autofit}, but
     * specific to printed output.
     *
     * @return Current printAutoFit value. Default value is true
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public Boolean getPrintAutoFit()  {
        Boolean result = getAttributeAsBoolean("printAutoFit");
        return result == null ? true : result;
    }
    

    /**
     * Style for non-header cells in printed output.  Defaults to {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} if null.
     *
     * @param printBaseStyle New printBaseStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintBaseStyle(String printBaseStyle) {
        setAttribute("printBaseStyle", printBaseStyle, true);
    }

    /**
     * Style for non-header cells in printed output.  Defaults to {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} if null.
     *
     * @return Current printBaseStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintBaseStyle()  {
        return getAttributeAsString("printBaseStyle");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} to use when {@link
     * com.smartgwt.client.docs.Printing printing}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printBooleanBaseStyle New printBooleanBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintBooleanBaseStyle(String printBooleanBaseStyle)  throws IllegalStateException {
        setAttribute("printBooleanBaseStyle", printBooleanBaseStyle, false);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle booleanBaseStyle} to use when {@link
     * com.smartgwt.client.docs.Printing printing}.
     *
     * @return Current printBooleanBaseStyle value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintBooleanBaseStyle()  {
        return getAttributeAsString("printBooleanBaseStyle");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} to use when {@link
     * com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanTrueImage printBooleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanPartialImage printBooleanPartialImage} are unset, this will be
     * set to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintUncheckedImage
     * CheckboxItem.printUncheckedImage}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printBooleanFalseImage New printBooleanFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintBooleanFalseImage(String printBooleanFalseImage) {
        setAttribute("printBooleanFalseImage", printBooleanFalseImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage booleanFalseImage} to use when {@link
     * com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanTrueImage printBooleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanPartialImage printBooleanPartialImage} are unset, this will be
     * set to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintUncheckedImage
     * CheckboxItem.printUncheckedImage}.
     *
     * @return Current printBooleanFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintBooleanFalseImage()  {
        return getAttributeAsString("printBooleanFalseImage");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} to use when
     * {@link com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanTrueImage printBooleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanFalseImage printBooleanFalseImage} are unset, this will be set
     * to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintPartialSelectedImage
     * CheckboxItem.printPartialSelectedImage}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printBooleanPartialImage New printBooleanPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintBooleanPartialImage(String printBooleanPartialImage) {
        setAttribute("printBooleanPartialImage", printBooleanPartialImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage booleanPartialImage} to use when
     * {@link com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanTrueImage printBooleanTrueImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanFalseImage printBooleanFalseImage} are unset, this will be set
     * to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintPartialSelectedImage
     * CheckboxItem.printPartialSelectedImage}.
     *
     * @return Current printBooleanPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintBooleanPartialImage()  {
        return getAttributeAsString("printBooleanPartialImage");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} to use when {@link
     * com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanFalseImage printBooleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanPartialImage printBooleanPartialImage} are unset, this will be
     * set to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintCheckedImage
     * CheckboxItem.printCheckedImage}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printBooleanTrueImage New printBooleanTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBooleanTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintBooleanTrueImage(String printBooleanTrueImage) {
        setAttribute("printBooleanTrueImage", printBooleanTrueImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage booleanTrueImage} to use when {@link
     * com.smartgwt.client.docs.Printing printing}. <p> If this, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanFalseImage printBooleanFalseImage} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getPrintBooleanPartialImage printBooleanPartialImage} are unset, this will be
     * set to the default {@link com.smartgwt.client.widgets.form.fields.CheckboxItem#getPrintCheckedImage
     * CheckboxItem.printCheckedImage}.
     *
     * @return Current printBooleanTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBooleanTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintBooleanTrueImage()  {
        return getAttributeAsString("printBooleanTrueImage");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldFalseImage checkboxFieldFalseImage} to use
     * when {@link com.smartgwt.client.docs.Printing printing}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printCheckboxFieldFalseImage New printCheckboxFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintCheckboxFieldFalseImage(String printCheckboxFieldFalseImage) {
        setAttribute("printCheckboxFieldFalseImage", printCheckboxFieldFalseImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldFalseImage checkboxFieldFalseImage} to use
     * when {@link com.smartgwt.client.docs.Printing printing}.
     *
     * @return Current printCheckboxFieldFalseImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldFalseImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintCheckboxFieldFalseImage()  {
        return getAttributeAsString("printCheckboxFieldFalseImage");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldPartialImage checkboxFieldPartialImage} to
     * use when {@link com.smartgwt.client.docs.Printing printing}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printCheckboxFieldPartialImage New printCheckboxFieldPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintCheckboxFieldPartialImage(String printCheckboxFieldPartialImage) {
        setAttribute("printCheckboxFieldPartialImage", printCheckboxFieldPartialImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldPartialImage checkboxFieldPartialImage} to
     * use when {@link com.smartgwt.client.docs.Printing printing}.
     *
     * @return Current printCheckboxFieldPartialImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldPartialImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintCheckboxFieldPartialImage()  {
        return getAttributeAsString("printCheckboxFieldPartialImage");
    }
    

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldTrueImage checkboxFieldTrueImage} to use
     * when {@link com.smartgwt.client.docs.Printing printing}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printCheckboxFieldTrueImage New printCheckboxFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCheckboxFieldTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintCheckboxFieldTrueImage(String printCheckboxFieldTrueImage) {
        setAttribute("printCheckboxFieldTrueImage", printCheckboxFieldTrueImage, true);
    }

    /**
     * If set, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldTrueImage checkboxFieldTrueImage} to use
     * when {@link com.smartgwt.client.docs.Printing printing}.
     *
     * @return Current printCheckboxFieldTrueImage value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCheckboxFieldTrueImage
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintCheckboxFieldTrueImage()  {
        return getAttributeAsString("printCheckboxFieldTrueImage");
    }
    

    /**
     * Style for header cells in printed output.  Defaults to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderBaseStyle headerBaseStyle} if null.
     *
     * @param printHeaderStyle New printHeaderStyle value. Default value is "printHeader"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintHeaderStyle(String printHeaderStyle) {
        setAttribute("printHeaderStyle", printHeaderStyle, true);
    }

    /**
     * Style for header cells in printed output.  Defaults to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderBaseStyle headerBaseStyle} if null.
     *
     * @return Current printHeaderStyle value. Default value is "printHeader"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public String getPrintHeaderStyle()  {
        return getAttributeAsString("printHeaderStyle");
    }
    

    /**
     * Advanced property - when generating printHTML for a large ListGrid, rows are printed in batches in order to avoid
     * triggering a native "script is running slowly" browser dialog. <P> For grids with exceptional numbers of columns or
     * complex formatting logic, this number might need to be adjusted downward.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param printMaxRows New printMaxRows value. Default value is 100
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintMaxRows(int printMaxRows) {
        setAttribute("printMaxRows", printMaxRows, true);
    }

    /**
     * Advanced property - when generating printHTML for a large ListGrid, rows are printed in batches in order to avoid
     * triggering a native "script is running slowly" browser dialog. <P> For grids with exceptional numbers of columns or
     * complex formatting logic, this number might need to be adjusted downward.
     *
     * @return Current printMaxRows value. Default value is 100
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public int getPrintMaxRows()  {
        return getAttributeAsInt("printMaxRows");
    }
    

    /**
     * Whether cell contents should wrap during printing.  Equivalent to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapCells}, but specific to printed output.
     *
     * @param printWrapCells New printWrapCells value. Default value is true
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public void setPrintWrapCells(Boolean printWrapCells) {
        setAttribute("printWrapCells", printWrapCells, true);
    }

    /**
     * Whether cell contents should wrap during printing.  Equivalent to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapCells}, but specific to printed output.
     *
     * @return Current printWrapCells value. Default value is true
     * @see com.smartgwt.client.docs.Printing Printing overview and related methods
     */
    public Boolean getPrintWrapCells()  {
        Boolean result = getAttributeAsBoolean("printWrapCells");
        return result == null ? true : result;
    }
    

    /**
     * Alternative to {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio}, to be used when the
     * user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio} will be used in all cases
     *
     * @param quickDrawAheadRatio New quickDrawAheadRatio value. Default value is 2.0
     */
    public void setQuickDrawAheadRatio(float quickDrawAheadRatio) {
        setAttribute("quickDrawAheadRatio", quickDrawAheadRatio, true);
    }

    /**
     * Alternative to {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio}, to be used when the
     * user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio} will be used in all cases
     *
     * @return Current quickDrawAheadRatio value. Default value is 2.0
     */
    public float getQuickDrawAheadRatio()  {
        return getAttributeAsFloat("quickDrawAheadRatio");
    }
    

    /**
     * This attribute allows custom base styles to be displayed on a per-record basis. To specify a custom base-style for some
     * record set <code>record[listGrid.recordBaseStyleProperty]</code> to the desired base style name - for example if
     * <code>recordBaseStyleProperty</code> is <code>"_baseStyle"</code>, set <code>record._baseStyle</code> to the custom base
     * style name.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordBaseStyleProperty New recordBaseStyleProperty value. Default value is "_baseStyle"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setRecordBaseStyleProperty(String recordBaseStyleProperty) {
        setAttribute("recordBaseStyleProperty", recordBaseStyleProperty, true);
    }

    /**
     * This attribute allows custom base styles to be displayed on a per-record basis. To specify a custom base-style for some
     * record set <code>record[listGrid.recordBaseStyleProperty]</code> to the desired base style name - for example if
     * <code>recordBaseStyleProperty</code> is <code>"_baseStyle"</code>, set <code>record._baseStyle</code> to the custom base
     * style name.
     *
     * @return Current recordBaseStyleProperty value. Default value is "_baseStyle"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getRecordBaseStyleProperty()  {
        return getAttributeAsString("recordBaseStyleProperty");
    }
    

    /**
     * If set to false on a record and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}
     * is true, removal of that record is disallowed in the UI. The icon in the remove field is not shown.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordCanRemoveProperty New recordCanRemoveProperty value. Default value is "_canRemove"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setRecordCanRemoveProperty(String recordCanRemoveProperty)  throws IllegalStateException {
        setAttribute("recordCanRemoveProperty", recordCanRemoveProperty, false);
    }

    /**
     * If set to false on a record and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}
     * is true, removal of that record is disallowed in the UI. The icon in the remove field is not shown.
     *
     * @return Current recordCanRemoveProperty value. Default value is "_canRemove"
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getRecordCanRemoveProperty()  {
        return getAttributeAsString("recordCanRemoveProperty");
    }
    

    /**
     * If set to false on a record, selection of that record is disallowed.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordCanSelectProperty New recordCanSelectProperty value. Default value is "canSelect"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setRecordCanSelectProperty(String recordCanSelectProperty)  throws IllegalStateException {
        setAttribute("recordCanSelectProperty", recordCanSelectProperty, false);
    }

    /**
     * If set to false on a record, selection of that record is disallowed.
     *
     * @return Current recordCanSelectProperty value. Default value is "canSelect"
     */
    public String getRecordCanSelectProperty()  {
        return getAttributeAsString("recordCanSelectProperty");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, this
     * attribute may be used to specify a standard height for record components. If specified every row in the grid will be
     * sized tall enough to accommodate a recordComponent of this size. <P> Note that if this property is unset, the grid will
     * not be able to know row heights in advance, and {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen
     * fields} are not currently supported in this case.  If you are putting a recordComponent in every row, and they all have
     * a consistent height, set <code>recordComponentHeight</code> and you will then be able to use frozen fields <i>and</i>
     * avoid the whitespace side-effect of virtual scrolling by setting  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling}:false. <P> Similarly, if your
     * recordComponents are never tall enough that they will expand the row beyond the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight}, set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling}:false to avoid the whitespace
     * side-effect of {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtual scrolling} and to allow 
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields} to be used.  In this mode, you can have
     * recordComponents on some rows but not others, and recordComponents of different heights, so long as no recordComponent
     * ever causes a row to grow beyond {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} (which would
     * happen if the recordComponents height + 2*{@link com.smartgwt.client.widgets.grid.ListGrid#getCellPadding cellPadding}
     * is larger than  {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight}).
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentHeight recordComponentHeight}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordComponentHeight recordComponent height. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setVirtualScrolling
     */
    public void setRecordComponentHeight(Integer recordComponentHeight) {
        setAttribute("recordComponentHeight", recordComponentHeight, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, this
     * attribute may be used to specify a standard height for record components. If specified every row in the grid will be
     * sized tall enough to accommodate a recordComponent of this size. <P> Note that if this property is unset, the grid will
     * not be able to know row heights in advance, and {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen
     * fields} are not currently supported in this case.  If you are putting a recordComponent in every row, and they all have
     * a consistent height, set <code>recordComponentHeight</code> and you will then be able to use frozen fields <i>and</i>
     * avoid the whitespace side-effect of virtual scrolling by setting  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling}:false. <P> Similarly, if your
     * recordComponents are never tall enough that they will expand the row beyond the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight}, set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling}:false to avoid the whitespace
     * side-effect of {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtual scrolling} and to allow 
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields} to be used.  In this mode, you can have
     * recordComponents on some rows but not others, and recordComponents of different heights, so long as no recordComponent
     * ever causes a row to grow beyond {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight} (which would
     * happen if the recordComponents height + 2*{@link com.smartgwt.client.widgets.grid.ListGrid#getCellPadding cellPadding}
     * is larger than  {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight cellHeight}).
     *
     * @return Current recordComponentHeight value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling
     */
    public Integer getRecordComponentHeight()  {
        return getAttributeAsInt("recordComponentHeight");
    }
    

    /**
     * The method of {@link com.smartgwt.client.types.RecordComponentPoolingMode component-pooling} to employ for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents}. <P> The default mode is "viewport",
     * which means that recordComponents are destroyed as soon their record is no longer being rendered (scrolled out of the
     * viewport, eliminated by search criteria, etc). <P> For a large or dynamic data set where the components shown on
     * different rows are similar, switch to "recycle" mode, which pools recordComponents by detaching them from records that
     * are not visible and re-using them in other records.  In this mode, you should implement {@link
     * com.smartgwt.client.widgets.grid.ListGrid#updateRecordComponent updateRecordComponent()} to apply any changes to make
     * reused components applicable to the new record they appear in, if necessary.  For example, if you have several controls
     * in your <code>recordComponents</code>, and not all of the controls apply to every record, your
     * <code>updateRecordComponent()</code> implementation could simply hide or disable inapplicable controls, and this would
     * be much faster than creating a whole new set of controls every time a given record is scrolled into view. <p> If you are
     * using {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell per-cell recordComponents}, and you
     * have components of different types in different columns and still want to take advantage of component recycling, you can
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getPoolComponentsPerColumn poolComponentsPerColumn} to ensure that
     * components intended for one column are not recycled for use in another column that should have a different component.
     * <P> Note that, if different records have distinctly different components embedded in them, or multiple columns in each
     * record embed different components, you should leave the recordComponentPoolingMode at "viewport" if your dataset is very
     * large or use "data" otherwise.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordComponentPoolingMode New recordComponentPoolingMode value. Default value is "viewport"
     */
    public void setRecordComponentPoolingMode(RecordComponentPoolingMode recordComponentPoolingMode) {
        setAttribute("recordComponentPoolingMode", recordComponentPoolingMode == null ? null : recordComponentPoolingMode.getValue(), true);
    }

    /**
     * The method of {@link com.smartgwt.client.types.RecordComponentPoolingMode component-pooling} to employ for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents}. <P> The default mode is "viewport",
     * which means that recordComponents are destroyed as soon their record is no longer being rendered (scrolled out of the
     * viewport, eliminated by search criteria, etc). <P> For a large or dynamic data set where the components shown on
     * different rows are similar, switch to "recycle" mode, which pools recordComponents by detaching them from records that
     * are not visible and re-using them in other records.  In this mode, you should implement {@link
     * com.smartgwt.client.widgets.grid.ListGrid#updateRecordComponent updateRecordComponent()} to apply any changes to make
     * reused components applicable to the new record they appear in, if necessary.  For example, if you have several controls
     * in your <code>recordComponents</code>, and not all of the controls apply to every record, your
     * <code>updateRecordComponent()</code> implementation could simply hide or disable inapplicable controls, and this would
     * be much faster than creating a whole new set of controls every time a given record is scrolled into view. <p> If you are
     * using {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell per-cell recordComponents}, and you
     * have components of different types in different columns and still want to take advantage of component recycling, you can
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getPoolComponentsPerColumn poolComponentsPerColumn} to ensure that
     * components intended for one column are not recycled for use in another column that should have a different component.
     * <P> Note that, if different records have distinctly different components embedded in them, or multiple columns in each
     * record embed different components, you should leave the recordComponentPoolingMode at "viewport" if your dataset is very
     * large or use "data" otherwise.
     *
     * @return Current recordComponentPoolingMode value. Default value is "viewport"
     */
    public RecordComponentPoolingMode getRecordComponentPoolingMode()  {
        return EnumUtil.getEnum(RecordComponentPoolingMode.values(), getAttribute("recordComponentPoolingMode"));
    }
    

    /**
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, how should
     * the component appear within the cell. Valid options are <ul><li><code>"within"</code>: the component will be rendered
     * inside the record / cell.  {@link com.smartgwt.client.widgets.Canvas#getSnapTo Canvas.snapTo} may be set to specify
     * where the component should render within  the row or cell, and {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetTop Canvas.snapOffsetTop} / {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetLeft Canvas.snapOffsetLeft} may  be set to indent recordComponents
     * within their parent cells.  Note that if unset, the component will show up at the top/left edge  for components embedded
     * within an entire row, or for per-cell components, cell  align and valign will be respected.  Note also that, when
     * rendering components "within"  cells, specified component heights will be respected and will change the height of the 
     * row.  However, if you want components to completely fill a cell at it's default height,  set height: "100%" or rows will
     * render at the default height of the component. </li> <li><code>"expand"</code>: the component will be written into the
     * cell below the  normal cell content, causing the cell to expand vertically to accommodate it. <li><code>null</code>: If
     * this attribute is unset, we will default to showing  recordComponents with position <code>"within"</code> if  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} is true, otherwise
     * using <code>"expand"</code>  logic. </ul>
     *
     * @param recordComponentPosition New recordComponentPosition value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowRecordComponents
     */
    public void setRecordComponentPosition(EmbeddedPosition recordComponentPosition) {
        setAttribute("recordComponentPosition", recordComponentPosition == null ? null : recordComponentPosition.getValue(), true);
    }

    /**
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, how should
     * the component appear within the cell. Valid options are <ul><li><code>"within"</code>: the component will be rendered
     * inside the record / cell.  {@link com.smartgwt.client.widgets.Canvas#getSnapTo Canvas.snapTo} may be set to specify
     * where the component should render within  the row or cell, and {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetTop Canvas.snapOffsetTop} / {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetLeft Canvas.snapOffsetLeft} may  be set to indent recordComponents
     * within their parent cells.  Note that if unset, the component will show up at the top/left edge  for components embedded
     * within an entire row, or for per-cell components, cell  align and valign will be respected.  Note also that, when
     * rendering components "within"  cells, specified component heights will be respected and will change the height of the 
     * row.  However, if you want components to completely fill a cell at it's default height,  set height: "100%" or rows will
     * render at the default height of the component. </li> <li><code>"expand"</code>: the component will be written into the
     * cell below the  normal cell content, causing the cell to expand vertically to accommodate it. <li><code>null</code>: If
     * this attribute is unset, we will default to showing  recordComponents with position <code>"within"</code> if  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} is true, otherwise
     * using <code>"expand"</code>  logic. </ul>
     *
     * @return Current recordComponentPosition value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents
     */
    public EmbeddedPosition getRecordComponentPosition()  {
        return EnumUtil.getEnum(EmbeddedPosition.values(), getAttribute("recordComponentPosition"));
    }
    
    

    /**
     * The name of the ListGridRecord property that specifies the DataSource to use when {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is "related".  The default is {@link
     * com.smartgwt.client.widgets.grid.ListGridRecord#getDetailDS ListGridRecord.detailDS}. Note that you can set the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDetailDS detailDS} at the grid level instead if the same dataSource is to
     * be used for all records.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordDetailDSProperty New recordDetailDSProperty value. Default value is "detailDS"
     */
    public void setRecordDetailDSProperty(String recordDetailDSProperty) {
        setAttribute("recordDetailDSProperty", recordDetailDSProperty, true);
    }

    /**
     * The name of the ListGridRecord property that specifies the DataSource to use when {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is "related".  The default is {@link
     * com.smartgwt.client.widgets.grid.ListGridRecord#getDetailDS ListGridRecord.detailDS}. Note that you can set the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDetailDS detailDS} at the grid level instead if the same dataSource is to
     * be used for all records.
     *
     * @return Current recordDetailDSProperty value. Default value is "detailDS"
     */
    public String getRecordDetailDSProperty()  {
        return getAttributeAsString("recordDetailDSProperty");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAcceptDroppedRecords canAcceptDroppedRecords} is true for this
     * listGrid, this property governs whether the user can drop between, or over records within the grid. This controls what
     * {@link com.smartgwt.client.types.RecordDropPosition} is passed to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recordDrop recordDrop()} event handler.
     *
     * @param recordDropAppearance New recordDropAppearance value. Default value is ListGrid.BETWEEN
     */
    public void setRecordDropAppearance(RecordDropAppearance recordDropAppearance) {
        setAttribute("recordDropAppearance", recordDropAppearance == null ? null : recordDropAppearance.getValue(), true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAcceptDroppedRecords canAcceptDroppedRecords} is true for this
     * listGrid, this property governs whether the user can drop between, or over records within the grid. This controls what
     * {@link com.smartgwt.client.types.RecordDropPosition} is passed to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recordDrop recordDrop()} event handler.
     *
     * @return Current recordDropAppearance value. Default value is ListGrid.BETWEEN
     */
    public RecordDropAppearance getRecordDropAppearance()  {
        return EnumUtil.getEnum(RecordDropAppearance.values(), getAttribute("recordDropAppearance"));
    }
    

    /**
     * Property name on a record that should be checked to determine whether the record may be edited. <br> This property is
     * configurable to avoid possible collision with data values in record. With the default setting of "_canEdit", a record
     * can be set non-editable by ensuring record._canEdit == false. <br> For controlling editability for the entire grid or
     * for a field, set grid.canEdit or field.canEdit.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordEditProperty New recordEditProperty value. Default value is "_canEdit"
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGridField#setCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setRecordEditProperty(String recordEditProperty) {
        setAttribute("recordEditProperty", recordEditProperty, true);
    }

    /**
     * Property name on a record that should be checked to determine whether the record may be edited. <br> This property is
     * configurable to avoid possible collision with data values in record. With the default setting of "_canEdit", a record
     * can be set non-editable by ensuring record._canEdit == false. <br> For controlling editability for the entire grid or
     * for a field, set grid.canEdit or field.canEdit.
     *
     * @return Current recordEditProperty value. Default value is "_canEdit"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGridField#getCanEdit
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public String getRecordEditProperty()  {
        return getAttributeAsString("recordEditProperty");
    }
    

    /**
     * Property name on a record that will be checked to determine whether a record is enabled. <P> Setting this property on a
     * record will effect the visual style and interactivity of the record.  If set to <code>false</code> the record (row in a
     * {@link com.smartgwt.client.widgets.grid.ListGrid} or {@link com.smartgwt.client.widgets.tree.TreeGrid}) will not
     * highlight when the mouse moves over it, nor will it respond to mouse clicks.
     *
     * @param recordEnabledProperty New recordEnabledProperty value. Default value is "enabled"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#setEnabled
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_disabled_rows" target="examples">Disabled rows Example</a>
     */
    public void setRecordEnabledProperty(String recordEnabledProperty)  throws IllegalStateException {
        setAttribute("recordEnabledProperty", recordEnabledProperty, false);
    }

    /**
     * Property name on a record that will be checked to determine whether a record is enabled. <P> Setting this property on a
     * record will effect the visual style and interactivity of the record.  If set to <code>false</code> the record (row in a
     * {@link com.smartgwt.client.widgets.grid.ListGrid} or {@link com.smartgwt.client.widgets.tree.TreeGrid}) will not
     * highlight when the mouse moves over it, nor will it respond to mouse clicks.
     *
     * @return Current recordEnabledProperty value. Default value is "enabled"
     * @see com.smartgwt.client.widgets.grid.ListGridRecord#getEnabled
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_disabled_rows" target="examples">Disabled rows Example</a>
     */
    public String getRecordEnabledProperty()  {
        return getAttributeAsString("recordEnabledProperty");
    }
    

    /**
     * If showing any record summary fields (IE: fields of {@link com.smartgwt.client.types.ListGridFieldType type:"summary"}),
     * this attribute specifies a custom base style to apply to cells in the summary field
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param recordSummaryBaseStyle New recordSummaryBaseStyle value. Default value is "recordSummaryCell"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setRecordSummaryBaseStyle(String recordSummaryBaseStyle) {
        setAttribute("recordSummaryBaseStyle", recordSummaryBaseStyle, true);
    }

    /**
     * If showing any record summary fields (IE: fields of {@link com.smartgwt.client.types.ListGridFieldType type:"summary"}),
     * this attribute specifies a custom base style to apply to cells in the summary field
     *
     * @return Current recordSummaryBaseStyle value. Default value is "recordSummaryCell"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getRecordSummaryBaseStyle()  {
        return getAttributeAsString("recordSummaryBaseStyle");
    }
    

    /**
     * Custom CSS text to be applied to records that have been {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved marked for removal}. <P> This CSS text will be applied on
     * top of standard disabled styling for the cell.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param removedCSSText New removedCSSText value. Default value is "text-decoration:line-through;"
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setRemovedCSSText(String removedCSSText) {
        setAttribute("removedCSSText", removedCSSText, true);
    }

    /**
     * Custom CSS text to be applied to records that have been {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved marked for removal}. <P> This CSS text will be applied on
     * top of standard disabled styling for the cell.
     *
     * @return Current removedCSSText value. Default value is "text-decoration:line-through;"
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getRemovedCSSText()  {
        return getAttributeAsString("removedCSSText");
    }
    
    

    /**
     * Configuration properties for the "remove field" displayed when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled.
     *
     * @param removeFieldProperties New removeFieldProperties value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setRemoveFieldProperties(ListGridField removeFieldProperties)  throws IllegalStateException {
        JavaScriptObject config = JSOHelper.createObject();
        if (removeFieldProperties != null) {
            JSOHelper.addProperties(config, removeFieldProperties.getJsObj());
        }
        setAttribute("removeFieldProperties", removeFieldProperties == null ? null : config, false);
    }

    /**
     * Configuration properties for the "remove field" displayed when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled.
     *
     * @return Current removeFieldProperties value. Default value is null
     */
    public ListGridField getRemoveFieldProperties()  {
        return ListGridField.getOrCreateRef(getAttributeAsJavaScriptObject("removeFieldProperties"));
    }
    

    /**
     * The title to use for the {@link com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldDefaults remove field}. <P> By
     * default this title is not displayed in the remove column header button as the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldDefaults removeFieldDefaults} sets {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowTitle ListGridField.showTitle} to <code>false</code>.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param removeFieldTitle New removeFieldTitle value. Default value is "&amp;nbsp;"
     */
    public void setRemoveFieldTitle(String removeFieldTitle) {
        setAttribute("removeFieldTitle", removeFieldTitle, true);
    }

    /**
     * The title to use for the {@link com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldDefaults remove field}. <P> By
     * default this title is not displayed in the remove column header button as the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemoveFieldDefaults removeFieldDefaults} sets {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowTitle ListGridField.showTitle} to <code>false</code>.
     *
     * @return Current removeFieldTitle value. Default value is "&amp;nbsp;"
     */
    public String getRemoveFieldTitle()  {
        return getAttributeAsString("removeFieldTitle");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, default icon to
     * show in the auto-generated field that allows removing records.
     *
     * @param removeIcon New removeIcon value. Default value is "[SKIN]/actions/remove.png"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setRemoveIcon(String removeIcon)  throws IllegalStateException {
        setAttribute("removeIcon", removeIcon, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, default icon to
     * show in the auto-generated field that allows removing records.
     *
     * @return Current removeIcon value. Default value is "[SKIN]/actions/remove.png"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getRemoveIcon()  {
        return getAttributeAsString("removeIcon");
    }
    

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon remove icons} for this
     * ListGrid.
     *
     * @param removeIconSize New removeIconSize value. Default value is 16
     */
    public void setRemoveIconSize(int removeIconSize) {
        setAttribute("removeIconSize", removeIconSize, true);
    }

    /**
     * Default width and height of {@link com.smartgwt.client.widgets.grid.ListGrid#getRemoveIcon remove icons} for this
     * ListGrid.
     *
     * @return Current removeIconSize value. Default value is 16
     */
    public int getRemoveIconSize()  {
        return getAttributeAsInt("removeIconSize");
    }
    

    /**
     * If true, when an update operation occurs on a selected record in a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource databound} listGrid, ensure the updated record is re-selected
     * when the operation completes. The {@link com.smartgwt.client.widgets.grid.ListGrid#getReselectOnUpdateNotifications
     * reselectOnUpdateNotifications} attributes governs whether {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addSelectionUpdatedHandler ListGrid.selectionUpdated()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addSelectionChangedHandler ListGrid.selectionChanged()} will fire when this
     * occurs.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param reselectOnUpdate New reselectOnUpdate value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setReselectOnUpdate(boolean reselectOnUpdate)  throws IllegalStateException {
        setAttribute("reselectOnUpdate", reselectOnUpdate, false);
    }

    /**
     * If true, when an update operation occurs on a selected record in a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource databound} listGrid, ensure the updated record is re-selected
     * when the operation completes. The {@link com.smartgwt.client.widgets.grid.ListGrid#getReselectOnUpdateNotifications
     * reselectOnUpdateNotifications} attributes governs whether {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addSelectionUpdatedHandler ListGrid.selectionUpdated()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addSelectionChangedHandler ListGrid.selectionChanged()} will fire when this
     * occurs.
     *
     * @return Current reselectOnUpdate value. Default value is true
     */
    public boolean getReselectOnUpdate()  {
        Boolean result = getAttributeAsBoolean("reselectOnUpdate");
        return result == null ? true : result;
    }
    

    /**
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getReselectOnUpdate reselectOnUpdate} is true, this property governs
     * what selection changed notifications should be triggered when a selected record is edited then automatically reselected
     * when the edited data is merged into the data set.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param reselectOnUpdateNotifications New reselectOnUpdateNotifications value. Default value is "selectionChanged"
     */
    public void setReselectOnUpdateNotifications(SelectionNotificationType reselectOnUpdateNotifications) {
        setAttribute("reselectOnUpdateNotifications", reselectOnUpdateNotifications == null ? null : reselectOnUpdateNotifications.getValue(), true);
    }

    /**
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getReselectOnUpdate reselectOnUpdate} is true, this property governs
     * what selection changed notifications should be triggered when a selected record is edited then automatically reselected
     * when the edited data is merged into the data set.
     *
     * @return Current reselectOnUpdateNotifications value. Default value is "selectionChanged"
     */
    public SelectionNotificationType getReselectOnUpdateNotifications()  {
        return EnumUtil.getEnum(SelectionNotificationType.values(), getAttribute("reselectOnUpdateNotifications"));
    }
    

    /**
     * If <code>true</code>, the grid contents are redrawn in real time as fields are resized. This can be slow with a large
     * grid and/or on some platforms. By default, this is enabled in modern desktop browsers. This is automatically switched
     * off in mobile browsers.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param resizeFieldsInRealTime New resizeFieldsInRealTime value. Default value is see below
     */
    public void setResizeFieldsInRealTime(boolean resizeFieldsInRealTime) {
        setAttribute("resizeFieldsInRealTime", resizeFieldsInRealTime, true);
    }

    /**
     * If <code>true</code>, the grid contents are redrawn in real time as fields are resized. This can be slow with a large
     * grid and/or on some platforms. By default, this is enabled in modern desktop browsers. This is automatically switched
     * off in mobile browsers.
     *
     * @return Current resizeFieldsInRealTime value. Default value is see below
     */
    public boolean getResizeFieldsInRealTime()  {
        Boolean result = getAttributeAsBoolean("resizeFieldsInRealTime");
        return result == null ? false : result;
    }
    

    /**
     * If a page is rendered in {@link com.smartgwt.client.util.Page#isRTL RTL mode}, should cell alignments specified {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCellAlign ListGridField.cellAlign} be reversed (so an
     * <code>align:"right"</code> field will have content aligned on the left and vice versa)? <P> This is true by default to
     * match user expectation that text flows from start-to end and is aligned with the start of text flow (left in LTR mode,
     * right in RTL mode) by default. May be set to false to have the specified alignments be taken literally in RTL mode.
     *
     * @param reverseRTLAlign New reverseRTLAlign value. Default value is true
     */
    public void setReverseRTLAlign(Boolean reverseRTLAlign) {
        setAttribute("reverseRTLAlign", reverseRTLAlign, true);
    }

    /**
     * If a page is rendered in {@link com.smartgwt.client.util.Page#isRTL RTL mode}, should cell alignments specified {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCellAlign ListGridField.cellAlign} be reversed (so an
     * <code>align:"right"</code> field will have content aligned on the left and vice versa)? <P> This is true by default to
     * match user expectation that text flows from start-to end and is aligned with the start of text flow (left in LTR mode,
     * right in RTL mode) by default. May be set to false to have the specified alignments be taken literally in RTL mode.
     *
     * @return Current reverseRTLAlign value. Default value is true
     */
    public Boolean getReverseRTLAlign()  {
        Boolean result = getAttributeAsBoolean("reverseRTLAlign");
        return result == null ? true : result;
    }
    
    
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the auto-generated <code>headerMenuButton</code> over a {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle rotated} header button.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param rotatedHeaderMenuButtonHeight New rotatedHeaderMenuButtonHeight value. Default value is "100%"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderMenuButtonHeight
     */
    public void setRotatedHeaderMenuButtonHeight(int rotatedHeaderMenuButtonHeight)  throws IllegalStateException {
        setAttribute("rotatedHeaderMenuButtonHeight", rotatedHeaderMenuButtonHeight, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the height of the auto-generated <code>headerMenuButton</code> over a {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle rotated} header button.
     *
     * @return Current rotatedHeaderMenuButtonHeight value. Default value is "100%"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonHeight
     */
    public int getRotatedHeaderMenuButtonHeight()  {
        return getAttributeAsInt("rotatedHeaderMenuButtonHeight");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the auto-generated <code>headerMenuButton</code> over a  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle rotated} header button.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param rotatedHeaderMenuButtonWidth New rotatedHeaderMenuButtonWidth value. Default value is 16
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderMenuButtonWidth
     */
    public void setRotatedHeaderMenuButtonWidth(int rotatedHeaderMenuButtonWidth)  throws IllegalStateException {
        setAttribute("rotatedHeaderMenuButtonWidth", rotatedHeaderMenuButtonWidth, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} is true, this property
     * governs the width of the auto-generated <code>headerMenuButton</code> over a  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle rotated} header button.
     *
     * @return Current rotatedHeaderMenuButtonWidth value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonWidth
     */
    public int getRotatedHeaderMenuButtonWidth()  {
        return getAttributeAsInt("rotatedHeaderMenuButtonWidth");
    }
    

    /**
     * Whether to rotate the field titles so they're rendered vertically from bottom to top. Can be overridden for individual
     * fields by setting {@link com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle ListGridField.rotateTitle}. <P>
     * Note that you can manually set the header height and field widths as you please when using this feature, but it's not
     * compatible with {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitHeaderHeights autoFitHeaderHeights} or
     * autofitting of field widths in any {@link com.smartgwt.client.types.AutoFitWidthApproach} other than "value". <P> You
     * can use {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleVAlign headerTitleVAlign} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValign ListGridField.valign} to control vertical positioning of the
     * titles, and {@link com.smartgwt.client.widgets.grid.ListGridField#getAlign ListGridField.align} to control the
     * horizontal. You may also choose between {@link com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles clipping}
     * or  {@link com.smartgwt.client.widgets.grid.ListGrid#getWrapHeaderTitles wrapping}, and set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} as you please (which reserves
     * space in each header button for the header menu button). <P> Note that this feature is incompatible with clipping via
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles clipHeaderTitles}:false, and may not work with
     * older browsers, particular IE versions before IE10.  The "TreeFrog" and "Basic" {@link com.smartgwt.client.docs.Skins
     * skins} are not supported for this feature.
     *
     * @param rotateHeaderTitles New rotateHeaderTitles value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderTitleVAlign
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValign
     * @see com.smartgwt.client.widgets.grid.ListGridField#setRotateTitle
     */
    public void setRotateHeaderTitles(Boolean rotateHeaderTitles)  throws IllegalStateException {
        setAttribute("rotateHeaderTitles", rotateHeaderTitles, false);
    }

    /**
     * Whether to rotate the field titles so they're rendered vertically from bottom to top. Can be overridden for individual
     * fields by setting {@link com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle ListGridField.rotateTitle}. <P>
     * Note that you can manually set the header height and field widths as you please when using this feature, but it's not
     * compatible with {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitHeaderHeights autoFitHeaderHeights} or
     * autofitting of field widths in any {@link com.smartgwt.client.types.AutoFitWidthApproach} other than "value". <P> You
     * can use {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleVAlign headerTitleVAlign} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValign ListGridField.valign} to control vertical positioning of the
     * titles, and {@link com.smartgwt.client.widgets.grid.ListGridField#getAlign ListGridField.align} to control the
     * horizontal. You may also choose between {@link com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles clipping}
     * or  {@link com.smartgwt.client.widgets.grid.ListGrid#getWrapHeaderTitles wrapping}, and set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderMenuButton showHeaderMenuButton} as you please (which reserves
     * space in each header button for the header menu button). <P> Note that this feature is incompatible with clipping via
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles clipHeaderTitles}:false, and may not work with
     * older browsers, particular IE versions before IE10.  The "TreeFrog" and "Basic" {@link com.smartgwt.client.docs.Skins
     * skins} are not supported for this feature.
     *
     * @return Current rotateHeaderTitles value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleVAlign
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValign
     * @see com.smartgwt.client.widgets.grid.ListGridField#getRotateTitle
     */
    public Boolean getRotateHeaderTitles()  {
        return getAttributeAsBoolean("rotateHeaderTitles");
    }
    

    /**
     * If the user is editing a record in this listGrid, and attempts to navigate to a field beyond the end of the row, via tab
     * (or shift-tab off the first editable field), this property determines what action to take:<ul> <li>"next": start editing
     * the next (or previous) record in the list <li>"same": put focus back into the first editable field of the same record.
     * <li>"done": hide the editor <li>"stop": leave focus in the cell being edited <li>"none": no action </ul>
     *
     * @param rowEndEditAction New rowEndEditAction value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setRowEndEditAction(RowEndEditAction rowEndEditAction) {
        setAttribute("rowEndEditAction", rowEndEditAction == null ? null : rowEndEditAction.getValue(), true);
    }

    /**
     * If the user is editing a record in this listGrid, and attempts to navigate to a field beyond the end of the row, via tab
     * (or shift-tab off the first editable field), this property determines what action to take:<ul> <li>"next": start editing
     * the next (or previous) record in the list <li>"same": put focus back into the first editable field of the same record.
     * <li>"done": hide the editor <li>"stop": leave focus in the cell being edited <li>"none": no action </ul>
     *
     * @return Current rowEndEditAction value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public RowEndEditAction getRowEndEditAction()  {
        return EnumUtil.getEnum(RowEndEditAction.values(), getAttribute("rowEndEditAction"));
    }
    

    /**
     * An automatically generated field that displays the current row number when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true.
     * <p>
     * This component is an AutoChild named "rowNumberField".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current rowNumberField value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public ListGridField getRowNumberField() throws IllegalStateException {
        errorIfNotCreated("rowNumberField");
        return ListGridField.getOrCreateRef(getAttributeAsJavaScriptObject("rowNumberField"));
    }
    

    /**
     * The number to start the row-count from - default value is 1.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param rowNumberStart New rowNumberStart value. Default value is 1
     */
    public void setRowNumberStart(int rowNumberStart) {
        setAttribute("rowNumberStart", rowNumberStart, true);
    }

    /**
     * The number to start the row-count from - default value is 1.
     *
     * @return Current rowNumberStart value. Default value is 1
     */
    public int getRowNumberStart()  {
        return getAttributeAsInt("rowNumberStart");
    }
    

    /**
     * The CSS Style name for the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowNumberField rowNumberField}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param rowNumberStyle New rowNumberStyle value. Default value is "specialCol"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setRowNumberStyle(String rowNumberStyle) {
        setAttribute("rowNumberStyle", rowNumberStyle, true);
    }

    /**
     * The CSS Style name for the {@link com.smartgwt.client.widgets.grid.ListGrid#getRowNumberField rowNumberField}.
     *
     * @return Current rowNumberStyle value. Default value is "specialCol"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getRowNumberStyle()  {
        return getAttributeAsString("rowNumberStyle");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowRowSpanning allowRowSpanning} is enabled, this property may
     * be used to specify editing behavior for cells that span multiple rows.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param rowSpanEditMode New rowSpanEditMode value. Default value is "first"
     */
    public void setRowSpanEditMode(RowSpanEditMode rowSpanEditMode) {
        setAttribute("rowSpanEditMode", rowSpanEditMode == null ? null : rowSpanEditMode.getValue(), true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowRowSpanning allowRowSpanning} is enabled, this property may
     * be used to specify editing behavior for cells that span multiple rows.
     *
     * @return Current rowSpanEditMode value. Default value is "first"
     */
    public RowSpanEditMode getRowSpanEditMode()  {
        return EnumUtil.getEnum(RowSpanEditMode.values(), getAttribute("rowSpanEditMode"));
    }
    

    /**
     * Chooses the selection mode when {@link com.smartgwt.client.widgets.grid.ListGrid#getUseRowSpanStyling useRowSpanStyling}
     * is enabled.  See {@link com.smartgwt.client.types.RowSpanSelectionMode}.
     *
     * @param rowSpanSelectionMode New rowSpanSelectionMode value. Default value is "forward"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setRowSpanSelectionMode(RowSpanSelectionMode rowSpanSelectionMode)  throws IllegalStateException {
        setAttribute("rowSpanSelectionMode", rowSpanSelectionMode == null ? null : rowSpanSelectionMode.getValue(), false);
    }

    /**
     * Chooses the selection mode when {@link com.smartgwt.client.widgets.grid.ListGrid#getUseRowSpanStyling useRowSpanStyling}
     * is enabled.  See {@link com.smartgwt.client.types.RowSpanSelectionMode}.
     *
     * @return Current rowSpanSelectionMode value. Default value is "forward"
     */
    public RowSpanSelectionMode getRowSpanSelectionMode()  {
        return EnumUtil.getEnum(RowSpanSelectionMode.values(), getAttribute("rowSpanSelectionMode"));
    }
    

    /**
     * Whether edits should be saved whenever the user moves between cells in the current edit row. <P> If unset, defaults to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell this.editByCell}. <P> To avoid automatic saving entirely,
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits}:false.
     *
     * @param saveByCell New saveByCell value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setEditByCell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setSaveByCell(Boolean saveByCell) {
        setAttribute("saveByCell", saveByCell, true);
    }

    /**
     * Whether edits should be saved whenever the user moves between cells in the current edit row. <P> If unset, defaults to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell this.editByCell}. <P> To avoid automatic saving entirely,
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits}:false.
     *
     * @return Current saveByCell value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditByCell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getSaveByCell()  {
        return getAttributeAsBoolean("saveByCell");
    }
    

    /**
     * For grids with a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, this property can
     * be set to <code>true</code> to cause the grid directly update its local data set instead of performing an operation
     * against it's configured DataSource. <p> When using this mode, data must be provided to the grid via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setData setData()}, and must be provided as   a RecordList.  Setting
     * <code>saveLocally</code> is invalid if either {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} is
     * called or if a {@link com.smartgwt.client.data.ResultSet} is provided as the data model. <p> <code>saveLocally</code>
     * mode includes changes made via  {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit inline editing}, record
     * removal via {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}, as well as
     * programmatic calls to {@link com.smartgwt.client.widgets.grid.ListGrid#updateData updateData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addData addData()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeData removeData()}.  This also causes saves to be performed
     * synchronously (unlike normal DataSource operations). <p> Note that using this mode also disables the automatic cache
     * synchronization provided by the DataSource system - changes made to this grid are saved only to this grid's data set.
     * <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterLocalData filterLocalData} to allow filtering,
     * such as filtering performed by the {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filterEditor}, to
     * also work only with the local data set. <P> If saveLocally is unset, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterLocalData filterLocalData} is true, the saveLocally behavior is
     * enabled by default
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param saveLocally New saveLocally value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setUseRemoteValidators
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setSaveLocally(Boolean saveLocally)  throws IllegalStateException {
        setAttribute("saveLocally", saveLocally, false);
    }

    /**
     * For grids with a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, this property can
     * be set to <code>true</code> to cause the grid directly update its local data set instead of performing an operation
     * against it's configured DataSource. <p> When using this mode, data must be provided to the grid via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setData setData()}, and must be provided as   a RecordList.  Setting
     * <code>saveLocally</code> is invalid if either {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} is
     * called or if a {@link com.smartgwt.client.data.ResultSet} is provided as the data model. <p> <code>saveLocally</code>
     * mode includes changes made via  {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit inline editing}, record
     * removal via {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords}, as well as
     * programmatic calls to {@link com.smartgwt.client.widgets.grid.ListGrid#updateData updateData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addData addData()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeData removeData()}.  This also causes saves to be performed
     * synchronously (unlike normal DataSource operations). <p> Note that using this mode also disables the automatic cache
     * synchronization provided by the DataSource system - changes made to this grid are saved only to this grid's data set.
     * <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterLocalData filterLocalData} to allow filtering,
     * such as filtering performed by the {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor filterEditor}, to
     * also work only with the local data set. <P> If saveLocally is unset, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFilterLocalData filterLocalData} is true, the saveLocally behavior is
     * enabled by default
     *
     * @return Current saveLocally value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getUseRemoteValidators
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public Boolean getSaveLocally()  {
        return getAttributeAsBoolean("saveLocally");
    }
    

    /**
     * For editable grids with a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, where
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} is false, this attribute may be used to
     * specify standard DSRequest properties to apply to all save operations performed by this grid (whether triggered by user
     * interaction, or explicit saveEdits or saveAllEdits call). <P> An example usage would be to customize the prompt
     * displayed while saving is in progress if {@link com.smartgwt.client.widgets.grid.ListGrid#getWaitForSave waitForSave} is
     * true. <P> Note that for more advanced customization of save operations, {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getAddOperation DataBoundComponent.addOperation} and {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getUpdateOperation DataBoundComponent.updateOperation} are available to
     * developers, allowing specification of an explicit {@link com.smartgwt.client.data.OperationBinding} for the add / update
     * operation performed on save.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param saveRequestProperties New saveRequestProperties value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setSaveRequestProperties(DSRequest saveRequestProperties) {
        JavaScriptObject config = JSOHelper.createObject();
        if (saveRequestProperties != null) {
            JSOHelper.addProperties(config, saveRequestProperties.getJsObj());
        }
        setAttribute("saveRequestProperties", saveRequestProperties == null ? null : config, true);
    }

    /**
     * For editable grids with a specified {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}, where
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} is false, this attribute may be used to
     * specify standard DSRequest properties to apply to all save operations performed by this grid (whether triggered by user
     * interaction, or explicit saveEdits or saveAllEdits call). <P> An example usage would be to customize the prompt
     * displayed while saving is in progress if {@link com.smartgwt.client.widgets.grid.ListGrid#getWaitForSave waitForSave} is
     * true. <P> Note that for more advanced customization of save operations, {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getAddOperation DataBoundComponent.addOperation} and {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getUpdateOperation DataBoundComponent.updateOperation} are available to
     * developers, allowing specification of an explicit {@link com.smartgwt.client.data.OperationBinding} for the add / update
     * operation performed on save.
     *
     * @return Current saveRequestProperties value. Default value is null
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public DSRequest getSaveRequestProperties()  {
        return new DSRequest(getAttributeAsJavaScriptObject("saveRequestProperties"));
    }
    

    /**
     * When {@link com.smartgwt.client.util.isc#setScreenReaderMode screen reader mode} is enabled, this invisible separator
     * string is written out between each cell value. This string will be picked up by screen readers allowing them to more
     * obviously identify to the user the different cell values as the contents of a row are read aloud. The {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScreenReaderRowSeparator screenReaderRowSeparator} string if any will be
     * written out after the last cell in a row to separate the last cell's value from the screen reader's announcement of the
     * row's number and total number of rows in the grid (such as "3 of 20"). <P> This attribute may be set to null to disable
     * the feature. <P> Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it
     * depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all read
     * the forward slash '/' as "slash". See <a
     * href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/'
     * target='_blank'>Why Don?t Screen Readers Always Read What?s on the Screen? Part 1: Punctuation and Typographic
     * Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param screenReaderCellSeparator New screenReaderCellSeparator value. Default value is "/"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public void setScreenReaderCellSeparator(String screenReaderCellSeparator)  throws IllegalStateException {
        setAttribute("screenReaderCellSeparator", screenReaderCellSeparator, false);
    }

    /**
     * When {@link com.smartgwt.client.util.isc#setScreenReaderMode screen reader mode} is enabled, this invisible separator
     * string is written out between each cell value. This string will be picked up by screen readers allowing them to more
     * obviously identify to the user the different cell values as the contents of a row are read aloud. The {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScreenReaderRowSeparator screenReaderRowSeparator} string if any will be
     * written out after the last cell in a row to separate the last cell's value from the screen reader's announcement of the
     * row's number and total number of rows in the grid (such as "3 of 20"). <P> This attribute may be set to null to disable
     * the feature. <P> Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it
     * depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all read
     * the forward slash '/' as "slash". See <a
     * href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/'
     * target='_blank'>Why Don?t Screen Readers Always Read What?s on the Screen? Part 1: Punctuation and Typographic
     * Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
     *
     * @return Current screenReaderCellSeparator value. Default value is "/"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public String getScreenReaderCellSeparator()  {
        return getAttributeAsString("screenReaderCellSeparator");
    }
    

    /**
     * When {@link com.smartgwt.client.util.isc#setScreenReaderMode screen reader mode} is enabled, this invisible string will
     * be written out after the last cell in a row. This string will be picked up by screen readers allowing them to more
     * obviously identify to the user the end of the row's contents and the screen reader's announcement of the row's number
     * and total number of rows in the grid (such as "3 of 20"). <p> This attribute may be set to null to disable writing out
     * an invisible string at the end of each row. <p> Note that screen readers vary widely on which punctuation symbols are
     * read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and
     * VoiceOver screen readers all pause briefly for a comma ',' that is within text. See <a
     * href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/'
     * target='_blank'>Why Don?t Screen Readers Always Read What?s on the Screen? Part 1: Punctuation and Typographic
     * Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param screenReaderRowSeparator New screenReaderRowSeparator value. Default value is ","
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setScreenReaderCellSeparator
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public void setScreenReaderRowSeparator(String screenReaderRowSeparator)  throws IllegalStateException {
        setAttribute("screenReaderRowSeparator", screenReaderRowSeparator, false);
    }

    /**
     * When {@link com.smartgwt.client.util.isc#setScreenReaderMode screen reader mode} is enabled, this invisible string will
     * be written out after the last cell in a row. This string will be picked up by screen readers allowing them to more
     * obviously identify to the user the end of the row's contents and the screen reader's announcement of the row's number
     * and total number of rows in the grid (such as "3 of 20"). <p> This attribute may be set to null to disable writing out
     * an invisible string at the end of each row. <p> Note that screen readers vary widely on which punctuation symbols are
     * read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and
     * VoiceOver screen readers all pause briefly for a comma ',' that is within text. See <a
     * href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/'
     * target='_blank'>Why Don?t Screen Readers Always Read What?s on the Screen? Part 1: Punctuation and Typographic
     * Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
     *
     * @return Current screenReaderRowSeparator value. Default value is ","
     * @see com.smartgwt.client.widgets.grid.ListGrid#getScreenReaderCellSeparator
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     * @see com.smartgwt.client.docs.Accessibility Accessibility overview and related methods
     */
    public String getScreenReaderRowSeparator()  {
        return getAttributeAsString("screenReaderRowSeparator");
    }
    

    /**
     * While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last
     * mouse movement by the user. This delay may be  separately customized for mouse-wheel scrolling via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollWheelRedrawDelay scrollWheelRedrawDelay}. <P> See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw GridRenderer.instantScrollTrackRedraw} for
     * cases where this delay is skipped. <P> <strong>NOTE:</strong> In {@link com.smartgwt.client.util.Browser#isTouch touch
     * browsers}, {@link com.smartgwt.client.widgets.grid.GridRenderer#getTouchScrollRedrawDelay touchScrollRedrawDelay} is
     * used instead.
     *
     * @param scrollRedrawDelay New scrollRedrawDelay value. Default value is 0
     */
    public void setScrollRedrawDelay(int scrollRedrawDelay) {
        setAttribute("scrollRedrawDelay", scrollRedrawDelay, true);
    }

    /**
     * While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last
     * mouse movement by the user. This delay may be  separately customized for mouse-wheel scrolling via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollWheelRedrawDelay scrollWheelRedrawDelay}. <P> See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw GridRenderer.instantScrollTrackRedraw} for
     * cases where this delay is skipped. <P> <strong>NOTE:</strong> In {@link com.smartgwt.client.util.Browser#isTouch touch
     * browsers}, {@link com.smartgwt.client.widgets.grid.GridRenderer#getTouchScrollRedrawDelay touchScrollRedrawDelay} is
     * used instead.
     *
     * @return Current scrollRedrawDelay value. Default value is 0
     */
    public int getScrollRedrawDelay()  {
        return getAttributeAsInt("scrollRedrawDelay");
    }
    

    /**
     * When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed into the method.
     *
     * @param scrollToCellXPosition New scrollToCellXPosition value. Default value is "center"
     */
    public void setScrollToCellXPosition(Alignment scrollToCellXPosition) {
        setAttribute("scrollToCellXPosition", scrollToCellXPosition == null ? null : scrollToCellXPosition.getValue(), true);
    }

    /**
     * When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed into the method.
     *
     * @return Current scrollToCellXPosition value. Default value is "center"
     */
    public Alignment getScrollToCellXPosition()  {
        return EnumUtil.getEnum(Alignment.values(), getAttribute("scrollToCellXPosition"));
    }
    

    /**
     * When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed into the method.
     *
     * @param scrollToCellYPosition New scrollToCellYPosition value. Default value is "center"
     */
    public void setScrollToCellYPosition(VerticalAlignment scrollToCellYPosition) {
        setAttribute("scrollToCellYPosition", scrollToCellYPosition == null ? null : scrollToCellYPosition.getValue(), true);
    }

    /**
     * When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed into the method.
     *
     * @return Current scrollToCellYPosition value. Default value is "center"
     */
    public VerticalAlignment getScrollToCellYPosition()  {
        return EnumUtil.getEnum(VerticalAlignment.values(), getAttribute("scrollToCellYPosition"));
    }
    

    /**
     * While scrolling an incrementally rendered grid, using the mouseWheel, time in  milliseconds to wait before redrawing,
     * after the last mouseWheel movement by the user.   If not specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} will be used as a default for both
     * drag scrolling and mouseWheel scrolling. <P> Note that if specified, this value will typically be larger than  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}. From experimentation, the default
     * setting of  <code>250</code> is typically enough time for a user to rapidly scroll through a grid (rotating the scroll
     * wheel with repeated flicks), without redrawing between rotations, but this will differ depending on how long the redraw
     * takes. A larger delay may be warranted for grids with large numbers of columns, heavy custom  formatting, etc. <P> See
     * also {@link com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw
     * GridRenderer.instantScrollTrackRedraw} for cases where this delay is skipped.
     *
     * @param scrollWheelRedrawDelay New scrollWheelRedrawDelay value. Default value is 0
     */
    public void setScrollWheelRedrawDelay(Integer scrollWheelRedrawDelay) {
        setAttribute("scrollWheelRedrawDelay", scrollWheelRedrawDelay, true);
    }

    /**
     * While scrolling an incrementally rendered grid, using the mouseWheel, time in  milliseconds to wait before redrawing,
     * after the last mouseWheel movement by the user.   If not specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} will be used as a default for both
     * drag scrolling and mouseWheel scrolling. <P> Note that if specified, this value will typically be larger than  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}. From experimentation, the default
     * setting of  <code>250</code> is typically enough time for a user to rapidly scroll through a grid (rotating the scroll
     * wheel with repeated flicks), without redrawing between rotations, but this will differ depending on how long the redraw
     * takes. A larger delay may be warranted for grids with large numbers of columns, heavy custom  formatting, etc. <P> See
     * also {@link com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw
     * GridRenderer.instantScrollTrackRedraw} for cases where this delay is skipped.
     *
     * @return Current scrollWheelRedrawDelay value. Default value is 0
     */
    public Integer getScrollWheelRedrawDelay()  {
        return getAttributeAsInt("scrollWheelRedrawDelay");
    }
    

    /**
     * If this property is set to true, clicking on a cell will natively select the  cell's content, ready to be copied to the
     * browser clipboard. <P> For control of this behavior at the field level,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSelectCellTextOnClick ListGridField.selectCellTextOnClick} may be
     * used. These properties interact as follows: <table border=1 cellpadding=4><tr>  <td><b>listGrid.selectCellTextOnClick
     * value</b></td>  <td><b>listGridField.selectCellTextOnClick value</b></td>  <td><b>Behavior</b></td> </tr><tr>  <td
     * rowspan=2><code>true</code></td>      <td><i>unset</i> or <code>true</code></td>          <td>Cell contents will be
     * natively selected on click.</td> </tr><tr>      <td><code>false</code></td>          <td>Cell contents will not be
     * natively selected on click.</td> </tr><tr> </tr><tr>  <td rowspan=2><i>unset</i></td>      <td><code>true</code></td>   
     * <td>Cell contents will be natively selected on click.</td> </tr><tr>      <td><i>unset</i> or <code>false</code></td>   
     * <td>Cell contents will not be natively selected on click.</td> </tr><tr>  <td><code>false</code></td>     
     * <td><code>true</code>, <code>false</code> or <i>unset</i></td>          <td>Cell contents will not be natively selected
     * on click.</td> </tr></table> <P> This is related to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanDragSelectText canDragSelectText} attribute which enables native text
     * selection of grid content by standard browser interactions (drag selecting or double-click selecting). <P> Note that
     * developers may also be interested in the related formItem properties {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getSelectOnClick FormItem.selectOnClick} and {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getSelectOnFocus FormItem.selectOnFocus}.
     *
     * @param selectCellTextOnClick New selectCellTextOnClick value. Default value is null
     */
    public void setSelectCellTextOnClick(Boolean selectCellTextOnClick) {
        setAttribute("selectCellTextOnClick", selectCellTextOnClick, true);
    }

    /**
     * If this property is set to true, clicking on a cell will natively select the  cell's content, ready to be copied to the
     * browser clipboard. <P> For control of this behavior at the field level,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSelectCellTextOnClick ListGridField.selectCellTextOnClick} may be
     * used. These properties interact as follows: <table border=1 cellpadding=4><tr>  <td><b>listGrid.selectCellTextOnClick
     * value</b></td>  <td><b>listGridField.selectCellTextOnClick value</b></td>  <td><b>Behavior</b></td> </tr><tr>  <td
     * rowspan=2><code>true</code></td>      <td><i>unset</i> or <code>true</code></td>          <td>Cell contents will be
     * natively selected on click.</td> </tr><tr>      <td><code>false</code></td>          <td>Cell contents will not be
     * natively selected on click.</td> </tr><tr> </tr><tr>  <td rowspan=2><i>unset</i></td>      <td><code>true</code></td>   
     * <td>Cell contents will be natively selected on click.</td> </tr><tr>      <td><i>unset</i> or <code>false</code></td>   
     * <td>Cell contents will not be natively selected on click.</td> </tr><tr>  <td><code>false</code></td>     
     * <td><code>true</code>, <code>false</code> or <i>unset</i></td>          <td>Cell contents will not be natively selected
     * on click.</td> </tr></table> <P> This is related to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanDragSelectText canDragSelectText} attribute which enables native text
     * selection of grid content by standard browser interactions (drag selecting or double-click selecting). <P> Note that
     * developers may also be interested in the related formItem properties {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getSelectOnClick FormItem.selectOnClick} and {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getSelectOnFocus FormItem.selectOnFocus}.
     *
     * @return Current selectCellTextOnClick value. Default value is null
     */
    public Boolean getSelectCellTextOnClick()  {
        return getAttributeAsBoolean("selectCellTextOnClick");
    }
    

    /**
     * Returns a snapshot of the current selection within this listGrid as a {@link
     * com.smartgwt.client.docs.ListGridSelectedState} object.<br> This object can be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSelectedState setSelectedState()} to reset this grid's selection the
     * current state (assuming the same data is present in the grid).<br>
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Reset this grid's selection to match the {@link com.smartgwt.client.docs.ListGridSelectedState} object passed in.<br> Used to restore previous state retrieved from the grid by a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectedState getSelectedState()}.
     *
     * @param selectedState Object describing the desired selection state of                                              the grid. Default value is null
     * @see com.smartgwt.client.docs.ListGridSelectedState ListGridSelectedState 
     */
    public void setSelectedState(String selectedState) {
        setAttribute("selectedState", selectedState, true);
    }

    /**
     * Returns a snapshot of the current selection within this listGrid as a {@link
     * com.smartgwt.client.docs.ListGridSelectedState} object.<br> This object can be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSelectedState setSelectedState()} to reset this grid's selection the
     * current state (assuming the same data is present in the grid).<br>
     *
     * @return Returns a snapshot of the current selection within this listGrid as a {@link
     * com.smartgwt.client.docs.ListGridSelectedState} object.<br> This object can be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSelectedState setSelectedState()} to reset this grid's current selection
     * state (assuming the same data is present in the grid).<br>. Default value is null
     * @see com.smartgwt.client.docs.ListGridSelectedState ListGridSelectedState 
     */
    public String getSelectedState()  {
        return getAttributeAsString("selectedState");
    }
    

    /**
     * If true, show the field-header for the sorted field (or the first field in a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanMultiSort multi-sort} grid) in the selected state.
     *
     * @param selectHeaderOnSort New selectHeaderOnSort value. Default value is true
     */
    public void setSelectHeaderOnSort(Boolean selectHeaderOnSort) {
        setAttribute("selectHeaderOnSort", selectHeaderOnSort, true);
    }

    /**
     * If true, show the field-header for the sorted field (or the first field in a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanMultiSort multi-sort} grid) in the selected state.
     *
     * @return Current selectHeaderOnSort value. Default value is true
     */
    public Boolean getSelectHeaderOnSort()  {
        Boolean result = getAttributeAsBoolean("selectHeaderOnSort");
        return result == null ? true : result;
    }
    
    

    /**
     * How selection of rows should be presented to the user. <P> For <code>selectionAppearance:"checkbox"</code> with multiple
     * selection allowed, you would typically use {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType
     * selectionType}:"simple" (the default).  Because <code>selectionType</code> and <code>selectionAppearance</code> are
     * unrelated, the combination of <code>selectionAppearance:"checkbox"</code> and <code>selectionType:"multiple"</code>
     * results in a grid where multiple selection can only be achieved via shift-click or ctrl-click. <P> If using
     * <code>"checkbox"</code> for a {@link com.smartgwt.client.widgets.grid.ListGrid}, see also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCheckboxField checkboxField} for customization APIs. <P> If using
     * <code>"checkbox"</code> for a {@link com.smartgwt.client.widgets.tree.TreeGrid}, an extra icon, {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getExtraIcon TreeGrid.getExtraIcon()} is not supported. Additionally only
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType}:"simple" and "single" are supported.
     * You can also toggle the display of a disabled checkbox on a treeGrid, displayed when the node can't be selected, via
     * {@link com.smartgwt.client.widgets.tree.TreeGrid#getShowDisabledSelectionCheckbox
     * TreeGrid.showDisabledSelectionCheckbox}. <p> Note that the default behavior when you enable checkbox selection is to
     * continue to show the selected style.  This can be changed by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedStyle showSelectedStyle} to false.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Changes selectionAppearance on the fly.
     *
     * @param selectionAppearance new selection appearance. Default value is "rowStyle"
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setSelectionAppearance(SelectionAppearance selectionAppearance) {
        setAttribute("selectionAppearance", selectionAppearance == null ? null : selectionAppearance.getValue(), true);
    }

    /**
     * How selection of rows should be presented to the user. <P> For <code>selectionAppearance:"checkbox"</code> with multiple
     * selection allowed, you would typically use {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType
     * selectionType}:"simple" (the default).  Because <code>selectionType</code> and <code>selectionAppearance</code> are
     * unrelated, the combination of <code>selectionAppearance:"checkbox"</code> and <code>selectionType:"multiple"</code>
     * results in a grid where multiple selection can only be achieved via shift-click or ctrl-click. <P> If using
     * <code>"checkbox"</code> for a {@link com.smartgwt.client.widgets.grid.ListGrid}, see also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCheckboxField checkboxField} for customization APIs. <P> If using
     * <code>"checkbox"</code> for a {@link com.smartgwt.client.widgets.tree.TreeGrid}, an extra icon, {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getExtraIcon TreeGrid.getExtraIcon()} is not supported. Additionally only
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType}:"simple" and "single" are supported.
     * You can also toggle the display of a disabled checkbox on a treeGrid, displayed when the node can't be selected, via
     * {@link com.smartgwt.client.widgets.tree.TreeGrid#getShowDisabledSelectionCheckbox
     * TreeGrid.showDisabledSelectionCheckbox}. <p> Note that the default behavior when you enable checkbox selection is to
     * continue to show the selected style.  This can be changed by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedStyle showSelectedStyle} to false.
     *
     * @return Current selectionAppearance value. Default value is "rowStyle"
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public SelectionAppearance getSelectionAppearance()  {
        return EnumUtil.getEnum(SelectionAppearance.values(), getAttribute("selectionAppearance"));
    }
    
    
    

    /**
     * If specified, the selection object for this list will use this property to mark records as selected.  In other words, if
     * this attribute were set to <code>"isSelected"</code> any records in the listGrid data where <code>"isSelected"</code> is
     * <code>true</code> will show up as selected in the grid. Similarly if records are selected within the grid after the grid
     * has been created, this property will be set to true on the selected records.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param selectionProperty New selectionProperty value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setSelectionProperty(String selectionProperty)  throws IllegalStateException {
        setAttribute("selectionProperty", selectionProperty, false);
    }

    /**
     * If specified, the selection object for this list will use this property to mark records as selected.  In other words, if
     * this attribute were set to <code>"isSelected"</code> any records in the listGrid data where <code>"isSelected"</code> is
     * <code>true</code> will show up as selected in the grid. Similarly if records are selected within the grid after the grid
     * has been created, this property will be set to true on the selected records.
     *
     * @return Current selectionProperty value. Default value is null
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public String getSelectionProperty()  {
        return getAttributeAsString("selectionProperty");
    }
    

    /**
     * Defines a listGrid's clickable-selection behavior. <P> The default selection appearance is governed by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance}: if selectionAppearance is
     * "checkbox", this will be "simple", otherwise, this will be "multiple".
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Changes selectionType on the fly.
     *
     * @param selectionType New selection style. Default value is null
     * @see com.smartgwt.client.types.SelectionStyle
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_multiselect" target="examples">Multiple select Example</a>
     */
    public void setSelectionType(SelectionStyle selectionType) {
        setAttribute("selectionType", selectionType == null ? null : selectionType.getValue(), true);
    }

    /**
     * Defines a listGrid's clickable-selection behavior. <P> The default selection appearance is governed by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionAppearance selectionAppearance}: if selectionAppearance is
     * "checkbox", this will be "simple", otherwise, this will be "multiple".
     *
     * @return Current selectionType value. Default value is null
     * @see com.smartgwt.client.types.SelectionStyle
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_multiselect" target="examples">Multiple select Example</a>
     */
    public SelectionStyle getSelectionType()  {
        return EnumUtil.getEnum(SelectionStyle.values(), getAttribute("selectionType"));
    }
    
    

    /**
     * When the user starts editing a row, should the row also be selected?  <P>  See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditSelectionType editSelectionType} for how edit-selection behaves.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param selectOnEdit New selectOnEdit value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setSelectOnEdit(Boolean selectOnEdit) {
        setAttribute("selectOnEdit", selectOnEdit, true);
    }

    /**
     * When the user starts editing a row, should the row also be selected?  <P>  See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditSelectionType editSelectionType} for how edit-selection behaves.
     *
     * @return Current selectOnEdit value. Default value is true
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getSelectOnEdit()  {
        Boolean result = getAttributeAsBoolean("selectOnEdit");
        return result == null ? true : result;
    }
    

    /**
     * When set to false, clicking a record's {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionField expansion
     * field} will not add the record to the current selection.
     *
     * @param selectOnExpandRecord New selectOnExpandRecord value. Default value is true
     */
    public void setSelectOnExpandRecord(boolean selectOnExpandRecord) {
        setAttribute("selectOnExpandRecord", selectOnExpandRecord, true);
    }

    /**
     * When set to false, clicking a record's {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionField expansion
     * field} will not add the record to the current selection.
     *
     * @return Current selectOnExpandRecord value. Default value is true
     */
    public boolean getSelectOnExpandRecord()  {
        Boolean result = getAttributeAsBoolean("selectOnExpandRecord");
        return result == null ? true : result;
    }
    

    /**
     * Whether all columns should be drawn all at once, or only columns visible in the viewport. <P> Drawing all columns causes
     * longer initial rendering time, but allows smoother horizontal scrolling.  With a very large number of columns,
     * showAllColumns will become too slow.
     *
     * @param showAllColumns New showAllColumns value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setShowAllColumns(Boolean showAllColumns)  throws IllegalStateException {
        setAttribute("showAllColumns", showAllColumns, false);
    }

    /**
     * Whether all columns should be drawn all at once, or only columns visible in the viewport. <P> Drawing all columns causes
     * longer initial rendering time, but allows smoother horizontal scrolling.  With a very large number of columns,
     * showAllColumns will become too slow.
     *
     * @return Current showAllColumns value. Default value is false
     */
    public Boolean getShowAllColumns()  {
        Boolean result = getAttributeAsBoolean("showAllColumns");
        return result == null ? false : result;
    }
    

    /**
     * Whether all records should be drawn all at once, or only records visible in the viewport. <P> Drawing all records causes
     * longer initial rendering time, but allows smoother vertical scrolling.  With a very large number of records,
     * showAllRecords will become too slow. <P> This setting is incompatible with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataFetchMode dataFetchMode}: "paged" as it requires all records matching
     * the criteria to be fetched from the server at once.
     *
     * @param showAllRecords New showAllRecords value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setDrawAheadRatio
     * @see com.smartgwt.client.widgets.grid.ListGrid#setDrawAllMaxCells
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public void setShowAllRecords(Boolean showAllRecords) {
        setAttribute("showAllRecords", showAllRecords, true);
    }

    /**
     * Whether all records should be drawn all at once, or only records visible in the viewport. <P> Drawing all records causes
     * longer initial rendering time, but allows smoother vertical scrolling.  With a very large number of records,
     * showAllRecords will become too slow. <P> This setting is incompatible with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataFetchMode dataFetchMode}: "paged" as it requires all records matching
     * the criteria to be fetched from the server at once.
     *
     * @return Current showAllRecords value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDrawAllMaxCells
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_rows" target="examples">Rows Example</a>
     */
    public Boolean getShowAllRecords()  {
        Boolean result = getAttributeAsBoolean("showAllRecords");
        return result == null ? false : result;
    }
    

    /**
     * If set to false, do not show the {@link com.smartgwt.client.widgets.grid.ListGrid#getAsynchGroupingPrompt
     * asynchGroupingPrompt} dialog during {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold
     * asynchronous grouping}.
     *
     * @param showAsynchGroupingPrompt New showAsynchGroupingPrompt value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setShowAsynchGroupingPrompt(Boolean showAsynchGroupingPrompt)  throws IllegalStateException {
        setAttribute("showAsynchGroupingPrompt", showAsynchGroupingPrompt, false);
    }

    /**
     * If set to false, do not show the {@link com.smartgwt.client.widgets.grid.ListGrid#getAsynchGroupingPrompt
     * asynchGroupingPrompt} dialog during {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByAsyncThreshold
     * asynchronous grouping}.
     *
     * @return Current showAsynchGroupingPrompt value. Default value is null
     */
    public Boolean getShowAsynchGroupingPrompt()  {
        return getAttributeAsBoolean("showAsynchGroupingPrompt");
    }
    

    /**
     * If <code>true</code> this grid will create and show per-row backgroundComponents as detailed {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBackgroundComponent here}.
     *
     * @param showBackgroundComponents New showBackgroundComponents value. Default value is false
     */
    public void setShowBackgroundComponents(Boolean showBackgroundComponents) {
        setAttribute("showBackgroundComponents", showBackgroundComponents, true);
    }

    /**
     * If <code>true</code> this grid will create and show per-row backgroundComponents as detailed {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBackgroundComponent here}.
     *
     * @return Current showBackgroundComponents value. Default value is false
     */
    public Boolean getShowBackgroundComponents()  {
        Boolean result = getAttributeAsBoolean("showBackgroundComponents");
        return result == null ? false : result;
    }
    

    /**
     * Whether to show a context menu with standard items for all context clicks on rows in the body.
     *
     * @param showCellContextMenus New showCellContextMenus value. Default value is false
     */
    public void setShowCellContextMenus(Boolean showCellContextMenus) {
        setAttribute("showCellContextMenus", showCellContextMenus, true);
    }

    /**
     * Whether to show a context menu with standard items for all context clicks on rows in the body.
     *
     * @return Current showCellContextMenus value. Default value is false
     */
    public Boolean getShowCellContextMenus()  {
        Boolean result = getAttributeAsBoolean("showCellContextMenus");
        return result == null ? false : result;
    }
    

    /**
     * If true and a header button's title is clipped, then a hover containing the full field title is enabled.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showClippedHeaderTitlesOnHover New showClippedHeaderTitlesOnHover value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#headerTitleClipped
     * @see com.smartgwt.client.widgets.grid.ListGrid#headerHoverHTML
     */
    public void setShowClippedHeaderTitlesOnHover(boolean showClippedHeaderTitlesOnHover)  throws IllegalStateException {
        setAttribute("showClippedHeaderTitlesOnHover", showClippedHeaderTitlesOnHover, false);
    }

    /**
     * If true and a header button's title is clipped, then a hover containing the full field title is enabled.
     *
     * @return Current showClippedHeaderTitlesOnHover value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#headerTitleClipped
     * @see com.smartgwt.client.widgets.grid.ListGrid#headerHoverHTML
     */
    public boolean getShowClippedHeaderTitlesOnHover()  {
        Boolean result = getAttributeAsBoolean("showClippedHeaderTitlesOnHover");
        return result == null ? true : result;
    }
    

    /**
     * If true and a cell's value is clipped, then a hover containing the full cell value is enabled. <p> Note that standard
     * cell hovers override clipped value hovers. Thus, to enable clipped value hovers, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanHover canHover} must be unset or null and the corresponding field must
     * have {@link com.smartgwt.client.widgets.grid.ListGridField#getShowHover showHover} unset or null as well.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showClippedValuesOnHover New showClippedValuesOnHover value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCanHover
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellValueHoverHTML
     */
    public void setShowClippedValuesOnHover(Boolean showClippedValuesOnHover)  throws IllegalStateException {
        setAttribute("showClippedValuesOnHover", showClippedValuesOnHover, false);
    }

    /**
     * If true and a cell's value is clipped, then a hover containing the full cell value is enabled. <p> Note that standard
     * cell hovers override clipped value hovers. Thus, to enable clipped value hovers, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanHover canHover} must be unset or null and the corresponding field must
     * have {@link com.smartgwt.client.widgets.grid.ListGridField#getShowHover showHover} unset or null as well.
     *
     * @return Current showClippedValuesOnHover value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCanHover
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellValueHoverHTML
     */
    public Boolean getShowClippedValuesOnHover()  {
        return getAttributeAsBoolean("showClippedValuesOnHover");
    }
    

    /**
     * Should group summaries be visible when the group is collapsed? <P> This property only applies to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} grids showing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summary rows}. When set to true, the group summary
     * row(s) for each group will show up under the group header nodes when the group is collapsed, or at then end of the
     * grouped set of data if the group is expanded. <P> This property has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getShowCollapsedGroupSummary showCollapsedGroupSummary}
     *
     * @param showCollapsedGroupSummary new showCollapsedGroupSummary value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setShowCollapsedGroupSummary(Boolean showCollapsedGroupSummary) {
        setAttribute("showCollapsedGroupSummary", showCollapsedGroupSummary, true);
    }

    /**
     * Should group summaries be visible when the group is collapsed? <P> This property only applies to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} grids showing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summary rows}. When set to true, the group summary
     * row(s) for each group will show up under the group header nodes when the group is collapsed, or at then end of the
     * grouped set of data if the group is expanded. <P> This property has no effect if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true.
     *
     * @return Current showCollapsedGroupSummary value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public Boolean getShowCollapsedGroupSummary()  {
        Boolean result = getAttributeAsBoolean("showCollapsedGroupSummary");
        return result == null ? false : result;
    }
    

    /**
     * Whether to include fields marked <code>detail:true</code> from this component's <code>DataSource</code>. <P> When this
     * property is <code>true</code>, the <code>ListGrid</code> will include all detail fields unless fields have been
     * specifically declared using the {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array. <P> Any field
     * which has been included directly in the <code>fields</code> array will be included regardless of the fields
     * <code>detail</code> attribute. <p> Detail fields included will initially be hidden but the user may show these fields
     * via the default header context menu ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu
     * showHeaderContextMenu}). <P> The field's visibility can also be overridden programatically using the standard {@link
     * com.smartgwt.client.widgets.grid.ListGrid#showField showField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#showIf ListGridField.showIf()} APIs, for example, set showIf:"true" to
     * show a detail field initially. <P> Setting this property to false will completely exclude all detail fields from the
     * list grid's fields array, such that they cannot be shown by the user or programmatically.
     *
     * @param showDetailFields New showDetailFields value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setShowDetailFields(Boolean showDetailFields)  throws IllegalStateException {
        setAttribute("showDetailFields", showDetailFields, false);
    }

    /**
     * Whether to include fields marked <code>detail:true</code> from this component's <code>DataSource</code>. <P> When this
     * property is <code>true</code>, the <code>ListGrid</code> will include all detail fields unless fields have been
     * specifically declared using the {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array. <P> Any field
     * which has been included directly in the <code>fields</code> array will be included regardless of the fields
     * <code>detail</code> attribute. <p> Detail fields included will initially be hidden but the user may show these fields
     * via the default header context menu ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu
     * showHeaderContextMenu}). <P> The field's visibility can also be overridden programatically using the standard {@link
     * com.smartgwt.client.widgets.grid.ListGrid#showField showField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#showIf ListGridField.showIf()} APIs, for example, set showIf:"true" to
     * show a detail field initially. <P> Setting this property to false will completely exclude all detail fields from the
     * list grid's fields array, such that they cannot be shown by the user or programmatically.
     *
     * @return Current showDetailFields value. Default value is true
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public Boolean getShowDetailFields()  {
        Boolean result = getAttributeAsBoolean("showDetailFields");
        return result == null ? true : result;
    }
    

    /**
     * Should ellipses be displayed when cell content is clipped? May be overridden at the field  level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowEllipsisWhenClipped ListGridField.showEllipsisWhenClipped}
     *
     * @param showEllipsisWhenClipped New showEllipsisWhenClipped value. Default value is true
     */
    public void setShowEllipsisWhenClipped(boolean showEllipsisWhenClipped) {
        setAttribute("showEllipsisWhenClipped", showEllipsisWhenClipped, true);
    }

    /**
     * Should ellipses be displayed when cell content is clipped? May be overridden at the field  level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowEllipsisWhenClipped ListGridField.showEllipsisWhenClipped}
     *
     * @return Current showEllipsisWhenClipped value. Default value is true
     */
    public boolean getShowEllipsisWhenClipped()  {
        Boolean result = getAttributeAsBoolean("showEllipsisWhenClipped");
        return result == null ? true : result;
    }
    

    /**
     * Indicates whether the text of the emptyMessage property should be displayed if no data is available.
     *
     * @param showEmptyMessage New showEmptyMessage value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setEmptyMessage
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_grid" target="examples">Empty grid Example</a>
     */
    public void setShowEmptyMessage(Boolean showEmptyMessage) {
        setAttribute("showEmptyMessage", showEmptyMessage, true);
    }

    /**
     * Indicates whether the text of the emptyMessage property should be displayed if no data is available.
     *
     * @return Current showEmptyMessage value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessage
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_empty_grid" target="examples">Empty grid Example</a>
     */
    public Boolean getShowEmptyMessage()  {
        Boolean result = getAttributeAsBoolean("showEmptyMessage");
        return result == null ? true : result;
    }
    

    /**
     * If this grid is editable, and an edit has caused validation failure for some cell,  should we show an icon to indicate
     * validation failure?
     *
     * @param showErrorIcons New showErrorIcons value. Default value is true
     */
    public void setShowErrorIcons(boolean showErrorIcons) {
        setAttribute("showErrorIcons", showErrorIcons, true);
    }

    /**
     * If this grid is editable, and an edit has caused validation failure for some cell,  should we show an icon to indicate
     * validation failure?
     *
     * @return Current showErrorIcons value. Default value is true
     */
    public boolean getShowErrorIcons()  {
        Boolean result = getAttributeAsBoolean("showErrorIcons");
        return result == null ? true : result;
    }
    

    /**
     * When {@link com.smartgwt.client.types.ExpansionMode} is <i>editor</i>, should a Save button be shown below the the
     * expanded editor? <P> Note that if an expanded-row containing an editor is collapsed while changes are outstanding,
     * changes will be either be automatically updated to the grid, or will first show a confirmation dialog, according to the
     * value of {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionEditorShowSaveDialog
     * expansionEditorShowSaveDialog}.
     * <p>
     * <b>Note :</b> This method should be called only after the widget has been rendered.
     *
     * @return Current showExpansionEditorSaveButton value. Default value is true
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public Boolean getShowExpansionEditorSaveButton() throws IllegalStateException {
        errorIfNotCreated("showExpansionEditorSaveButton");
        Boolean result = getAttributeAsBoolean("showExpansionEditorSaveButton");
        return result == null ? true : result;
    }
    

    /**
     * Should this listGrid display a filter row.  If true, this ListGrid
     *  will be drawn with a single editable row, (separate from the body) with a filter button.
     *  <P>
     *  Values entered into this row are used as filter criteria to filter this List's data on
     * enter-keypress or filter button click. {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle
     * autoFetchTextMatchStyle} determines
     *  the textMatchStyle for the request passed to {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}.
     *  <P>
     * The default {@link com.smartgwt.client.widgets.form.fields.FormItem#getOperator search operator} for an item in the
     * filterEditor can
     * be set via {@link com.smartgwt.client.widgets.grid.ListGridField#getFilterOperator ListGridField.filterOperator}.   When
     * <code>field.filterOperator</code> 
     *  has been set calls to retrieve the criteria from the grid return {@link com.smartgwt.client.data.AdvancedCriteria}.  
     * See also {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} for a UI that
     * allows end users to change the search
     *  operator on the fly
     *  <P>
     * Note that if {@link com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} is called
     *  directly while the filter editor is showing, the filter editor values will be updated to
     *  reflect the new set of criteria. If you wish to retain the user entered filter criteria
     *  and modify a subset of field values programmatically, this can be achieved by
     *  copying the existing set of criteria and adding other changes - something
     *  like this:
     *  
     *  
     *  <pre><code>
     *    Criteria newCriteria = myListGrid.getFilterEditorCriteria();
     *    newCriteria = DataSource.combineCriteria(newCriteria,
     *       new Criteria("field1", "new value1")
     *    );
     *    myListGrid.setCriteria(newCriteria);
     *  </code></pre>
     *  
     * In this example code we're using {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditorCriteria
     * getFilterEditorCriteria()} rather than
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getCriteria getCriteria()} - this ensures that if the user has typed a
     * new value into
     *  the filter editor, but not yet clicked the filter button, we pick up the value the user
     * entered.  This sample code uses {@link com.smartgwt.client.data.DataSource#combineCriteria DataSource.combineCriteria()}
     * to combine the
     *  existing filterEditorCriteria with some new custom criteria.  This technique is
     *  applicable to both simple and advanced criteria.
     *  <P>
     *  If you call <code>filterData()</code> and pass in criteria for dataSource
     *  fields that are not present in the ListGrid, these criteria will continue to be applied
     *  along with the user-visible criteria.
     *  <P>
     *  <b>filterEditor and advanced criteria</b>: If a developer calls <code>filterData()</code>
     *  on a ListGrid and passes in {@link com.smartgwt.client.data.AdvancedCriteria}, expected behavior of the filter
     *  editor becomes ambiguous, since AdvancedCriteria has far more complex filter
     *  expression support than the ordinary filterEditor can represent.
     *  <P>
     *  Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values
     *  in the filter editor as follows:
     *  <ul>
     *  <li>If the top level criteria has operator of type "and":<br>
     *   Each field in the top level
     *   criteria array for which a 'canFilter' true field is shown in the listGrid will show up
     *   if the specified operator matches the default filter behavior
     * (based on the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle autoFetchTextMatchStyle}).<br>
     *   If the user enters values in the filter editor, these will be combined with the
     *   existing AdvancedCriteria by either replacing or adding field level criteria at the top
     *   level.</li>
     *  <li>If the top level criteria is a single field-criteria:<br>
     *   If the field shows up in the listGrid and is canFilter:true, it will be displayed to
     *   the user (if the operator matches the default filter behavior for the field).<br>
     *   If the user enters new filter criteria in the filterEditor, they will be combined with
     *   this existing criterion via a top level "and" operator, or if the user modifies the
     *   field for which the criterion already existed, it will be replaced.</li>
     *  <li>Otherwise, if there are multiple top level criteria combined with an "or" operator,
     *   these will not be shown in the filter editor. Any filter parameters the user enters will
     *   be added to the existing criteria via an additional top level "and" operator, meaning
     *   the user will essentially filter a subset of the existing criteria</li>
     *  </ul>
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} property. Allows the filter editor to be shown or hidden at runtime.
     *
     * @param showFilterEditor true if the filter editor should be shown, false if it should be hidden. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sortFilter_filter" target="examples">Filter Example</a>
     */
    public void setShowFilterEditor(boolean showFilterEditor) {
        setAttribute("showFilterEditor", showFilterEditor, true);
    }

    /**
     * Should this listGrid display a filter row.  If true, this ListGrid
     *  will be drawn with a single editable row, (separate from the body) with a filter button.
     *  <P>
     *  Values entered into this row are used as filter criteria to filter this List's data on
     * enter-keypress or filter button click. {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle
     * autoFetchTextMatchStyle} determines
     *  the textMatchStyle for the request passed to {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()}.
     *  <P>
     * The default {@link com.smartgwt.client.widgets.form.fields.FormItem#getOperator search operator} for an item in the
     * filterEditor can
     * be set via {@link com.smartgwt.client.widgets.grid.ListGridField#getFilterOperator ListGridField.filterOperator}.   When
     * <code>field.filterOperator</code> 
     *  has been set calls to retrieve the criteria from the grid return {@link com.smartgwt.client.data.AdvancedCriteria}.  
     * See also {@link com.smartgwt.client.widgets.grid.ListGrid#getAllowFilterOperators allowFilterOperators} for a UI that
     * allows end users to change the search
     *  operator on the fly
     *  <P>
     * Note that if {@link com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} is called
     *  directly while the filter editor is showing, the filter editor values will be updated to
     *  reflect the new set of criteria. If you wish to retain the user entered filter criteria
     *  and modify a subset of field values programmatically, this can be achieved by
     *  copying the existing set of criteria and adding other changes - something
     *  like this:
     *  
     *  
     *  <pre><code>
     *    Criteria newCriteria = myListGrid.getFilterEditorCriteria();
     *    newCriteria = DataSource.combineCriteria(newCriteria,
     *       new Criteria("field1", "new value1")
     *    );
     *    myListGrid.setCriteria(newCriteria);
     *  </code></pre>
     *  
     * In this example code we're using {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditorCriteria
     * getFilterEditorCriteria()} rather than
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getCriteria getCriteria()} - this ensures that if the user has typed a
     * new value into
     *  the filter editor, but not yet clicked the filter button, we pick up the value the user
     * entered.  This sample code uses {@link com.smartgwt.client.data.DataSource#combineCriteria DataSource.combineCriteria()}
     * to combine the
     *  existing filterEditorCriteria with some new custom criteria.  This technique is
     *  applicable to both simple and advanced criteria.
     *  <P>
     *  If you call <code>filterData()</code> and pass in criteria for dataSource
     *  fields that are not present in the ListGrid, these criteria will continue to be applied
     *  along with the user-visible criteria.
     *  <P>
     *  <b>filterEditor and advanced criteria</b>: If a developer calls <code>filterData()</code>
     *  on a ListGrid and passes in {@link com.smartgwt.client.data.AdvancedCriteria}, expected behavior of the filter
     *  editor becomes ambiguous, since AdvancedCriteria has far more complex filter
     *  expression support than the ordinary filterEditor can represent.
     *  <P>
     *  Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values
     *  in the filter editor as follows:
     *  <ul>
     *  <li>If the top level criteria has operator of type "and":<br>
     *   Each field in the top level
     *   criteria array for which a 'canFilter' true field is shown in the listGrid will show up
     *   if the specified operator matches the default filter behavior
     * (based on the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle autoFetchTextMatchStyle}).<br>
     *   If the user enters values in the filter editor, these will be combined with the
     *   existing AdvancedCriteria by either replacing or adding field level criteria at the top
     *   level.</li>
     *  <li>If the top level criteria is a single field-criteria:<br>
     *   If the field shows up in the listGrid and is canFilter:true, it will be displayed to
     *   the user (if the operator matches the default filter behavior for the field).<br>
     *   If the user enters new filter criteria in the filterEditor, they will be combined with
     *   this existing criterion via a top level "and" operator, or if the user modifies the
     *   field for which the criterion already existed, it will be replaced.</li>
     *  <li>Otherwise, if there are multiple top level criteria combined with an "or" operator,
     *   these will not be shown in the filter editor. Any filter parameters the user enters will
     *   be added to the existing criteria via an additional top level "and" operator, meaning
     *   the user will essentially filter a subset of the existing criteria</li>
     *  </ul>
     *
     * @return Current showFilterEditor value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sortFilter_filter" target="examples">Filter Example</a>
     */
    public boolean getShowFilterEditor()  {
        Boolean result = getAttributeAsBoolean("showFilterEditor");
        return result == null ? false : result;
    }
    

    /**
     * Should this ListGrid show a summary row beneath the last record of the grid. This summary row will contain per-field
     * summary information. See {@link com.smartgwt.client.widgets.grid.ListGridField#getShowGridSummary
     * ListGridField.showGridSummary} and {@link com.smartgwt.client.widgets.grid.ListGrid#getGridSummaryFunction
     * getGridSummaryFunction()} for details on how the summary value to be displayed for each column will be calculated. <P>
     * Note that the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow autoChild} will be created to
     * actually display the summary row.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} attribute
     *
     * @param showGridSummary new value for this.showGridSummary. Default value is false
     */
    public void setShowGridSummary(Boolean showGridSummary) {
        setAttribute("showGridSummary", showGridSummary, true);
    }

    /**
     * Should this ListGrid show a summary row beneath the last record of the grid. This summary row will contain per-field
     * summary information. See {@link com.smartgwt.client.widgets.grid.ListGridField#getShowGridSummary
     * ListGridField.showGridSummary} and {@link com.smartgwt.client.widgets.grid.ListGrid#getGridSummaryFunction
     * getGridSummaryFunction()} for details on how the summary value to be displayed for each column will be calculated. <P>
     * Note that the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow autoChild} will be created to
     * actually display the summary row.
     *
     * @return Current showGridSummary value. Default value is false
     */
    public Boolean getShowGridSummary()  {
        Boolean result = getAttributeAsBoolean("showGridSummary");
        return result == null ? false : result;
    }
    

    /**
     * If this listGrid supports {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping}, setting this
     * property will cause the grid to render an extra row at the end of each group when grouped, containing summary
     * information for the fields. Summary information will be calculated by the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getGroupSummary ListGridField.getGroupSummary()} method if specified,
     * otherwise via the specified {@link com.smartgwt.client.widgets.grid.ListGridField#getSummaryFunction
     * ListGridField.summaryFunction}.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} attribute
     *
     * @param showGroupSummary new value for this.showGroupSummary. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setGroupByFieldSummaries
     */
    public void setShowGroupSummary(Boolean showGroupSummary) {
        setAttribute("showGroupSummary", showGroupSummary, true);
    }

    /**
     * If this listGrid supports {@link com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy grouping}, setting this
     * property will cause the grid to render an extra row at the end of each group when grouped, containing summary
     * information for the fields. Summary information will be calculated by the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getGroupSummary ListGridField.getGroupSummary()} method if specified,
     * otherwise via the specified {@link com.smartgwt.client.widgets.grid.ListGridField#getSummaryFunction
     * ListGridField.summaryFunction}.
     *
     * @return Current showGroupSummary value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupByFieldSummaries
     */
    public Boolean getShowGroupSummary()  {
        Boolean result = getAttributeAsBoolean("showGroupSummary");
        return result == null ? false : result;
    }
    

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, setting this property causes
     * field summary values for each group to be displayed directly in the group header node, rather than showing up at the
     * bottom of each expanded group. <P> Note that this means the group header node will be showing multiple field values
     * rather than the default display of a single cell spanning all columns containing the group title. Developers may specify
     * an explicit {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField}, or rely on the
     * automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn groupTitleColumn} to
     * have group titles be visible as well as the summary values. <P> Also note that multi-line group summaries are not
     * supported when showing the group summary in the group header. If multiple {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSummaryFunction field summary functions} are defined for some field
     * only the first will be displayed when this property is set to true.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader}
     *
     * @param showGroupSummaryInHeader new showGroupSummaryInHeader state. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public void setShowGroupSummaryInHeader(Boolean showGroupSummaryInHeader) {
        setAttribute("showGroupSummaryInHeader", showGroupSummaryInHeader, true);
    }

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, setting this property causes
     * field summary values for each group to be displayed directly in the group header node, rather than showing up at the
     * bottom of each expanded group. <P> Note that this means the group header node will be showing multiple field values
     * rather than the default display of a single cell spanning all columns containing the group title. Developers may specify
     * an explicit {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField}, or rely on the
     * automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGroupTitleColumn groupTitleColumn} to
     * have group titles be visible as well as the summary values. <P> Also note that multi-line group summaries are not
     * supported when showing the group summary in the group header. If multiple {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getSummaryFunction field summary functions} are defined for some field
     * only the first will be displayed when this property is set to true.
     *
     * @return Current showGroupSummaryInHeader value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public Boolean getShowGroupSummaryInHeader()  {
        Boolean result = getAttributeAsBoolean("showGroupSummaryInHeader");
        return result == null ? false : result;
    }
    

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, instead of
     * group header nodes showing up with a single cell value spanning the full set of columns, summaries for each field will
     * show up in the appropriate columns of the header node. <P> In this case there are 2 options for where the group title
     * will show up. Developers may specify an existing field to put the title values into via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField}. If no groupTitleField is specified, this
     * property may be set to <code>true</code> which causes a <code>groupTitleColumn</code> to be automatically generated.
     * Each group header will show the group title in this column (records within the group will not show a value for this
     * column). The column appears in the leftmost position within the grid (unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true, in which case this column shows up
     * in the second-leftmost position), and by default will auto-fit to its data. <P> To customize this field, developers may
     * modify {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleColumnProperties groupTitleColumnProperties}
     *
     * @param showGroupTitleColumn New showGroupTitleColumn value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setShowGroupTitleColumn(Boolean showGroupTitleColumn)  throws IllegalStateException {
        setAttribute("showGroupTitleColumn", showGroupTitleColumn, false);
    }

    /**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, instead of
     * group header nodes showing up with a single cell value spanning the full set of columns, summaries for each field will
     * show up in the appropriate columns of the header node. <P> In this case there are 2 options for where the group title
     * will show up. Developers may specify an existing field to put the title values into via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField}. If no groupTitleField is specified, this
     * property may be set to <code>true</code> which causes a <code>groupTitleColumn</code> to be automatically generated.
     * Each group header will show the group title in this column (records within the group will not show a value for this
     * column). The column appears in the leftmost position within the grid (unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true, in which case this column shows up
     * in the second-leftmost position), and by default will auto-fit to its data. <P> To customize this field, developers may
     * modify {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleColumnProperties groupTitleColumnProperties}
     *
     * @return Current showGroupTitleColumn value. Default value is true
     */
    public Boolean getShowGroupTitleColumn()  {
        Boolean result = getAttributeAsBoolean("showGroupTitleColumn");
        return result == null ? true : result;
    }
    

    /**
     * If this is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} and has  {@link
     * com.smartgwt.client.docs.FrozenFields frozen fields}, should the group title show in the frozen or unfrozen body? <P>
     * Setting this property to false will cause the group title to show in the  unfrozen body in this case, meaning it will
     * appear to the right of the frozen fields, and scroll horizontally as the user scrolls the unfrozen fields.  This can be
     * useful for grids where there isn't enough available space to show the group title text in the frozen body. <P> Note that
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField} is explicitly set, or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, this property
     * has no effect. In this case rather than the group title showing in a single cell spanning multiple other fields, it will
     * be rendered into a specific column.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showGroupTitleInFrozenBody New showGroupTitleInFrozenBody value. Default value is true
     */
    public void setShowGroupTitleInFrozenBody(boolean showGroupTitleInFrozenBody) {
        setAttribute("showGroupTitleInFrozenBody", showGroupTitleInFrozenBody, true);
    }

    /**
     * If this is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} and has  {@link
     * com.smartgwt.client.docs.FrozenFields frozen fields}, should the group title show in the frozen or unfrozen body? <P>
     * Setting this property to false will cause the group title to show in the  unfrozen body in this case, meaning it will
     * appear to the right of the frozen fields, and scroll horizontally as the user scrolls the unfrozen fields.  This can be
     * useful for grids where there isn't enough available space to show the group title text in the frozen body. <P> Note that
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTitleField groupTitleField} is explicitly set, or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummaryInHeader showGroupSummaryInHeader} is true, this property
     * has no effect. In this case rather than the group title showing in a single cell spanning multiple other fields, it will
     * be rendered into a specific column.
     *
     * @return Current showGroupTitleInFrozenBody value. Default value is true
     */
    public boolean getShowGroupTitleInFrozenBody()  {
        Boolean result = getAttributeAsBoolean("showGroupTitleInFrozenBody");
        return result == null ? true : result;
    }
    

    /**
     * Should we show the header for this ListGrid?
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Show or hide the ListGrid header.
     *
     * @param showHeader true to show the header, false to hide it. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setShowHeader(Boolean showHeader) {
        setAttribute("showHeader", showHeader, true);
    }

    /**
     * Should we show the header for this ListGrid?
     *
     * @return Current showHeader value. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public Boolean getShowHeader()  {
        Boolean result = getAttributeAsBoolean("showHeader");
        return result == null ? true : result;
    }
    

    /**
     * Whether to show a context menu on the header with standard items for showing and hiding fields.  Not supported for
     * {@link com.smartgwt.client.widgets.cube.CubeGrid}.
     *
     * @param showHeaderContextMenu New showHeaderContextMenu value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#displayHeaderContextMenu
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderContextMenuItems
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public void setShowHeaderContextMenu(Boolean showHeaderContextMenu)  throws IllegalStateException {
        setAttribute("showHeaderContextMenu", showHeaderContextMenu, false);
    }

    /**
     * Whether to show a context menu on the header with standard items for showing and hiding fields.  Not supported for
     * {@link com.smartgwt.client.widgets.cube.CubeGrid}.
     *
     * @return Current showHeaderContextMenu value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#displayHeaderContextMenu
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderContextMenuItems
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public Boolean getShowHeaderContextMenu()  {
        Boolean result = getAttributeAsBoolean("showHeaderContextMenu");
        return result == null ? true : result;
    }
    

    /**
     * If set to true and {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu showHeaderContextMenu} is
     * true, the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButton headerMenuButton} will be displayed when
     * the user rolls over the header buttons in this grid.  Not supported for {@link
     * com.smartgwt.client.widgets.cube.CubeGrid}.
     *
     * @param showHeaderMenuButton New showHeaderMenuButton value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setShowHeaderMenuButton(Boolean showHeaderMenuButton)  throws IllegalStateException {
        setAttribute("showHeaderMenuButton", showHeaderMenuButton, false);
    }

    /**
     * If set to true and {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu showHeaderContextMenu} is
     * true, the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButton headerMenuButton} will be displayed when
     * the user rolls over the header buttons in this grid.  Not supported for {@link
     * com.smartgwt.client.widgets.cube.CubeGrid}.
     *
     * @return Current showHeaderMenuButton value. Default value is true
     */
    public Boolean getShowHeaderMenuButton()  {
        Boolean result = getAttributeAsBoolean("showHeaderMenuButton");
        return result == null ? true : result;
    }
    

    /**
     * Should partial selection of all records be shown in header with a special icon? The partial icon will show in the header
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll canSelectAll} is enabled and at least one record
     * is selected but all records are not selected. To only show all selected and none selected states, set this attribute to
     * <code>false</code>.
     *
     * @param showHeaderPartialSelection New showHeaderPartialSelection value. Default value is null
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setShowHeaderPartialSelection(Boolean showHeaderPartialSelection) {
        setAttribute("showHeaderPartialSelection", showHeaderPartialSelection, true);
    }

    /**
     * Should partial selection of all records be shown in header with a special icon? The partial icon will show in the header
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectAll canSelectAll} is enabled and at least one record
     * is selected but all records are not selected. To only show all selected and none selected states, set this attribute to
     * <code>false</code>.
     *
     * @return Current showHeaderPartialSelection value. Default value is null
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public Boolean getShowHeaderPartialSelection()  {
        return getAttributeAsBoolean("showHeaderPartialSelection");
    }
    

    /**
     * Should the header show a drop-shadow? Shadow will be applied to the header, or for a grid with frozen columns, the
     * header layout.  <P> Header shadow will only be displayed if {@link com.smartgwt.client.widgets.Canvas#getUseCSSShadow
     * css shadows} are being used.
     *
     * @param showHeaderShadow New showHeaderShadow value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderShadowVOffset
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderShadowHOffset
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderShadowSoftness
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderShadowColor
     */
    public void setShowHeaderShadow(Boolean showHeaderShadow) {
        setAttribute("showHeaderShadow", showHeaderShadow, true);
    }

    /**
     * Should the header show a drop-shadow? Shadow will be applied to the header, or for a grid with frozen columns, the
     * header layout.  <P> Header shadow will only be displayed if {@link com.smartgwt.client.widgets.Canvas#getUseCSSShadow
     * css shadows} are being used.
     *
     * @return Current showHeaderShadow value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderShadowVOffset
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderShadowHOffset
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderShadowSoftness
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderShadowColor
     */
    public Boolean getShowHeaderShadow()  {
        Boolean result = getAttributeAsBoolean("showHeaderShadow");
        return result == null ? false : result;
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the FormulaBuilder or
     * SummaryBuilder.
     *
     * @param showHeaderSpanTitlesInFormulaBuilder New showHeaderSpanTitlesInFormulaBuilder value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFormulaBuilderSpanTitleSeparator
     */
    public void setShowHeaderSpanTitlesInFormulaBuilder(Boolean showHeaderSpanTitlesInFormulaBuilder) {
        setAttribute("showHeaderSpanTitlesInFormulaBuilder", showHeaderSpanTitlesInFormulaBuilder, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the FormulaBuilder or
     * SummaryBuilder.
     *
     * @return Current showHeaderSpanTitlesInFormulaBuilder value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getFormulaBuilderSpanTitleSeparator
     */
    public Boolean getShowHeaderSpanTitlesInFormulaBuilder()  {
        Boolean result = getAttributeAsBoolean("showHeaderSpanTitlesInFormulaBuilder");
        return result == null ? true : result;
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the {@link
     * com.smartgwt.client.widgets.DataBoundComponent#editHilites hilite editor}.
     *
     * @param showHeaderSpanTitlesInHiliteEditor New showHeaderSpanTitlesInHiliteEditor value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHiliteEditorSpanTitleSeparator
     */
    public void setShowHeaderSpanTitlesInHiliteEditor(Boolean showHeaderSpanTitlesInHiliteEditor) {
        setAttribute("showHeaderSpanTitlesInHiliteEditor", showHeaderSpanTitlesInHiliteEditor, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the {@link
     * com.smartgwt.client.widgets.DataBoundComponent#editHilites hilite editor}.
     *
     * @return Current showHeaderSpanTitlesInHiliteEditor value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHiliteEditorSpanTitleSeparator
     */
    public Boolean getShowHeaderSpanTitlesInHiliteEditor()  {
        Boolean result = getAttributeAsBoolean("showHeaderSpanTitlesInHiliteEditor");
        return result == null ? true : result;
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the {@link
     * com.smartgwt.client.widgets.MultiSortDialog multi-sort editor}.
     *
     * @param showHeaderSpanTitlesInSortEditor New showHeaderSpanTitlesInSortEditor value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortEditorSpanTitleSeparator
     */
    public void setShowHeaderSpanTitlesInSortEditor(Boolean showHeaderSpanTitlesInSortEditor) {
        setAttribute("showHeaderSpanTitlesInSortEditor", showHeaderSpanTitlesInSortEditor, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, should field
     * titles be prefixed with the titles of the headerSpans in which they are contained when using the {@link
     * com.smartgwt.client.widgets.MultiSortDialog multi-sort editor}.
     *
     * @return Current showHeaderSpanTitlesInSortEditor value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortEditorSpanTitleSeparator
     */
    public Boolean getShowHeaderSpanTitlesInSortEditor()  {
        Boolean result = getAttributeAsBoolean("showHeaderSpanTitlesInSortEditor");
        return result == null ? true : result;
    }
    

    /**
     * Determines whether hiliting for any field in this grid is shown in a group summary. This setting affects all fields of
     * the grid. <P> To suppress hilites for a specific field see {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHilitesInGroupSummary ListGridField.showHilitesInGroupSummary}.
     * <P> Hiliting in summary fields (columns) can be enabled by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getIncludeHilitesInSummaryFields includeHiliteInSummaryField} to true.
     *
     * @param showHilitesInGroupSummary New showHilitesInGroupSummary value. Default value is true
     */
    public void setShowHilitesInGroupSummary(boolean showHilitesInGroupSummary) {
        setAttribute("showHilitesInGroupSummary", showHilitesInGroupSummary, true);
    }

    /**
     * Determines whether hiliting for any field in this grid is shown in a group summary. This setting affects all fields of
     * the grid. <P> To suppress hilites for a specific field see {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHilitesInGroupSummary ListGridField.showHilitesInGroupSummary}.
     * <P> Hiliting in summary fields (columns) can be enabled by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getIncludeHilitesInSummaryFields includeHiliteInSummaryField} to true.
     *
     * @return Current showHilitesInGroupSummary value. Default value is true
     */
    public boolean getShowHilitesInGroupSummary()  {
        Boolean result = getAttributeAsBoolean("showHilitesInGroupSummary");
        return result == null ? true : result;
    }
    

    /**
     * If true, and canHover is also true, when the user hovers over a cell, hover text will pop up next to the mouse.  The
     * contents of the hover is determined by {@link com.smartgwt.client.widgets.grid.ListGrid#cellHoverHTML cellHoverHTML()}.
     *
     * @param showHover New showHover value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCanHover
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellHoverHTML
     */
    public void setShowHover(Boolean showHover) {
        setAttribute("showHover", showHover, true);
    }

    /**
     * If true, and canHover is also true, when the user hovers over a cell, hover text will pop up next to the mouse.  The
     * contents of the hover is determined by {@link com.smartgwt.client.widgets.grid.ListGrid#cellHoverHTML cellHoverHTML()}.
     *
     * @return Current showHover value. Default value is true
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCanHover
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellHoverHTML
     */
    public Boolean getShowHover()  {
        Boolean result = getAttributeAsBoolean("showHover");
        return result == null ? true : result;
    }
    

    /**
     * When set to true and canHover is also true, shows a widget hovering at the mouse point. <P> A number of builtin modes
     * are provided - see {@link com.smartgwt.client.types.HoverMode}. <P> Also supported at the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHoverComponents field-level}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showHoverComponents New showHoverComponents value. Default value is false
     */
    public void setShowHoverComponents(Boolean showHoverComponents) {
        setAttribute("showHoverComponents", showHoverComponents, true);
    }

    /**
     * When set to true and canHover is also true, shows a widget hovering at the mouse point. <P> A number of builtin modes
     * are provided - see {@link com.smartgwt.client.types.HoverMode}. <P> Also supported at the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowHoverComponents field-level}.
     *
     * @return Current showHoverComponents value. Default value is false
     */
    public Boolean getShowHoverComponents()  {
        Boolean result = getAttributeAsBoolean("showHoverComponents");
        return result == null ? false : result;
    }
    

    /**
     * When set to true, shows the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field} on
     * initial draw.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showInitialDragHandles New showInitialDragHandles value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see com.smartgwt.client.widgets.grid.ListGrid#hideDragHandles
     * @see com.smartgwt.client.widgets.grid.ListGrid#setDragHandleField
     */
    public void setShowInitialDragHandles(Boolean showInitialDragHandles)  throws IllegalStateException {
        setAttribute("showInitialDragHandles", showInitialDragHandles, false);
    }

    /**
     * When set to true, shows the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field} on
     * initial draw.
     *
     * @return Current showInitialDragHandles value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     * @see com.smartgwt.client.widgets.grid.ListGrid#hideDragHandles
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField
     */
    public Boolean getShowInitialDragHandles()  {
        return getAttributeAsBoolean("showInitialDragHandles");
    }
    

    /**
     * Should partially selected parents (in a Tree data set) be shown with special icon? This has an impact in grouped grids
     * where {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectGroups canSelectGroups} is true. The partial icon
     * will show up for the group header node when a group is partially selected.
     *
     * @param showPartialSelection New showPartialSelection value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public void setShowPartialSelection(Boolean showPartialSelection) {
        setAttribute("showPartialSelection", showPartialSelection, true);
    }

    /**
     * Should partially selected parents (in a Tree data set) be shown with special icon? This has an impact in grouped grids
     * where {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectGroups canSelectGroups} is true. The partial icon
     * will show up for the group header node when a group is partially selected.
     *
     * @return Current showPartialSelection value. Default value is false
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public Boolean getShowPartialSelection()  {
        Boolean result = getAttributeAsBoolean("showPartialSelection");
        return result == null ? false : result;
    }
    

    /**
     * When enabled, {@link com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent createRecordComponent()} will be
     * called when saved rows are being rendered, and any returned component will be displayed embedded within the row or cell.
     * <P> recordComponents are not created for newly added rows which have not yet been saved.   See the {@link
     * com.smartgwt.client.docs.UnsavedRecords Handling Unsaved Records overview} for more information. <P> Depending on the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} setting,
     * <code>createRecordComponent()</code> will be called either once per row, or once for every cell. <P> Depending on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPosition recordComponentPosition}, components can either be
     * placed underneath normal record or cell content ("expand" setting) or placed so that they overlap normal cell content
     * ("within" setting).  For the "within" setting, the default is to fill the row or cell, but the component can specify
     * percent size or even use {@link com.smartgwt.client.widgets.Canvas#getSnapTo snapTo-positioning} to place itself within
     * the row or cell. <p> The "expand" setting is incompatible with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen columns} <i>unless</i> all
     * <code>recordComponents</code> are the same height and they are present in every row, in which case the fixed height of
     * all <code>recordComponents</code> can be set via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentHeight recordComponentHeight} to re-enable frozen fields.
     * <p> Using <code>recordComponents</code> potentially means creating one component for every visible grid row or cell and
     * so can impact performance.  Before using this subsystem: <ul> <li> consider using {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIcons ListGridField.valueIcons} (possibly with a specified      
     * {@link com.smartgwt.client.widgets.grid.ListGridField#addValueIconClickHandler ListGridField.valueIconClick()} handler)
     * for icons based on field values      which may be displayed alone in the cell or alongside standard content      (see
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getShowValueIconOnly ListGridField.showValueIconOnly}); <li> for
     * clickable icons representing actions that can be taken on a record, also       consider using {@link
     * com.smartgwt.client.types.ListGridFieldType a field of type "icon"}, or       multiple such fields <li> for controls
     * that only need to appear on rollover, consider      {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas rollOver controls} <li> if you are trying to customize
     * the editor for a field, you can provide a custom      control via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getEditorType ListGridField.editorType}, and {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getIcons FormItem.icons} are a common      way to add clickable
     * buttons.  You can also      {@link com.smartgwt.client.widgets.grid.ListGrid#getEditorType provide different controls
     * per record}.  These options are      usually better that using <code>recordComponents</code> as custom editors, since   
     * you won't have to manage issues like making the <code>recordComponent</code> appear      only when editing, having
     * changes affect {@link com.smartgwt.client.docs.Editing editValues},      triggering saves and handling validation
     * errors, etc. </ul> <P> See {@link com.smartgwt.client.types.RecordComponentPoolingMode} for an overview of how best to
     * optimize use of <code>recordComponents</code> for different data sets. <p> Regardless of the pooling mode, you can
     * explicitly refresh record components via {@link com.smartgwt.client.widgets.grid.ListGrid#invalidateRecordComponents
     * invalidateRecordComponents()} and {@link com.smartgwt.client.widgets.grid.ListGrid#refreshRecordComponent
     * refreshRecordComponent()}. <P> <i>Interaction with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths column auto-fit}</i>: per-cell record components are not
     * taken into account when determining the size for column auto fit. The default {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} implementation looks at cell
     * content only. We typically recommend that, for fields showing record-components,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} be disabled, or if  the
     * record components are of a predictable size, a {@link com.smartgwt.client.widgets.grid.ListGridField#getDefaultWidth
     * ListGridField.defaultWidth} be specified.<br> This is particularly pertinent where {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPosition recordComponentPosition} is set to "within", in
     * which case cells' content is often empty or completely covered by record-components.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} attribute
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRecordComponents new value for <code>this.showRecordComponents</code>. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRecordComponentPosition
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowRecordComponentsByCell
     * @see com.smartgwt.client.types.RecordComponentPoolingMode
     * @see com.smartgwt.client.widgets.grid.ListGrid#showRecordComponent
     * @see com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent
     * @see com.smartgwt.client.widgets.grid.ListGrid#updateRecordComponent
     */
    public void setShowRecordComponents(Boolean showRecordComponents) {
        setAttribute("showRecordComponents", showRecordComponents, true);
    }

    /**
     * When enabled, {@link com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent createRecordComponent()} will be
     * called when saved rows are being rendered, and any returned component will be displayed embedded within the row or cell.
     * <P> recordComponents are not created for newly added rows which have not yet been saved.   See the {@link
     * com.smartgwt.client.docs.UnsavedRecords Handling Unsaved Records overview} for more information. <P> Depending on the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} setting,
     * <code>createRecordComponent()</code> will be called either once per row, or once for every cell. <P> Depending on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPosition recordComponentPosition}, components can either be
     * placed underneath normal record or cell content ("expand" setting) or placed so that they overlap normal cell content
     * ("within" setting).  For the "within" setting, the default is to fill the row or cell, but the component can specify
     * percent size or even use {@link com.smartgwt.client.widgets.Canvas#getSnapTo snapTo-positioning} to place itself within
     * the row or cell. <p> The "expand" setting is incompatible with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen columns} <i>unless</i> all
     * <code>recordComponents</code> are the same height and they are present in every row, in which case the fixed height of
     * all <code>recordComponents</code> can be set via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentHeight recordComponentHeight} to re-enable frozen fields.
     * <p> Using <code>recordComponents</code> potentially means creating one component for every visible grid row or cell and
     * so can impact performance.  Before using this subsystem: <ul> <li> consider using {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIcons ListGridField.valueIcons} (possibly with a specified      
     * {@link com.smartgwt.client.widgets.grid.ListGridField#addValueIconClickHandler ListGridField.valueIconClick()} handler)
     * for icons based on field values      which may be displayed alone in the cell or alongside standard content      (see
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getShowValueIconOnly ListGridField.showValueIconOnly}); <li> for
     * clickable icons representing actions that can be taken on a record, also       consider using {@link
     * com.smartgwt.client.types.ListGridFieldType a field of type "icon"}, or       multiple such fields <li> for controls
     * that only need to appear on rollover, consider      {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas rollOver controls} <li> if you are trying to customize
     * the editor for a field, you can provide a custom      control via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getEditorType ListGridField.editorType}, and {@link
     * com.smartgwt.client.widgets.form.fields.FormItem#getIcons FormItem.icons} are a common      way to add clickable
     * buttons.  You can also      {@link com.smartgwt.client.widgets.grid.ListGrid#getEditorType provide different controls
     * per record}.  These options are      usually better that using <code>recordComponents</code> as custom editors, since   
     * you won't have to manage issues like making the <code>recordComponent</code> appear      only when editing, having
     * changes affect {@link com.smartgwt.client.docs.Editing editValues},      triggering saves and handling validation
     * errors, etc. </ul> <P> See {@link com.smartgwt.client.types.RecordComponentPoolingMode} for an overview of how best to
     * optimize use of <code>recordComponents</code> for different data sets. <p> Regardless of the pooling mode, you can
     * explicitly refresh record components via {@link com.smartgwt.client.widgets.grid.ListGrid#invalidateRecordComponents
     * invalidateRecordComponents()} and {@link com.smartgwt.client.widgets.grid.ListGrid#refreshRecordComponent
     * refreshRecordComponent()}. <P> <i>Interaction with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths column auto-fit}</i>: per-cell record components are not
     * taken into account when determining the size for column auto fit. The default {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFieldWidth getDefaultFieldWidth()} implementation looks at cell
     * content only. We typically recommend that, for fields showing record-components,  {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getCanAutoFitWidth ListGridField.canAutoFitWidth} be disabled, or if  the
     * record components are of a predictable size, a {@link com.smartgwt.client.widgets.grid.ListGridField#getDefaultWidth
     * ListGridField.defaultWidth} be specified.<br> This is particularly pertinent where {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPosition recordComponentPosition} is set to "within", in
     * which case cells' content is often empty or completely covered by record-components.
     *
     * @return Current showRecordComponents value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPosition
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * @see com.smartgwt.client.types.RecordComponentPoolingMode
     * @see com.smartgwt.client.widgets.grid.ListGrid#showRecordComponent
     * @see com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent
     * @see com.smartgwt.client.widgets.grid.ListGrid#updateRecordComponent
     */
    public Boolean getShowRecordComponents()  {
        return getAttributeAsBoolean("showRecordComponents");
    }
    

    /**
     * If true, shows {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents} in cells,
     * rather than just in records.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRecordComponentsByCell New showRecordComponentsByCell value. Default value is null
     */
    public void setShowRecordComponentsByCell(Boolean showRecordComponentsByCell) {
        if(showRecordComponentsByCell) setRecordComponentPosition(EmbeddedPosition.WITHIN);
        setAttribute("showRecordComponentsByCell", showRecordComponentsByCell, true);
    }

    /**
     * If true, shows {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents} in cells,
     * rather than just in records.
     *
     * @return Current showRecordComponentsByCell value. Default value is null
     */
    public Boolean getShowRecordComponentsByCell()  {
        return getAttributeAsBoolean("showRecordComponentsByCell");
    }
    

    /**
     * Should we show different styling for the cell the mouse is over? <p> If true, the cell style will have the suffix "Over"
     * appended. <p> Can be overridden on a per-record basis via {@link
     * com.smartgwt.client.widgets.grid.ListGridRecord#getShowRollOver ListGridRecord.showRollOver}.
     *
     * @param showRollOver New showRollOver value. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setShowRollOver(Boolean showRollOver) {
        setAttribute("showRollOver", showRollOver, true);
    }

    /**
     * Should we show different styling for the cell the mouse is over? <p> If true, the cell style will have the suffix "Over"
     * appended. <p> Can be overridden on a per-record basis via {@link
     * com.smartgwt.client.widgets.grid.ListGridRecord#getShowRollOver ListGridRecord.showRollOver}.
     *
     * @return Current showRollOver value. Default value is true
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public Boolean getShowRollOver()  {
        Boolean result = getAttributeAsBoolean("showRollOver");
        return result == null ? true : result;
    }
    

    /**
     * When enabled, when the mouse moves over a row or cell (depending on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers}), an arbitrary Canvas can be shown
     * layered on top of the row or cell (the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas
     * rollOverCanvas}), layered underneath the row or cell (the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas}), or both.  <P> This can be used to
     * dynamically show controls or informational displays only on rollover.  For example, controls to delete a row might
     * appear only on rollover so they do not clutter the static display, or a "rollUnder" Canvas could be used to display
     * additional information that can appear behind normal cell values (like displaying percent complete via as a bar of color
     * that appears behind text values). <p> {@link com.smartgwt.client.widgets.Canvas#getSnapTo snapTo positioning} can be
     * used to place the rollOver/rollUnderCanvas.  With <code>useCellRollOvers</code>, positioning is relative to the cell,
     * for row-level rollOver, position is relative to the portion of the row that is scrolled into view (this implies a
     * row-level rollOver/UnderCanvas can never be placed horizontally scrolled out of view, but this is possible for a
     * cell-level rollOver).   <p> <code>snapTo</code> positioning makes it easy to do something like place a button at the
     * right edge of the grid, next to the scrollbar: just set snapTo:"R" on the <code>rollOverCanvas</code>. <p> The
     * rollOver/rollUnder Canvas can be a single static component (the same for all cells/rows) configured via the {@link
     * com.smartgwt.client.types.AutoChild} system, or can instead be provided dynamically by implementing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas getRollOverCanvas()} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas getRollUnderCanvas()}. <p> The rollOver/rollUnder canvas
     * will be automatically added to the grid's {@link com.smartgwt.client.widgets.grid.ListGrid#getBody body} as an  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEmbeddedComponent embedded component}.<br> For grids with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, the behavior is as follows: <ul><li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is false (the default), embedded
     * components   will be added to both the body and the frozen body</li> <li>Otherwise the component will be added to
     * whichever body contains the cell the   user is currently over</li></ul> The rollOver/rollUnder canvas added to the
     * frozen body will be created by calling the {@link com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollOverCanvas
     * getFrozenRollOverCanvas()} or {@link com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollUnderCanvas
     * getFrozenRollUnderCanvas()} methods. The default implementation for these methods matches their equivalents for
     * non-frozen rollOver / rollUnder canvases - it will use the autoChild subsystem to create a canvas from the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas} autoChild configuration. <p>
     * <code>showRollOverCanvas</code> has no effect if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver
     * showRollOver} is <code>false</code>. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas showSelectedRollOverCanvas}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRollOverCanvas New showRollOverCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowRollUnderCanvas
     * 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_rollover_controls" target="examples">RollOver Controls Example</a>
     */
    public void setShowRollOverCanvas(Boolean showRollOverCanvas) {
        setAttribute("showRollOverCanvas", showRollOverCanvas, true);
    }

    /**
     * When enabled, when the mouse moves over a row or cell (depending on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers}), an arbitrary Canvas can be shown
     * layered on top of the row or cell (the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas
     * rollOverCanvas}), layered underneath the row or cell (the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas}), or both.  <P> This can be used to
     * dynamically show controls or informational displays only on rollover.  For example, controls to delete a row might
     * appear only on rollover so they do not clutter the static display, or a "rollUnder" Canvas could be used to display
     * additional information that can appear behind normal cell values (like displaying percent complete via as a bar of color
     * that appears behind text values). <p> {@link com.smartgwt.client.widgets.Canvas#getSnapTo snapTo positioning} can be
     * used to place the rollOver/rollUnderCanvas.  With <code>useCellRollOvers</code>, positioning is relative to the cell,
     * for row-level rollOver, position is relative to the portion of the row that is scrolled into view (this implies a
     * row-level rollOver/UnderCanvas can never be placed horizontally scrolled out of view, but this is possible for a
     * cell-level rollOver).   <p> <code>snapTo</code> positioning makes it easy to do something like place a button at the
     * right edge of the grid, next to the scrollbar: just set snapTo:"R" on the <code>rollOverCanvas</code>. <p> The
     * rollOver/rollUnder Canvas can be a single static component (the same for all cells/rows) configured via the {@link
     * com.smartgwt.client.types.AutoChild} system, or can instead be provided dynamically by implementing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas getRollOverCanvas()} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas getRollUnderCanvas()}. <p> The rollOver/rollUnder canvas
     * will be automatically added to the grid's {@link com.smartgwt.client.widgets.grid.ListGrid#getBody body} as an  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEmbeddedComponent embedded component}.<br> For grids with {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, the behavior is as follows: <ul><li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is false (the default), embedded
     * components   will be added to both the body and the frozen body</li> <li>Otherwise the component will be added to
     * whichever body contains the cell the   user is currently over</li></ul> The rollOver/rollUnder canvas added to the
     * frozen body will be created by calling the {@link com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollOverCanvas
     * getFrozenRollOverCanvas()} or {@link com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollUnderCanvas
     * getFrozenRollUnderCanvas()} methods. The default implementation for these methods matches their equivalents for
     * non-frozen rollOver / rollUnder canvases - it will use the autoChild subsystem to create a canvas from the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas} autoChild configuration. <p>
     * <code>showRollOverCanvas</code> has no effect if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver
     * showRollOver} is <code>false</code>. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas showSelectedRollOverCanvas}.
     *
     * @return Current showRollOverCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowRollUnderCanvas
     * 
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_rollover_controls" target="examples">RollOver Controls Example</a>
     */
    public Boolean getShowRollOverCanvas()  {
        return getAttributeAsBoolean("showRollOverCanvas");
    }
    

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas roll over canvas} to be sized
     * to cover the normal row and the expansion layout. Otherwise the rollOverCanvas is only shown for the un-expanded part of
     * the row.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRollOverInExpansion New showRollOverInExpansion value. Default value is null
     */
    public void setShowRollOverInExpansion(Boolean showRollOverInExpansion) {
        setAttribute("showRollOverInExpansion", showRollOverInExpansion, true);
    }

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas roll over canvas} to be sized
     * to cover the normal row and the expansion layout. Otherwise the rollOverCanvas is only shown for the un-expanded part of
     * the row.
     *
     * @return Current showRollOverInExpansion value. Default value is null
     */
    public Boolean getShowRollOverInExpansion()  {
        return getAttributeAsBoolean("showRollOverInExpansion");
    }
    

    /**
     * If roll overs are enabled, should the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas
     * rollUnderCanvas} be displayed? <p> Use of the <code>showRollUnderCanvas</code> is enabled if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver} is <code>true</code>, and either {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas showRollOverCanvas} is <code>true</code> and
     * <code>showRollUnderCanvas</code> is unset, or <code>showRollUnderCanvas</code> is explicitly set to <code>true</code>.
     * <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollUnderCanvas
     * showSelectedRollUnderCanvas}.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRollUnderCanvas New showRollUnderCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowRollOverCanvas
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public void setShowRollUnderCanvas(Boolean showRollUnderCanvas) {
        setAttribute("showRollUnderCanvas", showRollUnderCanvas, true);
    }

    /**
     * If roll overs are enabled, should the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas
     * rollUnderCanvas} be displayed? <p> Use of the <code>showRollUnderCanvas</code> is enabled if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOver showRollOver} is <code>true</code>, and either {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas showRollOverCanvas} is <code>true</code> and
     * <code>showRollUnderCanvas</code> is unset, or <code>showRollUnderCanvas</code> is explicitly set to <code>true</code>.
     * <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollUnderCanvas
     * showSelectedRollUnderCanvas}.
     *
     * @return Current showRollUnderCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_animated_selection" target="examples">Animated Selection Example</a>
     */
    public Boolean getShowRollUnderCanvas()  {
        return getAttributeAsBoolean("showRollUnderCanvas");
    }
    

    /**
     * When set to true, shows an additional field at the beginning of the field-list (respecting RTL) that displays the
     * current rowNum for each record.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showRowNumbers New showRowNumbers value. Default value is null
     */
    public void setShowRowNumbers(Boolean showRowNumbers) {
        setAttribute("showRowNumbers", showRowNumbers, true);
    }

    /**
     * When set to true, shows an additional field at the beginning of the field-list (respecting RTL) that displays the
     * current rowNum for each record.
     *
     * @return Current showRowNumbers value. Default value is null
     */
    public Boolean getShowRowNumbers()  {
        return getAttributeAsBoolean("showRowNumbers");
    }
    

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas roll over canvas} to be
     * displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be
     * useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showSelectedRollOverCanvas New showSelectedRollOverCanvas value. Default value is false
     */
    public void setShowSelectedRollOverCanvas(Boolean showSelectedRollOverCanvas) {
        setAttribute("showSelectedRollOverCanvas", showSelectedRollOverCanvas, true);
    }

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas roll over canvas} to be
     * displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be
     * useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling.
     *
     * @return Current showSelectedRollOverCanvas value. Default value is false
     */
    public Boolean getShowSelectedRollOverCanvas()  {
        Boolean result = getAttributeAsBoolean("showSelectedRollOverCanvas");
        return result == null ? false : result;
    }
    

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas roll under canvas} to be
     * displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be
     * useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling. <P> As with
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollUnderCanvas showRollUnderCanvas}, if this property is unset,
     * but the related {@link com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas
     * showSelectedRollOverCanvas} property is true, both the the roll under and roll under canvases will be displayed as the
     * user rolls  over selected records.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showSelectedRollUnderCanvas New showSelectedRollUnderCanvas value. Default value is false
     */
    public void setShowSelectedRollUnderCanvas(Boolean showSelectedRollUnderCanvas) {
        setAttribute("showSelectedRollUnderCanvas", showSelectedRollUnderCanvas, true);
    }

    /**
     * This setting causes the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas roll under canvas} to be
     * displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be
     * useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling. <P> As with
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollUnderCanvas showRollUnderCanvas}, if this property is unset,
     * but the related {@link com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas
     * showSelectedRollOverCanvas} property is true, both the the roll under and roll under canvases will be displayed as the
     * user rolls  over selected records.
     *
     * @return Current showSelectedRollUnderCanvas value. Default value is false
     */
    public Boolean getShowSelectedRollUnderCanvas()  {
        Boolean result = getAttributeAsBoolean("showSelectedRollUnderCanvas");
        return result == null ? false : result;
    }
    

    /**
     * Should the "Selected" style be applied to selected records?
     *
     * @param showSelectedStyle New showSelectedStyle value. Default value is true
     */
    public void setShowSelectedStyle(Boolean showSelectedStyle) {
        setAttribute("showSelectedStyle", showSelectedStyle, true);
    }

    /**
     * Should the "Selected" style be applied to selected records?
     *
     * @return Current showSelectedStyle value. Default value is true
     */
    public Boolean getShowSelectedStyle()  {
        Boolean result = getAttributeAsBoolean("showSelectedStyle");
        return result == null ? true : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is set to  {@link
     * com.smartgwt.client.types.SelectionStyle#SINGLE}, setting this property to <code>true</code> means selection will be
     * displayed to the user with the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas}
     * and/or {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} rather than with
     * CSS styling. <p> If <code>showSelectionCanvas</code> is set to <code>true</code>, then the
     * <code>selectionUnderCanvas</code> will automatically be enabled unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionUnderCanvas showSelectionUnderCanvas} is set to
     * <code>false</code>. <p> NOTE: It is recommended to use the <code>selectionUnderCanvas</code> rather than the
     * <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code> is stacked on top of the selected
     * record and this may interfere with event handling in rare cases. If no interactive components are shown in the
     * <code>selectionCanvas</code> and it simply provides custom styling, then the <code>selectionUnderCanvas</code> should be
     * used instead. <p> With {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen fields}, the
     * <code>selectionCanvas</code> is displayed only over the non-frozen fields of the selected row.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showSelectionCanvas New showSelectionCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowSelectionUnderCanvas
     */
    public void setShowSelectionCanvas(Boolean showSelectionCanvas) {
        setAttribute("showSelectionCanvas", showSelectionCanvas, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is set to  {@link
     * com.smartgwt.client.types.SelectionStyle#SINGLE}, setting this property to <code>true</code> means selection will be
     * displayed to the user with the {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas}
     * and/or {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} rather than with
     * CSS styling. <p> If <code>showSelectionCanvas</code> is set to <code>true</code>, then the
     * <code>selectionUnderCanvas</code> will automatically be enabled unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionUnderCanvas showSelectionUnderCanvas} is set to
     * <code>false</code>. <p> NOTE: It is recommended to use the <code>selectionUnderCanvas</code> rather than the
     * <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code> is stacked on top of the selected
     * record and this may interfere with event handling in rare cases. If no interactive components are shown in the
     * <code>selectionCanvas</code> and it simply provides custom styling, then the <code>selectionUnderCanvas</code> should be
     * used instead. <p> With {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen fields}, the
     * <code>selectionCanvas</code> is displayed only over the non-frozen fields of the selected row.
     *
     * @return Current showSelectionCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionUnderCanvas
     */
    public Boolean getShowSelectionCanvas()  {
        return getAttributeAsBoolean("showSelectionCanvas");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is set to  {@link
     * com.smartgwt.client.types.SelectionStyle#SINGLE}, and either {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionCanvas showSelectionCanvas} is <code>true</code> and
     * <code>showSelectionUnderCanvas</code> is unset, or <code>showSelectionUnderCanvas</code> is explicitly set to
     * <code>true</code>, then selection will be displayed to the user with the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} rather than with CSS styling.
     * Setting <code>showSelectionUnderCanvas</code> to <code>false</code> will disable the use of the
     * <code>selectionUnderCanvas</code>. <p> With {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen
     * fields}, the <code>selectionUnderCanvas</code> is displayed only behind the non-frozen fields of the selected row.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showSelectionUnderCanvas New showSelectionUnderCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setShowSelectionCanvas
     * 
     */
    public void setShowSelectionUnderCanvas(Boolean showSelectionUnderCanvas) {
        setAttribute("showSelectionUnderCanvas", showSelectionUnderCanvas, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is set to  {@link
     * com.smartgwt.client.types.SelectionStyle#SINGLE}, and either {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionCanvas showSelectionCanvas} is <code>true</code> and
     * <code>showSelectionUnderCanvas</code> is unset, or <code>showSelectionUnderCanvas</code> is explicitly set to
     * <code>true</code>, then selection will be displayed to the user with the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionCanvas selectionCanvas} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionUnderCanvas selectionUnderCanvas} rather than with CSS styling.
     * Setting <code>showSelectionUnderCanvas</code> to <code>false</code> will disable the use of the
     * <code>selectionUnderCanvas</code>. <p> With {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields frozen
     * fields}, the <code>selectionUnderCanvas</code> is displayed only behind the non-frozen fields of the selected row.
     *
     * @return Current showSelectionUnderCanvas value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowSelectionCanvas
     * 
     */
    public Boolean getShowSelectionUnderCanvas()  {
        return getAttributeAsBoolean("showSelectionUnderCanvas");
    }
    

    /**
     * Indicates whether a sorting arrow should appear for the listGrid, and its location. See {@link
     * com.smartgwt.client.types.SortArrow} for details. <P> Clicking the sort arrow reverses the direction of sorting for the
     * current sort column (if any), or sorts the listGrid by its first sortable column. The arrow image on the button
     * indicates the current direction of sorting. If undefined, the sort arrow will show up in the sorted field, and the
     * corner sort button will be displayed if a vertical scrollbar is being displayed
     *
     * @param showSortArrow New showSortArrow value. Default value is null
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setShowSortArrow(SortArrow showSortArrow) {
        setAttribute("showSortArrow", showSortArrow == null ? null : showSortArrow.getValue(), true);
    }

    /**
     * Indicates whether a sorting arrow should appear for the listGrid, and its location. See {@link
     * com.smartgwt.client.types.SortArrow} for details. <P> Clicking the sort arrow reverses the direction of sorting for the
     * current sort column (if any), or sorts the listGrid by its first sortable column. The arrow image on the button
     * indicates the current direction of sorting. If undefined, the sort arrow will show up in the sorted field, and the
     * corner sort button will be displayed if a vertical scrollbar is being displayed
     *
     * @return Current showSortArrow value. Default value is null
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public SortArrow getShowSortArrow()  {
        return EnumUtil.getEnum(SortArrow.values(), getAttribute("showSortArrow"));
    }
    

    /**
     * When multiple fields are sorted, set this to false to hide the sort-numeral displayed by default after the sort-arrows
     * in the header-buttons of sorted fields.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param showSortNumerals New showSortNumerals value. Default value is null
     */
    public void setShowSortNumerals(Boolean showSortNumerals) {
        setAttribute("showSortNumerals", showSortNumerals, true);
    }

    /**
     * When multiple fields are sorted, set this to false to hide the sort-numeral displayed by default after the sort-arrows
     * in the header-buttons of sorted fields.
     *
     * @return Current showSortNumerals value. Default value is null
     */
    public Boolean getShowSortNumerals()  {
        return getAttributeAsBoolean("showSortNumerals");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans} are in use, whether to show a
     * hierarchical column picker that includes both headerSpans and normal headers, with normal headers indented under
     * headerSpans similarly to how a {@link com.smartgwt.client.widgets.tree.TreeGrid} displays a Tree. <P> If
     * <code>showTreeColumnPicker</code> is false, no column picker will be shown on the headerSpan itself, and the column
     * picker for a clicked on a normal field header will include only normal fields.
     *
     * @param showTreeColumnPicker New showTreeColumnPicker value. Default value is true
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setShowTreeColumnPicker(Boolean showTreeColumnPicker)  throws IllegalStateException {
        setAttribute("showTreeColumnPicker", showTreeColumnPicker, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans} are in use, whether to show a
     * hierarchical column picker that includes both headerSpans and normal headers, with normal headers indented under
     * headerSpans similarly to how a {@link com.smartgwt.client.widgets.tree.TreeGrid} displays a Tree. <P> If
     * <code>showTreeColumnPicker</code> is false, no column picker will be shown on the headerSpan itself, and the column
     * picker for a clicked on a normal field header will include only normal fields.
     *
     * @return Current showTreeColumnPicker value. Default value is true
     */
    public Boolean getShowTreeColumnPicker()  {
        Boolean result = getAttributeAsBoolean("showTreeColumnPicker");
        return result == null ? true : result;
    }
    

    /**
     * If this list grid is showing any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen} fields, and a
     * horizontal scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap be left visible
     * below the frozen columns?<br> Note that if set to <code>true</code> any backgroundColor or border applied to the
     * ListGrid will show up below the bottom row of the frozen column(s).
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param shrinkForFreeze New shrinkForFreeze value. Default value is false
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public void setShrinkForFreeze(Boolean shrinkForFreeze) {
        setAttribute("shrinkForFreeze", shrinkForFreeze, true);
    }

    /**
     * If this list grid is showing any {@link com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen} fields, and a
     * horizontal scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap be left visible
     * below the frozen columns?<br> Note that if set to <code>true</code> any backgroundColor or border applied to the
     * ListGrid will show up below the bottom row of the frozen column(s).
     *
     * @return Current shrinkForFreeze value. Default value is false
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public Boolean getShrinkForFreeze()  {
        Boolean result = getAttributeAsBoolean("shrinkForFreeze");
        return result == null ? false : result;
    }
    

    /**
     * If <code>record[this.singleCellValueProperty]</code> is set for some record, the record will be displayed as a single
     * cell spanning every column in the grid, with contents set to the value of
     * <code>record[this.singleCellValueProperty]</code>.
     *
     * @param singleCellValueProperty New singleCellValueProperty value. Default value is "singleCellValue"
     */
    public void setSingleCellValueProperty(String singleCellValueProperty) {
        setAttribute("singleCellValueProperty", singleCellValueProperty, true);
    }

    /**
     * If <code>record[this.singleCellValueProperty]</code> is set for some record, the record will be displayed as a single
     * cell spanning every column in the grid, with contents set to the value of
     * <code>record[this.singleCellValueProperty]</code>.
     *
     * @return Current singleCellValueProperty value. Default value is "singleCellValue"
     */
    public String getSingleCellValueProperty()  {
        return getAttributeAsString("singleCellValueProperty");
    }
    

    /**
     * Where do 'skin' images (those provided with the class) live?
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param skinImgDir New skinImgDir value. Default value is "images/ListGrid/"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Images Images overview and related methods
     */
    public void setSkinImgDir(String skinImgDir) {
        setAttribute("skinImgDir", skinImgDir, true);
    }

    /**
     * Where do 'skin' images (those provided with the class) live?
     *
     * @return Current skinImgDir value. Default value is "images/ListGrid/"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     * @see com.smartgwt.client.docs.Images Images overview and related methods
     */
    public String getSkinImgDir()  {
        return getAttributeAsString("skinImgDir");
    }
    

    /**
     * Whether to skip line breaks for all fields by default when {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getEscapeHTML escaping HTML}.  This property can be overridden at the
     * field level by {@link com.smartgwt.client.widgets.grid.ListGridField#getSkipLineBreaks ListGridField.skipLineBreaks}.
     *
     * @param skipLineBreaks New skipLineBreaks value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#setEscapeHTML
     */
    public void setSkipLineBreaks(Boolean skipLineBreaks) {
        setAttribute("skipLineBreaks", skipLineBreaks, true);
    }

    /**
     * Whether to skip line breaks for all fields by default when {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getEscapeHTML escaping HTML}.  This property can be overridden at the
     * field level by {@link com.smartgwt.client.widgets.grid.ListGridField#getSkipLineBreaks ListGridField.skipLineBreaks}.
     *
     * @return Current skipLineBreaks value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#getEscapeHTML
     */
    public Boolean getSkipLineBreaks()  {
        return getAttributeAsBoolean("skipLineBreaks");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getLeaveHeaderMenuButtonSpace leaveHeaderMenuButtonSpace} is true,
     * configures the amount of space beyond the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonWidth
     * headerMenuButtonWidth} on the right side of a ListGrid header button (left for {@link
     * com.smartgwt.client.util.Page#isRTL RTL mode}) to reserve for the sort arrow if sorting is active for that field and the
     * arrow will be shown.  May be increased for more separation between the sort arrow and the title text, at the expense of
     * a reduced space for the title text. <P> This value may need to be customized in your skin or if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortAscendingImage sortAscendingImage} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortDescendingImage sortDescendingImage} are changed.
     *
     * @param sortArrowMenuButtonSpaceOffset New sortArrowMenuButtonSpaceOffset value. Default value is 7
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortNumeralMenuButtonSpaceOffset
     */
    public void setSortArrowMenuButtonSpaceOffset(int sortArrowMenuButtonSpaceOffset) {
        setAttribute("sortArrowMenuButtonSpaceOffset", sortArrowMenuButtonSpaceOffset, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getLeaveHeaderMenuButtonSpace leaveHeaderMenuButtonSpace} is true,
     * configures the amount of space beyond the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonWidth
     * headerMenuButtonWidth} on the right side of a ListGrid header button (left for {@link
     * com.smartgwt.client.util.Page#isRTL RTL mode}) to reserve for the sort arrow if sorting is active for that field and the
     * arrow will be shown.  May be increased for more separation between the sort arrow and the title text, at the expense of
     * a reduced space for the title text. <P> This value may need to be customized in your skin or if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortAscendingImage sortAscendingImage} or  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortDescendingImage sortDescendingImage} are changed.
     *
     * @return Current sortArrowMenuButtonSpaceOffset value. Default value is 7
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralMenuButtonSpaceOffset
     */
    public int getSortArrowMenuButtonSpaceOffset()  {
        return getAttributeAsInt("sortArrowMenuButtonSpaceOffset");
    }
    

    /**
     * Image to show when sorting ascending. See {@link com.smartgwt.client.widgets.ImgProperties} for format.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param sortAscendingImage New sortAscendingImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortArrowMenuButtonSpaceOffset
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setSortAscendingImage(ImgProperties sortAscendingImage) {
        setAttribute("sortAscendingImage", sortAscendingImage == null ? null : sortAscendingImage.getJsObj(), true);
    }

    /**
     * Image to show when sorting ascending. See {@link com.smartgwt.client.widgets.ImgProperties} for format.
     *
     * @return Current sortAscendingImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortArrowMenuButtonSpaceOffset
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public ImgProperties getSortAscendingImage()  {
        return new ImgProperties(getAttributeAsJavaScriptObject("sortAscendingImage"));
    }
    

    /**
     * For any fields of {@link com.smartgwt.client.types.FieldType type "binary"}, should sorting be performed against the
     * fileName of the value for the field? For Smart GWT server backed dataSources, this is applied to the record
     * automatically as described in the {@link com.smartgwt.client.docs.BinaryFields} overview. <P> If set to false, binary
     * fields will be sorted against the record value for the field in question. Client-side sorting does not support this, so
     * developers who actually want to support a sort against the binary itself would typically set {@link
     * com.smartgwt.client.data.ResultSet#getUseClientSorting ResultSet.useClientSorting} to false on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataProperties dataProperties} block for this grid. <P> Note that this
     * setting will have no effect if {@link com.smartgwt.client.data.DataSourceField#getSortByField
     * DataSourceField.sortByField} is specified
     *
     * @param sortBinaryByFileName New sortBinaryByFileName value. Default value is true
     */
    public void setSortBinaryByFileName(boolean sortBinaryByFileName) {
        setAttribute("sortBinaryByFileName", sortBinaryByFileName, true);
    }

    /**
     * For any fields of {@link com.smartgwt.client.types.FieldType type "binary"}, should sorting be performed against the
     * fileName of the value for the field? For Smart GWT server backed dataSources, this is applied to the record
     * automatically as described in the {@link com.smartgwt.client.docs.BinaryFields} overview. <P> If set to false, binary
     * fields will be sorted against the record value for the field in question. Client-side sorting does not support this, so
     * developers who actually want to support a sort against the binary itself would typically set {@link
     * com.smartgwt.client.data.ResultSet#getUseClientSorting ResultSet.useClientSorting} to false on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataProperties dataProperties} block for this grid. <P> Note that this
     * setting will have no effect if {@link com.smartgwt.client.data.DataSourceField#getSortByField
     * DataSourceField.sortByField} is specified
     *
     * @return Current sortBinaryByFileName value. Default value is true
     */
    public boolean getSortBinaryByFileName()  {
        Boolean result = getAttributeAsBoolean("sortBinaryByFileName");
        return result == null ? true : result;
    }
    

    /**
     * If set, whenever grouping is performed by an end user or by a programmatic call to  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()}, data is implicitly sorted by all of the grouped columns,
     * in the order  they were passed to groupBy. Any user-configured sorting is applied after sorting by  grouped columns. <p>
     * Sorting by grouped fields will be in ascending or descending order according to whether  the grid is currently sorted
     * (by any field) in ascending or descending order, defaulting  to ascending if the grid is not sorted. Implicit sorting by
     * group can be forced to be  always ascending or always descending by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupSortDirection groupSortDirection}. <p> The sorting is "implicit" in
     * the sense that the sorting is not shown in the ListGrid  headers, and not shown in the {@link
     * com.smartgwt.client.widgets.MultiSortDialog} if enabled.  An end user cannot  currently remove the implicit sorting
     * themselves (except by removing the grouping),  though it is possible to override it by providing an explicit sort on the
     * group's column. Clicking on the grouped field's header reveals the usual sort indicators with all the same semantics.
     * <p> The correct way to remove implicit sorting programmatically is to call  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSortByGroupFirst setSortByGroupFirst(false)}. <p> Programmatic calls to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()} will not include the implicit sort in  the list of
     * return sort specifiers, and calls to {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} will implicitly
     * add  the sorting by grouped columns before the specified sort. <p> Note that directly calling ResultSet.getSort() will
     * include the implicit sort  information.
     *
     * @param sortByGroupFirst New sortByGroupFirst value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#setGroupSortDirection
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupSortNormalizer
     */
    public void setSortByGroupFirst(Boolean sortByGroupFirst) {
        setAttribute("sortByGroupFirst", sortByGroupFirst, true);
    }

    /**
     * If set, whenever grouping is performed by an end user or by a programmatic call to  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy groupBy()}, data is implicitly sorted by all of the grouped columns,
     * in the order  they were passed to groupBy. Any user-configured sorting is applied after sorting by  grouped columns. <p>
     * Sorting by grouped fields will be in ascending or descending order according to whether  the grid is currently sorted
     * (by any field) in ascending or descending order, defaulting  to ascending if the grid is not sorted. Implicit sorting by
     * group can be forced to be  always ascending or always descending by setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupSortDirection groupSortDirection}. <p> The sorting is "implicit" in
     * the sense that the sorting is not shown in the ListGrid  headers, and not shown in the {@link
     * com.smartgwt.client.widgets.MultiSortDialog} if enabled.  An end user cannot  currently remove the implicit sorting
     * themselves (except by removing the grouping),  though it is possible to override it by providing an explicit sort on the
     * group's column. Clicking on the grouped field's header reveals the usual sort indicators with all the same semantics.
     * <p> The correct way to remove implicit sorting programmatically is to call  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSortByGroupFirst setSortByGroupFirst(false)}. <p> Programmatic calls to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()} will not include the implicit sort in  the list of
     * return sort specifiers, and calls to {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} will implicitly
     * add  the sorting by grouped columns before the specified sort. <p> Note that directly calling ResultSet.getSort() will
     * include the implicit sort  information.
     *
     * @return Current sortByGroupFirst value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupSortDirection
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupSortNormalizer
     */
    public Boolean getSortByGroupFirst()  {
        return getAttributeAsBoolean("sortByGroupFirst");
    }
    

    /**
     * Image to show when sorting descending. See {@link com.smartgwt.client.widgets.ImgProperties} for format.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param sortDescendingImage New sortDescendingImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortArrowMenuButtonSpaceOffset
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setSortDescendingImage(ImgProperties sortDescendingImage) {
        setAttribute("sortDescendingImage", sortDescendingImage == null ? null : sortDescendingImage.getJsObj(), true);
    }

    /**
     * Image to show when sorting descending. See {@link com.smartgwt.client.widgets.ImgProperties} for format.
     *
     * @return Current sortDescendingImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortArrowMenuButtonSpaceOffset
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public ImgProperties getSortDescendingImage()  {
        return new ImgProperties(getAttributeAsJavaScriptObject("sortDescendingImage"));
    }
    

    /**
     * Sorting direction of this ListGrid. If specified when the ListGrid is initialized, this property will be the default
     * sorting direction for the {@link com.smartgwt.client.widgets.grid.ListGrid#getSortField sortField}. May be overridden by
     * specifying {@link com.smartgwt.client.widgets.grid.ListGridField#getSortDirection ListGridField.sortDirection}. <P>
     * After initialization, this property will be updated on {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort()} or
     * {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} to reflect the current sort direction of the grid.
     * When this grid is sorted by multiple fields, the grid's sortDirection reflects the sort direction of the primary sort
     * field.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Sort this grid's data, with the option to explicitly specify a single field to sort by and sort direction. <P> If sortField is not provided and listGrid.sortField is undefined, the data will be sorted by the first sortable column according to {@link com.smartgwt.client.widgets.grid.ListGridField#getSortDirection ListGridField.sortDirection} if specified, or {@link com.smartgwt.client.widgets.grid.ListGrid#getSortDirection sortDirection}. <P> ListGrids also support multiple-field sorting. See {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} for details. <P> Note that for editable grids, sorting is performed by underlying data values, not for unsaved {@link com.smartgwt.client.widgets.grid.ListGrid#getEditValues pending edit values}.
     *
     * @param sortDirection the field name or column number to sort by. Default value is "ascending"
     * @see com.smartgwt.client.types.SortDirection
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sort_sort" target="examples">Sort Example</a>
     */
    public void setSortDirection(SortDirection sortDirection) {
        setAttribute("sortDirection", sortDirection == null ? null : sortDirection.getValue(), true);
    }

    /**
     * Sorting direction of this ListGrid. If specified when the ListGrid is initialized, this property will be the default
     * sorting direction for the {@link com.smartgwt.client.widgets.grid.ListGrid#getSortField sortField}. May be overridden by
     * specifying {@link com.smartgwt.client.widgets.grid.ListGridField#getSortDirection ListGridField.sortDirection}. <P>
     * After initialization, this property will be updated on {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort()} or
     * {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} to reflect the current sort direction of the grid.
     * When this grid is sorted by multiple fields, the grid's sortDirection reflects the sort direction of the primary sort
     * field.
     *
     * @return Current sortDirection value. Default value is "ascending"
     * @see com.smartgwt.client.types.SortDirection
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sort_sort" target="examples">Sort Example</a>
     */
    public SortDirection getSortDirection()  {
        return EnumUtil.getEnum(SortDirection.values(), getAttribute("sortDirection"));
    }
    

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInSortEditor showHeaderSpanTitlesInSortEditor} is true,
     * this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid on the {@link
     * com.smartgwt.client.widgets.MultiSortDialog multi-sort editor}
     *
     * @param sortEditorSpanTitleSeparator New sortEditorSpanTitleSeparator value. Default value is " - "
     */
    public void setSortEditorSpanTitleSeparator(String sortEditorSpanTitleSeparator) {
        setAttribute("sortEditorSpanTitleSeparator", sortEditorSpanTitleSeparator, true);
    }

    /**
     * If this grid has specified {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInSortEditor showHeaderSpanTitlesInSortEditor} is true,
     * this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid on the {@link
     * com.smartgwt.client.widgets.MultiSortDialog multi-sort editor}
     *
     * @return Current sortEditorSpanTitleSeparator value. Default value is " - "
     */
    public String getSortEditorSpanTitleSeparator()  {
        return getAttributeAsString("sortEditorSpanTitleSeparator");
    }
    

    /**
     * The title for the corner sort button.  The title will only  ListGrid.changeDefaults() rather than replacing with an
     * entirely new object.
     *
     * @param sorterButtonTitle New sorterButtonTitle value. Default value is "corner menu"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setSorterButtonTitle(String sorterButtonTitle)  throws IllegalStateException {
        setAttribute("sorterButtonTitle", sorterButtonTitle, false);
    }

    /**
     * The title for the corner sort button.  The title will only  ListGrid.changeDefaults() rather than replacing with an
     * entirely new object.
     *
     * @return Current sorterButtonTitle value. Default value is "corner menu"
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getSorterButtonTitle()  {
        return getAttributeAsString("sorterButtonTitle");
    }
    
    
    
    

    /**
     * Specifies the field by which this grid should be initially sorted. Can be set to either a {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getName field name} or the index of the field in the fields Array. <P>
     * ListGrids also support being initialized with multiple-field sort via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getInitialSort initialSort}. If initialSort is specified, it will be used in
     * preference to this property. <P> To sort the grid after it has been initialized, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#sort sort()} or {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort()}. Details about the current sort of a live grid can be retrieved by calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortField getSortField()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()}
     *
     * @param sortField New sortField value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sort_sort" target="examples">Sort Example</a>
     */
    public void setSortField(String sortField)  throws IllegalStateException {
        setAttribute("sortField", sortField, false);
    }

    /**
     * Specifies the field by which this grid should be initially sorted. Can be set to either a {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getName field name} or the index of the field in the fields Array. <P>
     * ListGrids also support being initialized with multiple-field sort via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getInitialSort initialSort}. If initialSort is specified, it will be used in
     * preference to this property. <P> To sort the grid after it has been initialized, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#sort sort()} or {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort()}. Details about the current sort of a live grid can be retrieved by calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortField getSortField()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()}
     *
     * @return Returns the current sort field for this grid. Note that if {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort()} has been used to sort by multiple fields, you can call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()} to retrieve details about the complete sort applied to the
     * grid. Default value is null
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sort_sort" target="examples">Sort Example</a>
     */
    public String getSortField()  {
        return getAttributeAsString("sortField");
    }

    /**
     * Specifies the field by which this grid should be initially sorted. Can be set to either a {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getName field name} or the index of the field in the fields Array. <P>
     * ListGrids also support being initialized with multiple-field sort via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getInitialSort initialSort}. If initialSort is specified, it will be used in
     * preference to this property. <P> To sort the grid after it has been initialized, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#sort sort()} or {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort()}. Details about the current sort of a live grid can be retrieved by calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortField getSortField()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSort getSort()}
     *
     * @param sortField New sortField value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_sort_sort" target="examples">Sort Example</a>
     */
    public void setSortField(Integer sortField)  throws IllegalStateException {
        setAttribute("sortField", sortField, false);
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to sort a field in ascending order.
     *
     * @param sortFieldAscendingText New sortFieldAscendingText value. Default value is "Sort Ascending"
     */
    public void setSortFieldAscendingText(String sortFieldAscendingText) {
        setAttribute("sortFieldAscendingText", sortFieldAscendingText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to sort a field in ascending order.
     *
     * @return Current sortFieldAscendingText value. Default value is "Sort Ascending"
     */
    public String getSortFieldAscendingText()  {
        return getAttributeAsString("sortFieldAscendingText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to sort a field in descending order.
     *
     * @param sortFieldDescendingText New sortFieldDescendingText value. Default value is "Sort Descending"
     */
    public void setSortFieldDescendingText(String sortFieldDescendingText) {
        setAttribute("sortFieldDescendingText", sortFieldDescendingText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, this attribute will be shown as the menu item title to sort a field in descending order.
     *
     * @return Current sortFieldDescendingText value. Default value is "Sort Descending"
     */
    public String getSortFieldDescendingText()  {
        return getAttributeAsString("sortFieldDescendingText");
    }
    
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getLeaveHeaderMenuButtonSpace leaveHeaderMenuButtonSpace} is true,
     * configures the amount of space beyond the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonWidth
     * headerMenuButtonWidth} on the right side of a ListGrid header button (left for {@link
     * com.smartgwt.client.util.Page#isRTL RTL mode}) to reserve for the sort numeral if  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanMultiSort multi-sorting} is active for that field and the numeral will
     * be shown. May be increased for more separation between the title text and the sort arrow when  multi-sorting.   <P> Note
     * that larger values may required if 10 or more fields are sorted at once, as the numeral will occupy more space.  This
     * value may need to be customized in your skin or if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortAscendingImage sortAscendingImage} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortDescendingImage sortDescendingImage} are changed.
     *
     * @param sortNumeralMenuButtonSpaceOffset New sortNumeralMenuButtonSpaceOffset value. Default value is 9
     * @see com.smartgwt.client.widgets.grid.ListGrid#setSortArrowMenuButtonSpaceOffset
     */
    public void setSortNumeralMenuButtonSpaceOffset(int sortNumeralMenuButtonSpaceOffset) {
        setAttribute("sortNumeralMenuButtonSpaceOffset", sortNumeralMenuButtonSpaceOffset, true);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getLeaveHeaderMenuButtonSpace leaveHeaderMenuButtonSpace} is true,
     * configures the amount of space beyond the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderMenuButtonWidth
     * headerMenuButtonWidth} on the right side of a ListGrid header button (left for {@link
     * com.smartgwt.client.util.Page#isRTL RTL mode}) to reserve for the sort numeral if  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanMultiSort multi-sorting} is active for that field and the numeral will
     * be shown. May be increased for more separation between the title text and the sort arrow when  multi-sorting.   <P> Note
     * that larger values may required if 10 or more fields are sorted at once, as the numeral will occupy more space.  This
     * value may need to be customized in your skin or if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortAscendingImage sortAscendingImage} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSortDescendingImage sortDescendingImage} are changed.
     *
     * @return Current sortNumeralMenuButtonSpaceOffset value. Default value is 9
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortArrowMenuButtonSpaceOffset
     */
    public int getSortNumeralMenuButtonSpaceOffset()  {
        return getAttributeAsInt("sortNumeralMenuButtonSpaceOffset");
    }
    

    /**
     * When multiple fields are sorted, the Style to apply to the numeral that appears after the sort-arrows in the
     * header-buttons of sorted fields.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param sortNumeralStyle New sortNumeralStyle value. Default value is "sortNumeral"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setSortNumeralStyle(String sortNumeralStyle) {
        setAttribute("sortNumeralStyle", sortNumeralStyle, true);
    }

    /**
     * When multiple fields are sorted, the Style to apply to the numeral that appears after the sort-arrows in the
     * header-buttons of sorted fields.
     *
     * @return Current sortNumeralStyle value. Default value is "sortNumeral"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getSortNumeralStyle()  {
        return getAttributeAsString("sortNumeralStyle");
    }
    

    /**
     * Initial sort state for the grid. <P> {@link com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be
     * used to initialize all view properties of the grid. When doing so, <code>sortState</code> is not needed because
     * <code>viewState</code> includes it as well. If both are provided, <code>sortState</code> has priority for sort state.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Reset this grid's sort state (sort field and direction or list of {@link com.smartgwt.client.data.SortSpecifier}s) to match the {@link com.smartgwt.client.docs.ListGridSortState} object passed in.<br> Used to restore previous state retrieved from the grid by a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getSortState getSortState()}.
     *
     * @param sortState Object describing the desired sort state for the grid. Default value is null
     * @see com.smartgwt.client.docs.ListGridSortState ListGridSortState 
     */
    public void setSortState(String sortState) {
        setAttribute("sortState", sortState, true);
    }

    /**
     * Initial sort state for the grid. <P> {@link com.smartgwt.client.widgets.grid.ListGrid#getViewState viewState} can be
     * used to initialize all view properties of the grid. When doing so, <code>sortState</code> is not needed because
     * <code>viewState</code> includes it as well. If both are provided, <code>sortState</code> has priority for sort state.
     *
     * @return Returns a snapshot of the current sort state within this listGrid as a {@link
     * com.smartgwt.client.docs.ListGridSortState} object.<br> This object can be passed to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSortState setSortState()} to reset this grid's sort to the current state
     * (assuming the same fields are present in the grid).<br>. Default value is null
     * @see com.smartgwt.client.docs.ListGridSortState ListGridSortState 
     */
    public String getSortState()  {
        return getAttributeAsString("sortState");
    }
    

    /**
     * The menu displayed when a cell is right clicked on.
     * <p>
     * This component is an AutoChild named "spanContextMenu".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current spanContextMenu value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public Layout getSpanContextMenu() throws IllegalStateException {
        errorIfNotCreated("spanContextMenu");
        return (Layout)Layout.getByJSObject(getAttributeAsJavaScriptObject("spanContextMenu"));
    }
    

    /**
     * {@link com.smartgwt.client.widgets.Button#getBaseStyle Button.baseStyle} to apply to the field header buttons for this
     * ListGrid when showing header spans. Note that, depending on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor Class} of the header buttons, you may also need to
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleStyle headerTitleStyle}.
     *
     * @param spannedHeaderBaseStyle New spannedHeaderBaseStyle value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setSpannedHeaderBaseStyle(String spannedHeaderBaseStyle)  throws IllegalStateException {
        setAttribute("spannedHeaderBaseStyle", spannedHeaderBaseStyle, false);
    }

    /**
     * {@link com.smartgwt.client.widgets.Button#getBaseStyle Button.baseStyle} to apply to the field header buttons for this
     * ListGrid when showing header spans. Note that, depending on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderButtonConstructor Class} of the header buttons, you may also need to
     * set {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderTitleStyle headerTitleStyle}.
     *
     * @return Current spannedHeaderBaseStyle value. Default value is null
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getSpannedHeaderBaseStyle()  {
        return getAttributeAsString("spannedHeaderBaseStyle");
    }
    

    /**
     * If this is an editable listGrid, this property determines how failure to save due to validation errors should be
     * displayed to the user. <P> If this property is true, when validation errors occur the errors will be displayed to the
     * user in an alert, and focus will be returned to the first cell to fail validation. <P> If false, the cells that failed
     * validation will be silently styled with the editFailedBaseStyle. <p> <b>Note:</b> stopOnErrors being set to true implies
     * that 'waitForSave' is also true. We will not dismiss the editor until save has completed if stopOnErrors is true.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param stopOnErrors New stopOnErrors value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#setWaitForSave
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setStopOnErrors(Boolean stopOnErrors) {
        setAttribute("stopOnErrors", stopOnErrors, true);
    }

    /**
     * If this is an editable listGrid, this property determines how failure to save due to validation errors should be
     * displayed to the user. <P> If this property is true, when validation errors occur the errors will be displayed to the
     * user in an alert, and focus will be returned to the first cell to fail validation. <P> If false, the cells that failed
     * validation will be silently styled with the editFailedBaseStyle. <p> <b>Note:</b> stopOnErrors being set to true implies
     * that 'waitForSave' is also true. We will not dismiss the editor until save has completed if stopOnErrors is true.
     *
     * @return Current stopOnErrors value. Default value is false
     * @see com.smartgwt.client.widgets.grid.ListGrid#getWaitForSave
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getStopOnErrors()  {
        Boolean result = getAttributeAsBoolean("stopOnErrors");
        return result == null ? false : result;
    }
    

    /**
     * Default CSS class for the ListGrid as a whole.
     *
     * @param styleName New styleName value. Default value is "listGrid"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public void setStyleName(String styleName) {
        setAttribute("styleName", styleName, true);
    }

    /**
     * Default CSS class for the ListGrid as a whole.
     *
     * @return Current styleName value. Default value is "listGrid"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public String getStyleName()  {
        return getAttributeAsString("styleName");
    }
    

    /**
     * Automatically generated ListGrid for displaying grid summary information (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary}). <P> This component is an {@link
     * com.smartgwt.client.types.AutoChild} and as such may be customized via <code>listGrid.summaryRowProperties</code> and
     * <code>listGrid.summaryRowDefaults</code>
     * <p>
     * This component is an AutoChild named "summaryRow".  For an overview of how to use and
     * configure AutoChildren, see {@link com.smartgwt.client.docs.AutoChildUsage Using AutoChildren}.
     *
     * @return Current summaryRow value. Default value is null
     * @throws IllegalStateException if this widget has not yet been rendered.
     */
    public ListGrid getSummaryRow() throws IllegalStateException {
        errorIfNotCreated("summaryRow");
        return (ListGrid)ListGrid.getByJSObject(getAttributeAsJavaScriptObject("summaryRow"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, and a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource} is specified this property may
     * be used to specify fetch criteria to apply when retrieving summary data to show in the summary row. If unset, and any
     * filter criteria have been specified for the grid, they will be used.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param summaryRowCriteria New summaryRowCriteria value. Default value is null
     */
    public void setSummaryRowCriteria(Criteria summaryRowCriteria) {
        if (summaryRowCriteria instanceof Criterion) {
            summaryRowCriteria.setAttribute("_constructor", "AdvancedCriteria");
        }
        setAttribute("summaryRowCriteria", summaryRowCriteria == null ? null : summaryRowCriteria.getJsObj(), true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, and a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource} is specified this property may
     * be used to specify fetch criteria to apply when retrieving summary data to show in the summary row. If unset, and any
     * filter criteria have been specified for the grid, they will be used.
     *
     * @return Current summaryRowCriteria value. Default value is null
     */
    public Criteria getSummaryRowCriteria()  {
        return new Criteria(getAttributeAsJavaScriptObject("summaryRowCriteria"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, by default summary
     * values are calculated on the client based on the current data-set for the grid (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGridSummary getGridSummary()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGridSummaryFunction getGridSummaryFunction()}). <P> In some cases however
     * it may make sense to calculate summary values on the server and retrieve them via a dataSource fetch. If set, this
     * property specifies a dataSource to fetch against for the summary row. The dataSource should return a single record with
     * summary data for each field for which summary data should be shown. Note that specifying this property completely
     * bypasses the standard client-side grid summary calculation logic. <P> The fetch may be further customized via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowCriteria summaryRowCriteria} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowFetchRequestProperties summaryRowFetchRequestProperties}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param summaryRowDataSource New summaryRowDataSource value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setSummaryRowDataSource(DataSource summaryRowDataSource)  throws IllegalStateException {
        setAttribute("summaryRowDataSource", summaryRowDataSource == null ? null : summaryRowDataSource.getOrCreateJsObj(), false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, by default summary
     * values are calculated on the client based on the current data-set for the grid (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGridSummary getGridSummary()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGridSummaryFunction getGridSummaryFunction()}). <P> In some cases however
     * it may make sense to calculate summary values on the server and retrieve them via a dataSource fetch. If set, this
     * property specifies a dataSource to fetch against for the summary row. The dataSource should return a single record with
     * summary data for each field for which summary data should be shown. Note that specifying this property completely
     * bypasses the standard client-side grid summary calculation logic. <P> The fetch may be further customized via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowCriteria summaryRowCriteria} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowFetchRequestProperties summaryRowFetchRequestProperties}
     *
     * @return Current summaryRowDataSource value. Default value is null
     */
    public DataSource getSummaryRowDataSource()  {
        return DataSource.getOrCreateRef(getAttributeAsJavaScriptObject("summaryRowDataSource"));
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, and a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource} is specified this property may
     * be used to customize the fetch request used when retrieving summary data to show in the summary row. An example use case
     * might be specifying a {@link com.smartgwt.client.data.DSRequest#getOperationId DSRequest.operationId} to perform a
     * custom fetch operation which retrieved only summary values based on criteria.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param summaryRowFetchRequestProperties New summaryRowFetchRequestProperties value. Default value is null
     */
    public void setSummaryRowFetchRequestProperties(DSRequest summaryRowFetchRequestProperties) {
        JavaScriptObject config = JSOHelper.createObject();
        if (summaryRowFetchRequestProperties != null) {
            JSOHelper.addProperties(config, summaryRowFetchRequestProperties.getJsObj());
        }
        setAttribute("summaryRowFetchRequestProperties", summaryRowFetchRequestProperties == null ? null : config, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true, and a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource} is specified this property may
     * be used to customize the fetch request used when retrieving summary data to show in the summary row. An example use case
     * might be specifying a {@link com.smartgwt.client.data.DSRequest#getOperationId DSRequest.operationId} to perform a
     * custom fetch operation which retrieved only summary values based on criteria.
     *
     * @return Current summaryRowFetchRequestProperties value. Default value is null
     */
    public DSRequest getSummaryRowFetchRequestProperties()  {
        return new DSRequest(getAttributeAsJavaScriptObject("summaryRowFetchRequestProperties"));
    }
    

    /**
     * Default height for the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summary row autoChild}. Note that
     * this height is a minimum - the summary row has {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * autoFitData} set to "vertical" so if multiple rows are visible in the grid summary, the summaryRow component will expand
     * to accommodate them.
     *
     * @param summaryRowHeight New summaryRowHeight value. Default value is 20
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setSummaryRowHeight(int summaryRowHeight)  throws IllegalStateException {
        setAttribute("summaryRowHeight", summaryRowHeight, false);
    }

    /**
     * Default height for the {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summary row autoChild}. Note that
     * this height is a minimum - the summary row has {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitData
     * autoFitData} set to "vertical" so if multiple rows are visible in the grid summary, the summaryRow component will expand
     * to accommodate them.
     *
     * @return Current summaryRowHeight value. Default value is 20
     */
    public int getSummaryRowHeight()  {
        return getAttributeAsInt("summaryRowHeight");
    }
    

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} for the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param summaryRowStyle New summaryRowStyle value. Default value is "gridSummaryCell"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setSummaryRowStyle(String summaryRowStyle) {
        setAttribute("summaryRowStyle", summaryRowStyle, true);
    }

    /**
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} for the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow summaryRow}
     *
     * @return Current summaryRowStyle value. Default value is "gridSummaryCell"
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getSummaryRowStyle()  {
        return getAttributeAsString("summaryRowStyle");
    }
    

    /**
     * "Tall" baseStyle for this listGrid. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} is set to null. <P> If <code>baseStyle</code> is unset, this property will be used as a base cell style
     * unless the grid is showing fixed height rows with a specified cellHeight that matches {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight normalCellHeight}, in which case {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} will be used. Note that in Internet
     * Explorer if {@link com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} is true,
     * <code>tallBaseStyle</code> will also be used even if the cellHeight matches the specified <code>normalCellHeight</code>
     * for the grid. <P> See {@link com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are
     * combined with the base style to generate stateful cell styles.
     *
     * @param tallBaseStyle New tallBaseStyle value. Default value is "cell"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public void setTallBaseStyle(String tallBaseStyle)  throws IllegalStateException {
        setAttribute("tallBaseStyle", tallBaseStyle, false);
    }

    /**
     * "Tall" baseStyle for this listGrid. Only applies if {@link com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * baseStyle} is set to null. <P> If <code>baseStyle</code> is unset, this property will be used as a base cell style
     * unless the grid is showing fixed height rows with a specified cellHeight that matches {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight normalCellHeight}, in which case {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} will be used. Note that in Internet
     * Explorer if {@link com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} is true,
     * <code>tallBaseStyle</code> will also be used even if the cellHeight matches the specified <code>normalCellHeight</code>
     * for the grid. <P> See {@link com.smartgwt.client.docs.CellStyleSuffixes} for details on how stateful suffixes are
     * combined with the base style to generate stateful cell styles.
     *
     * @return Current tallBaseStyle value. Default value is "cell"
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.CSSStyleName CSSStyleName 
     */
    public String getTallBaseStyle()  {
        return getAttributeAsString("tallBaseStyle");
    }
    
    
    

    /**
     * While scrolling an incrementally rendered grid, using the inertial scrolling, time in  milliseconds to wait before
     * redrawing, after the last touchScroll by the user.   If not specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} will be used as a default for both
     * drag scrolling and touch scrolling. <P> Note that if specified, this value will typically be larger than  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}. <P> See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw GridRenderer.instantScrollTrackRedraw} for
     * cases where this delay is skipped.
     *
     * @param touchScrollRedrawDelay New touchScrollRedrawDelay value. Default value is 0
     */
    public void setTouchScrollRedrawDelay(Integer touchScrollRedrawDelay) {
        setAttribute("touchScrollRedrawDelay", touchScrollRedrawDelay, true);
    }

    /**
     * While scrolling an incrementally rendered grid, using the inertial scrolling, time in  milliseconds to wait before
     * redrawing, after the last touchScroll by the user.   If not specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay} will be used as a default for both
     * drag scrolling and touch scrolling. <P> Note that if specified, this value will typically be larger than  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getScrollRedrawDelay scrollRedrawDelay}. <P> See also {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getInstantScrollTrackRedraw GridRenderer.instantScrollTrackRedraw} for
     * cases where this delay is skipped.
     *
     * @return Current touchScrollRedrawDelay value. Default value is 0
     */
    public Integer getTouchScrollRedrawDelay()  {
        return getAttributeAsInt("touchScrollRedrawDelay");
    }
    

    /**
     * Default image to use for the dragTracker when things are dragged within or out of this list. See {@link
     * com.smartgwt.client.widgets.ImgProperties} for format.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param trackerImage New trackerImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#setDragTrackerMode
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragTrackerIcon
     */
    public void setTrackerImage(ImgProperties trackerImage) {
        setAttribute("trackerImage", trackerImage == null ? null : trackerImage.getJsObj(), true);
    }

    /**
     * Default image to use for the dragTracker when things are dragged within or out of this list. See {@link
     * com.smartgwt.client.widgets.ImgProperties} for format.
     *
     * @return Current trackerImage value. Default value is {...}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragTrackerMode
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragTrackerIcon
     */
    public ImgProperties getTrackerImage()  {
        return new ImgProperties(getAttributeAsJavaScriptObject("trackerImage"));
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to unfreeze a currently frozen field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Unfreeze " + the field's summary title.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param unfreezeFieldText New unfreezeFieldText value. Default value is "Unfreeze ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public void setUnfreezeFieldText(String unfreezeFieldText) {
        setAttribute("unfreezeFieldText", unfreezeFieldText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to unfreeze a currently frozen field. <P> This is a dynamic string - text
     * within <code>&#36;{...}</code> will be evaluated as JS code when the message is displayed, with <code>title</code>
     * available as a variable containing the field title. <P> Default value returns "Unfreeze " + the field's summary title.
     *
     * @return Current unfreezeFieldText value. Default value is "Unfreeze ${title}"
     * @see com.smartgwt.client.docs.HTMLString HTMLString 
     */
    public String getUnfreezeFieldText()  {
        return getAttributeAsString("unfreezeFieldText");
    }
    

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getIsGrouped this.isGrouped} is true, this attribute will be
     * shown as the title for the menu item to ungroup the grid.
     *
     * @param ungroupText New ungroupText value. Default value is "Ungroup"
     */
    public void setUngroupText(String ungroupText) {
        setAttribute("ungroupText", ungroupText, true);
    }

    /**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid, and {@link com.smartgwt.client.widgets.grid.ListGrid#getIsGrouped this.isGrouped} is true, this attribute will be
     * shown as the title for the menu item to ungroup the grid.
     *
     * @return Current ungroupText value. Default value is "Ungroup"
     */
    public String getUngroupText()  {
        return getAttributeAsString("ungroupText");
    }
    

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, this icon will
     * be shown in the auto generated field fro removing records if the record has been marked as removed via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}. At this point, clicking on the icon
     * will unmark the record as removed.
     *
     * @param unremoveIcon New unremoveIcon value. Default value is "[SKIN]/actions/undo.png"
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public void setUnremoveIcon(String unremoveIcon)  throws IllegalStateException {
        setAttribute("unremoveIcon", unremoveIcon, false);
    }

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is enabled, this icon will
     * be shown in the auto generated field fro removing records if the record has been marked as removed via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}. At this point, clicking on the icon
     * will unmark the record as removed.
     *
     * @return Current unremoveIcon value. Default value is "[SKIN]/actions/undo.png"
     * @see com.smartgwt.client.docs.SCImgURL SCImgURL 
     */
    public String getUnremoveIcon()  {
        return getAttributeAsString("unremoveIcon");
    }
    
    

    /**
     * Should the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter-editor} in this grid always
     * produce  {@link com.smartgwt.client.data.AdvancedCriteria}?
     *
     * @param useAdvancedCriteria New useAdvancedCriteria value. Default value is null
     * @see com.smartgwt.client.docs.CriteriaEditing CriteriaEditing overview and related methods
     */
    public void setUseAdvancedCriteria(Boolean useAdvancedCriteria) {
        setAttribute("useAdvancedCriteria", useAdvancedCriteria, true);
    }

    /**
     * Should the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filter-editor} in this grid always
     * produce  {@link com.smartgwt.client.data.AdvancedCriteria}?
     *
     * @return Current useAdvancedCriteria value. Default value is null
     * @see com.smartgwt.client.docs.CriteriaEditing CriteriaEditing overview and related methods
     */
    public Boolean getUseAdvancedCriteria()  {
        return getAttributeAsBoolean("useAdvancedCriteria");
    }
    

    /**
     * If set to true, an advanced field picker based on the {@link com.smartgwt.client.widgets.FieldPicker} will be shown
     * instead of the column picker submenu if there are more fields in the grid than {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAdvancedFieldPickerThreshold advancedFieldPickerThreshold}. <P> When there
     * are large numbers of available fields, the FieldPicker-based interface is more usable for both defining visible fields
     * and defining field order.
     *
     * @param useAdvancedFieldPicker New useAdvancedFieldPicker value. Default value is false
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setUseAdvancedFieldPicker(Boolean useAdvancedFieldPicker)  throws IllegalStateException {
        setAttribute("useAdvancedFieldPicker", useAdvancedFieldPicker, false);
    }

    /**
     * If set to true, an advanced field picker based on the {@link com.smartgwt.client.widgets.FieldPicker} will be shown
     * instead of the column picker submenu if there are more fields in the grid than {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAdvancedFieldPickerThreshold advancedFieldPickerThreshold}. <P> When there
     * are large numbers of available fields, the FieldPicker-based interface is more usable for both defining visible fields
     * and defining field order.
     *
     * @return Current useAdvancedFieldPicker value. Default value is false
     */
    public Boolean getUseAdvancedFieldPicker()  {
        Boolean result = getAttributeAsBoolean("useAdvancedFieldPicker");
        return result == null ? false : result;
    }
    
    

    /**
     * Are rollovers cell-level or row-level?
     *
     * @param useCellRollOvers New useCellRollOvers value. Default value is null
     */
    public void setUseCellRollOvers(Boolean useCellRollOvers) {
        setAttribute("useCellRollOvers", useCellRollOvers, true);
    }

    /**
     * Are rollovers cell-level or row-level?
     *
     * @return Current useCellRollOvers value. Default value is null
     */
    public Boolean getUseCellRollOvers()  {
        return getAttributeAsBoolean("useCellRollOvers");
    }
    

    /**
     * Enables copy/paste shortcuts, provided {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells
     * canSelectCells} is true <p> The default setting of true means that the value of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} determines whether copy/paste shortcuts are
     * enabled.  Setting this property to false disables said shortcuts unconditionally. <p> Copying is done via copying to a
     * Smart GWT-wide "clipboard" - <b>not</b> the OS-level clipboard, which is inaccessible on some browsers - via the methods
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectedCellData getSelectedCellData()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#applyCellData applyCellData()}.  To copy data to and from applications outside
     * of the browser, use the technique shown in the @see <a
     * href="http://www.smartclient.com/smartgwtee/showcase/#gridToExcel" target="examples">Grid to Excel</a> and @see <a
     * href="http://www.smartclient.com/smartgwtee/showcase/#excelToGrid" target="examples">Excel to Grid</a> samples. <p> The
     * following shortcuts are available: <p> CTRL + D: copy cell values from top row of selected cells down to all rows <p>
     * CTRL + R: copy cell values from left column of selected cells right to all columns <p> CTRL + C: copy selected cell
     * values into shared clipboard <p> CTRL + V: paste from shared clipboard into current selection
     *
     * @param useCopyPasteShortcuts New useCopyPasteShortcuts value. Default value is true
     */
    public void setUseCopyPasteShortcuts(Boolean useCopyPasteShortcuts) {
        setAttribute("useCopyPasteShortcuts", useCopyPasteShortcuts, true);
    }

    /**
     * Enables copy/paste shortcuts, provided {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells
     * canSelectCells} is true <p> The default setting of true means that the value of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} determines whether copy/paste shortcuts are
     * enabled.  Setting this property to false disables said shortcuts unconditionally. <p> Copying is done via copying to a
     * Smart GWT-wide "clipboard" - <b>not</b> the OS-level clipboard, which is inaccessible on some browsers - via the methods
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectedCellData getSelectedCellData()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#applyCellData applyCellData()}.  To copy data to and from applications outside
     * of the browser, use the technique shown in the @see <a
     * href="http://www.smartclient.com/smartgwtee/showcase/#gridToExcel" target="examples">Grid to Excel</a> and @see <a
     * href="http://www.smartclient.com/smartgwtee/showcase/#excelToGrid" target="examples">Excel to Grid</a> samples. <p> The
     * following shortcuts are available: <p> CTRL + D: copy cell values from top row of selected cells down to all rows <p>
     * CTRL + R: copy cell values from left column of selected cells right to all columns <p> CTRL + C: copy selected cell
     * values into shared clipboard <p> CTRL + V: paste from shared clipboard into current selection
     *
     * @return Current useCopyPasteShortcuts value. Default value is true
     */
    public Boolean getUseCopyPasteShortcuts()  {
        Boolean result = getAttributeAsBoolean("useCopyPasteShortcuts");
        return result == null ? true : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} is specified, but this grid is bound to
     * a DataSource which includes remote field validators, by default edits will be saved synchronously and these validators
     * will not be executed.<br> Set this property to <code>true</code> to ensure these remote validators are called when
     * saving edits in saveLocally mode. Note that since these remote validators need to run on the server, saving with this
     * property set is asynchronous, even though the data that ultimately gets updated is already present on the client.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param useRemoteValidators New useRemoteValidators value. Default value is null
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setUseRemoteValidators(Boolean useRemoteValidators) {
        setAttribute("useRemoteValidators", useRemoteValidators, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally} is specified, but this grid is bound to
     * a DataSource which includes remote field validators, by default edits will be saved synchronously and these validators
     * will not be executed.<br> Set this property to <code>true</code> to ensure these remote validators are called when
     * saving edits in saveLocally mode. Note that since these remote validators need to run on the server, saving with this
     * property set is asynchronous, even though the data that ultimately gets updated is already present on the client.
     *
     * @return Current useRemoteValidators value. Default value is null
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public Boolean getUseRemoteValidators()  {
        return getAttributeAsBoolean("useRemoteValidators");
    }
    

    /**
     * Enables various styling behaviors that potentially make sense when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} has been overridden to introduce spanning cells, and
     * spanning is largest on the left and smaller as cells go to the right.  Specifically: <ul> <li> computes {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles banded styling} based on the span of the      cell in
     * the left-most column <li> enables {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells cell-level
     * selection}, including      {@link com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers cell-level rollover}
     * styling <li> enables row-span-sensitive cell selection.  See also {@link com.smartgwt.client.types.RowSpanSelectionMode}
     * for available behaviors </ul> <P> Because this setting enables {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells}, it is incompatible with any APIs that
     * expect a record-oriented data model. <P> Because this setting only makes sense when row spanning decreases from the
     * first column to the last, it has unspecified behavior with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanReorderFields canReorderFields}.
     *
     * @param useRowSpanStyling New useRowSpanStyling value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     */
    public void setUseRowSpanStyling(Boolean useRowSpanStyling)  throws IllegalStateException {
        setAttribute("useRowSpanStyling", useRowSpanStyling, false);
    }

    /**
     * Enables various styling behaviors that potentially make sense when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} has been overridden to introduce spanning cells, and
     * spanning is largest on the left and smaller as cells go to the right.  Specifically: <ul> <li> computes {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAlternateRecordStyles banded styling} based on the span of the      cell in
     * the left-most column <li> enables {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells cell-level
     * selection}, including      {@link com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers cell-level rollover}
     * styling <li> enables row-span-sensitive cell selection.  See also {@link com.smartgwt.client.types.RowSpanSelectionMode}
     * for available behaviors </ul> <P> Because this setting enables {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells}, it is incompatible with any APIs that
     * expect a record-oriented data model. <P> Because this setting only makes sense when row spanning decreases from the
     * first column to the last, it has unspecified behavior with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanReorderFields canReorderFields}.
     *
     * @return Current useRowSpanStyling value. Default value is null
     */
    public Boolean getUseRowSpanStyling()  {
        return getAttributeAsBoolean("useRowSpanStyling");
    }
    

    /**
     * Whether client-side validation checks should be performed when the user moves between cells in the current edit row.  If
     * unset, defaults to {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell editByCell}. <P> Note that validation
     * always occurs when a row is to be saved, so setting {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell
     * saveByCell}:true forces validation on cell transitions.  To completely disable automatic validation, set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNeverValidate neverValidate}:true.
     *
     * @param validateByCell New validateByCell value. Default value is null
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public void setValidateByCell(Boolean validateByCell) {
        setAttribute("validateByCell", validateByCell, true);
    }

    /**
     * Whether client-side validation checks should be performed when the user moves between cells in the current edit row.  If
     * unset, defaults to {@link com.smartgwt.client.widgets.grid.ListGrid#getEditByCell editByCell}. <P> Note that validation
     * always occurs when a row is to be saved, so setting {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell
     * saveByCell}:true forces validation on cell transitions.  To completely disable automatic validation, set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getNeverValidate neverValidate}:true.
     *
     * @return Current validateByCell value. Default value is null
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public Boolean getValidateByCell()  {
        return getAttributeAsBoolean("validateByCell");
    }
    

    /**
     * If true, validation will be performed on each edited cell when each editor's "change" handler is fired.
     *
     * @param validateOnChange New validateOnChange value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValidateOnChange
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public void setValidateOnChange(Boolean validateOnChange) {
        setAttribute("validateOnChange", validateOnChange, true);
    }

    /**
     * If true, validation will be performed on each edited cell when each editor's "change" handler is fired.
     *
     * @return Current validateOnChange value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValidateOnChange
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public Boolean getValidateOnChange()  {
        return getAttributeAsBoolean("validateOnChange");
    }
    

    /**
     * Height for value icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getValueIconSize
     * valueIconSize}. Can be overridden at the field level
     *
     * @param valueIconHeight New valueIconHeight value. Default value is null
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setValueIconHeight(Integer valueIconHeight) {
        setAttribute("valueIconHeight", valueIconHeight, true);
    }

    /**
     * Height for value icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getValueIconSize
     * valueIconSize}. Can be overridden at the field level
     *
     * @return Current valueIconHeight value. Default value is null
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public Integer getValueIconHeight()  {
        return getAttributeAsInt("valueIconHeight");
    }
    

    /**
     * How much padding should there be on the left of valueIcons by default Can be overridden at the field level
     *
     * @param valueIconLeftPadding New valueIconLeftPadding value. Default value is 2
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValueIcons
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setValueIconLeftPadding(int valueIconLeftPadding) {
        setAttribute("valueIconLeftPadding", valueIconLeftPadding, true);
    }

    /**
     * How much padding should there be on the left of valueIcons by default Can be overridden at the field level
     *
     * @return Current valueIconLeftPadding value. Default value is 2
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValueIcons
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getValueIconLeftPadding()  {
        return getAttributeAsInt("valueIconLeftPadding");
    }
    

    /**
     * How much padding should there be on the right of valueIcons by default
     *
     * @param valueIconRightPadding New valueIconRightPadding value. Default value is 2
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValueIcons
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setValueIconRightPadding(int valueIconRightPadding) {
        setAttribute("valueIconRightPadding", valueIconRightPadding, true);
    }

    /**
     * How much padding should there be on the right of valueIcons by default
     *
     * @return Current valueIconRightPadding value. Default value is 2
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValueIcons
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getValueIconRightPadding()  {
        return getAttributeAsInt("valueIconRightPadding");
    }
    

    /**
     * Default width and height of value icons for this ListGrid. Can be overridden at the listGrid level via explicit {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getValueIconWidth valueIconWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getValueIconHeight valueIconHeight}, or at the field level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIconSize ListGridField.valueIconSize}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIconWidth ListGridField.valueIconWidth} and
     * {ListGridField.valueIconHeight}
     *
     * @param valueIconSize New valueIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#setValueIconWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setValueIconHeight
     * @see com.smartgwt.client.widgets.grid.ListGridField#setValueIconSize
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setValueIconSize(int valueIconSize) {
        setAttribute("valueIconSize", valueIconSize, true);
    }

    /**
     * Default width and height of value icons for this ListGrid. Can be overridden at the listGrid level via explicit {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getValueIconWidth valueIconWidth} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getValueIconHeight valueIconHeight}, or at the field level via {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIconSize ListGridField.valueIconSize}, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getValueIconWidth ListGridField.valueIconWidth} and
     * {ListGridField.valueIconHeight}
     *
     * @return Current valueIconSize value. Default value is 16
     * @see com.smartgwt.client.widgets.grid.ListGrid#getValueIconWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getValueIconHeight
     * @see com.smartgwt.client.widgets.grid.ListGridField#getValueIconSize
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public int getValueIconSize()  {
        return getAttributeAsInt("valueIconSize");
    }
    

    /**
     * Width for value icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getValueIconSize
     * valueIconSize}. Can be overridden at the field level
     *
     * @param valueIconWidth New valueIconWidth value. Default value is null
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public void setValueIconWidth(Integer valueIconWidth) {
        setAttribute("valueIconWidth", valueIconWidth, true);
    }

    /**
     * Width for value icons for this listGrid. Overrides {@link com.smartgwt.client.widgets.grid.ListGrid#getValueIconSize
     * valueIconSize}. Can be overridden at the field level
     *
     * @return Current valueIconWidth value. Default value is null
     * @see com.smartgwt.client.docs.ImageColumns ImageColumns overview and related methods
     */
    public Integer getValueIconWidth()  {
        return getAttributeAsInt("valueIconWidth");
    }
    

    /**
     * Initial {@link com.smartgwt.client.docs.ListGridViewState view state} for the grid. <P> Since view state contains field
     * state it is not necessary to set {@link com.smartgwt.client.widgets.grid.ListGrid#getFieldState fieldState} when also
     * setting <code>viewState</code>. If both are provided, <code>fieldState</code> has priority for field state.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Reset this grid's view state to match the {@link com.smartgwt.client.docs.ListGridViewState} object passed in.<br> Used to restore previous state retrieved from the grid by a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getViewState getViewState()}.
     *
     * @param viewState Object describing the desired view state for the grid. Default value is null
     * @see com.smartgwt.client.docs.ListGridViewState ListGridViewState 
     */
    public void setViewState(String viewState) {
        setAttribute("viewState", viewState, true);
    }

    /**
     * Initial {@link com.smartgwt.client.docs.ListGridViewState view state} for the grid. <P> Since view state contains field
     * state it is not necessary to set {@link com.smartgwt.client.widgets.grid.ListGrid#getFieldState fieldState} when also
     * setting <code>viewState</code>. If both are provided, <code>fieldState</code> has priority for field state.
     *
     * @return Returns a snapshot of the current view state of this ListGrid.<br> This includes the field, sort, hilite, group, and
     * selected state of the grid, returned  as a string representation of a {@link com.smartgwt.client.docs.ListGridViewState}
     * object.<br> This string can be passed to {@link com.smartgwt.client.widgets.grid.ListGrid#setViewState setViewState()}
     * to reset this grid's view state to the current state (assuming the same data / fields are present in the grid).<br>. Default value is null
     * @see com.smartgwt.client.docs.ListGridViewState ListGridViewState 
     */
    public String getViewState()  {
        return getAttributeAsString("viewState");
    }
    

    /**
     * When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages
     * the differences in scroll height calculations due to the unknown sizes of un-rendered rows to make the scrollbar and
     * viewport appear correctly. <P> When the <code>virtualScrolling</code> system is active, the last scroll position scrolls
     * the last record to the top of the viewport, leaving blank space underneath. This is a necessary and unavoidable
     * consequence of mapping the position of the scrollbar thumb to an unknown amount of remaining space without being able to
     * know the total scrollable area in advance (since record heights vary). <P> virtualScrolling is switched on automatically
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights} is false and also when
     * using the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents subsystem}, as
     * recordComponents expand the rows that contain them. This flag should be manually enabled when calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEmbeddedComponent addEmbeddedComponent()} if embedded components can cause
     * record sizes to expand beyond specified cellHeight. <P> virtualScrolling is also automatically enabled when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true to handle the fact that expanded
     * rows may render at variable heights.
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param virtualScrolling New virtualScrolling value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRecordComponentHeight
     */
    public void setVirtualScrolling(Boolean virtualScrolling)  throws IllegalStateException {
        setAttribute("virtualScrolling", virtualScrolling, false);
    }

    /**
     * When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages
     * the differences in scroll height calculations due to the unknown sizes of un-rendered rows to make the scrollbar and
     * viewport appear correctly. <P> When the <code>virtualScrolling</code> system is active, the last scroll position scrolls
     * the last record to the top of the viewport, leaving blank space underneath. This is a necessary and unavoidable
     * consequence of mapping the position of the scrollbar thumb to an unknown amount of remaining space without being able to
     * know the total scrollable area in advance (since record heights vary). <P> virtualScrolling is switched on automatically
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights} is false and also when
     * using the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponents subsystem}, as
     * recordComponents expand the rows that contain them. This flag should be manually enabled when calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEmbeddedComponent addEmbeddedComponent()} if embedded components can cause
     * record sizes to expand beyond specified cellHeight. <P> virtualScrolling is also automatically enabled when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true to handle the fact that expanded
     * rows may render at variable heights.
     *
     * @return Current virtualScrolling value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentHeight
     */
    public Boolean getVirtualScrolling()  {
        return getAttributeAsBoolean("virtualScrolling");
    }
    

    /**
     * If this is an editable listGrid, this property determines whether the user will be able to dismiss the edit form, or
     * navigate to another cell while the save is in process (before the asynchronous server response returns).
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param waitForSave New waitForSave value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public void setWaitForSave(Boolean waitForSave) {
        setAttribute("waitForSave", waitForSave, true);
    }

    /**
     * If this is an editable listGrid, this property determines whether the user will be able to dismiss the edit form, or
     * navigate to another cell while the save is in process (before the asynchronous server response returns).
     *
     * @return Current waitForSave value. Default value is false
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public Boolean getWaitForSave()  {
        Boolean result = getAttributeAsBoolean("waitForSave");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is true, when the user clicks
     * the remove icon for some record, should we show a warning message (defined as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemovalMessage warnOnRemovalMessage}) and allow the user to cancel
     * removal?
     *
     * @param warnOnRemoval New warnOnRemoval value. Default value is false
     */
    public void setWarnOnRemoval(Boolean warnOnRemoval) {
        setAttribute("warnOnRemoval", warnOnRemoval, true);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is true, when the user clicks
     * the remove icon for some record, should we show a warning message (defined as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemovalMessage warnOnRemovalMessage}) and allow the user to cancel
     * removal?
     *
     * @return Current warnOnRemoval value. Default value is false
     */
    public Boolean getWarnOnRemoval()  {
        Boolean result = getAttributeAsBoolean("warnOnRemoval");
        return result == null ? false : result;
    }
    

    /**
     * Warning message to show the user on a click on the 'remove' icon if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval warnOnRemoval} is true.
     *
     * @param warnOnRemovalMessage New warnOnRemovalMessage value. Default value is "Are you sure you want to delete this record?"
     */
    public void setWarnOnRemovalMessage(String warnOnRemovalMessage) {
        setAttribute("warnOnRemovalMessage", warnOnRemovalMessage, true);
    }

    /**
     * Warning message to show the user on a click on the 'remove' icon if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval warnOnRemoval} is true.
     *
     * @return Current warnOnRemovalMessage value. Default value is "Are you sure you want to delete this record?"
     */
    public String getWarnOnRemovalMessage()  {
        return getAttributeAsString("warnOnRemovalMessage");
    }
    

    /**
     * If a field has {@link com.smartgwt.client.widgets.grid.ListGridField#getDisplayField ListGridField.displayField}
     * specified and has no {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource}, this field will display the value from the <code>displayField</code> of each record by
     * default (for more on this behavior see {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource}). <P> If such a field is editable, changing the edit value for the field on some record,
     * without updating the edit value for the associated display field on the same record would mean the user would continue
     * to see the unchanged display field value. Developers can resolve this situation by programmatically setting an edit
     * value for the display field as well as the data field, or avoid it by specifying an optionDataSource and ensuring {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchDisplayMap autoFetchDisplayMap} is true, or setting an explicit
     * valueMap for the field. <P> By default, when the edit value on a field with a specified displayField and no
     * optionDataSource is set, we log a warning to notify the developer. This warning may be disabled by setting
     * <code>warnOnUnmappedValueFieldChange</code> to <code>false</code>. <P> Note: There are actually a couple of cases in
     * which the system will automatically derive a new display-field value and apply it to the record: <ol><li>If the edit
     * value was changed by a user actually editing the record (rather than a programmatic call to setEditValue()), and the
     * edit-item had a valueMap or optionDataSource set, we automatically pick up the display value from that item and store it
     * as an edit-value for the displayField of the record</li>     <li>If the listGrid has a loaded record in its data set
     * whose valueField value matches the edit value for the valueField, we automatically apply the displayField value from
     * that record as an edit value for the displayField on the newly edited record.</li></ol> In either case, the display
     * value for the record is updated automatically (and the warning would not be logged).
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param warnOnUnmappedValueFieldChange New warnOnUnmappedValueFieldChange value. Default value is true
     */
    public void setWarnOnUnmappedValueFieldChange(Boolean warnOnUnmappedValueFieldChange) {
        setAttribute("warnOnUnmappedValueFieldChange", warnOnUnmappedValueFieldChange, true);
    }

    /**
     * If a field has {@link com.smartgwt.client.widgets.grid.ListGridField#getDisplayField ListGridField.displayField}
     * specified and has no {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource}, this field will display the value from the <code>displayField</code> of each record by
     * default (for more on this behavior see {@link com.smartgwt.client.widgets.grid.ListGridField#getOptionDataSource
     * ListGridField.optionDataSource}). <P> If such a field is editable, changing the edit value for the field on some record,
     * without updating the edit value for the associated display field on the same record would mean the user would continue
     * to see the unchanged display field value. Developers can resolve this situation by programmatically setting an edit
     * value for the display field as well as the data field, or avoid it by specifying an optionDataSource and ensuring {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchDisplayMap autoFetchDisplayMap} is true, or setting an explicit
     * valueMap for the field. <P> By default, when the edit value on a field with a specified displayField and no
     * optionDataSource is set, we log a warning to notify the developer. This warning may be disabled by setting
     * <code>warnOnUnmappedValueFieldChange</code> to <code>false</code>. <P> Note: There are actually a couple of cases in
     * which the system will automatically derive a new display-field value and apply it to the record: <ol><li>If the edit
     * value was changed by a user actually editing the record (rather than a programmatic call to setEditValue()), and the
     * edit-item had a valueMap or optionDataSource set, we automatically pick up the display value from that item and store it
     * as an edit-value for the displayField of the record</li>     <li>If the listGrid has a loaded record in its data set
     * whose valueField value matches the edit value for the valueField, we automatically apply the displayField value from
     * that record as an edit value for the displayField on the newly edited record.</li></ol> In either case, the display
     * value for the record is updated automatically (and the warning would not be logged).
     *
     * @return Current warnOnUnmappedValueFieldChange value. Default value is true
     */
    public Boolean getWarnOnUnmappedValueFieldChange()  {
        Boolean result = getAttributeAsBoolean("warnOnUnmappedValueFieldChange");
        return result == null ? true : result;
    }
    

    /**
     * Should content within cells be allowed to wrap? <P> Even if content is allowed to wrap, if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights} is set, the content will be clipped
     * off at the cell boundary.  Either set a larger, fixed {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight
     * cellHeight} to reveal more content, or set {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights
     * fixedRecordHeights} to false to allow auto-sizing.
     *
     * <br><br>If this method is called after the component has been drawn/initialized:
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGrid#getWrapCells wrapCells}
     * <p><b>Note : </b> This is an advanced setting</p>
     *
     * @param wrapCells New wrapCells value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_values" target="examples">Cell Values Example</a>
     */
    public void setWrapCells(Boolean wrapCells) {
        setAttribute("wrapCells", wrapCells, true);
    }

    /**
     * Should content within cells be allowed to wrap? <P> Even if content is allowed to wrap, if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights} is set, the content will be clipped
     * off at the cell boundary.  Either set a larger, fixed {@link com.smartgwt.client.widgets.grid.ListGrid#getCellHeight
     * cellHeight} to reveal more content, or set {@link com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights
     * fixedRecordHeights} to false to allow auto-sizing.
     *
     * @return Current wrapCells value. Default value is false
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_autofit_values" target="examples">Cell Values Example</a>
     */
    public Boolean getWrapCells()  {
        Boolean result = getAttributeAsBoolean("wrapCells");
        return result == null ? false : result;
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.HeaderSpan#getWrap HeaderSpan.wrap} is not explicitly set, should fields
     * wrap?  If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
     *
     * @param wrapHeaderSpanTitles New wrapHeaderSpanTitles value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setMinFieldWidth
     */
    public void setWrapHeaderSpanTitles(Boolean wrapHeaderSpanTitles)  throws IllegalStateException {
        setAttribute("wrapHeaderSpanTitles", wrapHeaderSpanTitles, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.HeaderSpan#getWrap HeaderSpan.wrap} is not explicitly set, should fields
     * wrap?  If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
     *
     * @return Current wrapHeaderSpanTitles value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getMinFieldWidth
     */
    public Boolean getWrapHeaderSpanTitles()  {
        return getAttributeAsBoolean("wrapHeaderSpanTitles");
    }
    

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap ListGridField.wrap} is not explicitly set, should
     * fields wrap?  If autofitting, see the docs on that property for the details of how the minimum width for a field is
     * determined.
     *
     * @param wrapHeaderTitles New wrapHeaderTitles value. Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.widgets.grid.ListGrid#setMinFieldWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#setHeaderBaseStyle
     */
    public void setWrapHeaderTitles(Boolean wrapHeaderTitles)  throws IllegalStateException {
        setAttribute("wrapHeaderTitles", wrapHeaderTitles, false);
    }

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGridField#getWrap ListGridField.wrap} is not explicitly set, should
     * fields wrap?  If autofitting, see the docs on that property for the details of how the minimum width for a field is
     * determined.
     *
     * @return Current wrapHeaderTitles value. Default value is null
     * @see com.smartgwt.client.widgets.grid.ListGrid#getMinFieldWidth
     * @see com.smartgwt.client.widgets.grid.ListGrid#getHeaderBaseStyle
     */
    public Boolean getWrapHeaderTitles()  {
        return getAttributeAsBoolean("wrapHeaderTitles");
    }
    

    // ********************* Methods ***********************
	/**
     * Perform a DataSource "add" operation to add new records to this component's DataSource.
     * @param newRecord new record
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_add" target="examples">Databound add Example</a>
     */
    public native void addData(Record newRecord) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "addData", "Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.addData(newRecord.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

    /**
     * @see ListGrid#addData
     */
    public void addData(Record newRecord, DSCallback callback){
        addData(newRecord, callback, null);
    }

	/**
     * Perform a DataSource "add" operation to add new records to this component's DataSource.
     * @param newRecord new record
     * @param callback method to call on operation completion
     * @param requestProperties additional properties to set on the DSRequest                                          that will be issued
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_add" target="examples">Databound add Example</a>
     */
    public native void addData(Record newRecord, DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "addData", "Record,DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.addData(newRecord.@com.smartgwt.client.core.DataClass::getJsObj()(), 
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Attaches the component to the provided record. If <code>position</code> is specified as <code>"within"</code> {@link
     * com.smartgwt.client.widgets.Canvas#getSnapTo Canvas.snapTo} and {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetLeft Canvas.snapOffsetLeft}, {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetTop Canvas.snapOffsetTop} may be set to specify where the component will
     * render within the cell or record. If unset, for components embedded within a record we will default to embedding at the
     * top/left coordinate, and for components embedded within a cell, we will respect the align / valign properties for the
     * cell in question. Any percentage sizing will be interpreted as percentage of row size. <P> Otherwise it will appear to
     * be embedded within the record, underneath the field values. <P> Embedded components become children of the grid and will
     * stay attached to a record through scrolling, sorting and other operations that cause records to shift position. <P> If
     * <code>position</code> is set to <code>"expand"</code>, embedded components may offer a resize interface, eg, by setting
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getCanDragResize canDragResize}:true, and the grid will react
     * accordingly, growing or shrinking the record to match the embedded component's new extents. <P> Embedded components can
     * be explicitly removed with {@link com.smartgwt.client.widgets.grid.ListGrid#removeEmbeddedComponent
     * removeEmbeddedComponent()}. <P> If a record is removed from the dataset or is replaced in the dataset, for example, it
     * is eliminated through filtering (removes record) or is successfully edited in a databound grid (replaces record), the
     * component is cleared but not logically removed from the grid. It is the responsibility of code that sets up the embedded
     * component to remove it if the record is removed from the dataSet. <P> When embedding components will result in variable
     * height records, you should switch on {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling
     * virtualScrolling}.
     * @param component component to embed
     * @param record record to attach the component to
     */
    public native void addEmbeddedComponent(Canvas component, ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "addEmbeddedComponent", "Canvas,ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.addEmbeddedComponent(component == null ? null : component.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), record.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

    /**
     * @see ListGrid#addEmbeddedComponent
     */
    public void addEmbeddedComponent(Canvas component, ListGridRecord record, Integer rowNum){
        addEmbeddedComponent(component, record, rowNum, (Integer) null, null);
    }

    /**
     * @see ListGrid#addEmbeddedComponent
     */
    public void addEmbeddedComponent(Canvas component, ListGridRecord record, Integer rowNum, Integer colNum){
        addEmbeddedComponent(component, record, rowNum, colNum, null);
    }

	/**
     * Attaches the component to the provided record. If <code>position</code> is specified as <code>"within"</code> {@link
     * com.smartgwt.client.widgets.Canvas#getSnapTo Canvas.snapTo} and {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetLeft Canvas.snapOffsetLeft}, {@link
     * com.smartgwt.client.widgets.Canvas#getSnapOffsetTop Canvas.snapOffsetTop} may be set to specify where the component will
     * render within the cell or record. If unset, for components embedded within a record we will default to embedding at the
     * top/left coordinate, and for components embedded within a cell, we will respect the align / valign properties for the
     * cell in question. Any percentage sizing will be interpreted as percentage of row size. <P> Otherwise it will appear to
     * be embedded within the record, underneath the field values. <P> Embedded components become children of the grid and will
     * stay attached to a record through scrolling, sorting and other operations that cause records to shift position. <P> If
     * <code>position</code> is set to <code>"expand"</code>, embedded components may offer a resize interface, eg, by setting
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getCanDragResize canDragResize}:true, and the grid will react
     * accordingly, growing or shrinking the record to match the embedded component's new extents. <P> Embedded components can
     * be explicitly removed with {@link com.smartgwt.client.widgets.grid.ListGrid#removeEmbeddedComponent
     * removeEmbeddedComponent()}. <P> If a record is removed from the dataset or is replaced in the dataset, for example, it
     * is eliminated through filtering (removes record) or is successfully edited in a databound grid (replaces record), the
     * component is cleared but not logically removed from the grid. It is the responsibility of code that sets up the embedded
     * component to remove it if the record is removed from the dataSet. <P> When embedding components will result in variable
     * height records, you should switch on {@link com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling
     * virtualScrolling}.
     * @param component component to embed
     * @param record record to attach the component to
     * @param rowNum rowNum of the record to attach the component to
     * @param colNum colNum in which to embed the component
     * @param position positioning with respect to the record or cell (Defaults to "expand").
     */
    public native void addEmbeddedComponent(Canvas component, ListGridRecord record, Integer rowNum, Integer colNum, EmbeddedPosition position) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "addEmbeddedComponent", "Canvas,ListGridRecord,Integer,Integer,EmbeddedPosition");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.addEmbeddedComponent(component == null ? null : component.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()(), position == null ? null : position.@com.smartgwt.client.types.EmbeddedPosition::getValue()());
    }-*/;
	
	/**
     * Adds another {@link com.smartgwt.client.data.SortSpecifier} to this grid's sort configuration and resorts.
     * @param sortSpecifier A SortSpecifier object indicating an additional field    and direction to sort by
     */
    public native void addSort(SortSpecifier sortSpecifier) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "addSort", "SortSpecifier");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.addSort(sortSpecifier.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Applies a set of Records containing coordinate-based data as returned by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectedCellData getSelectedCellData()} and applies the data at the current
     * selection. <P> For consistency with Excel, given a record in the cellData, after the data value with the most negative
     * column index is found, the rest of the values in the record are applied contiguously to the right of it, using the
     * positional data for ordering only. <P> Will only modify cells in the grid which are editable, and changes will be
     * applied as editValues, exactly as though the user had typed the values in (see {@link com.smartgwt.client.docs.Editing
     * Grid Editing Overview}). <P> See also {@link com.smartgwt.client.widgets.grid.ListGrid#applyRecordData
     * applyRecordData()}.
     * @param cellData list of Records as described above
     */
    public native void applyCellData(RecordList cellData) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "applyCellData", "RecordList");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.applyCellData(cellData == null ? null : cellData.@com.smartgwt.client.core.BaseClass::getOrCreateJsObj()());
    }-*/;

	/**
     * Applies a list of Records as changes to the current selection. <P> Values found in each of the passed records will be
     * applied to the same-named fields in the Records starting from the top-left of the current selection, in order. <P> Will
     * only modify cells in the grid which are editable, and changes will be applied as editValues, exactly as though the user
     * had typed the values in (see {@link com.smartgwt.client.docs.Editing Grid Editing Overview}). <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#applyCellData applyCellData()}.
     * @param recordData list of Records as described above
     */
    public native void applyRecordData(RecordList recordData) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "applyRecordData", "RecordList");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.applyRecordData(recordData == null ? null : recordData.@com.smartgwt.client.core.BaseClass::getOrCreateJsObj()());
    }-*/;

	/**
     * Sort the grid's data to reflect the parameter sortSpecifiers. <p> <b>NOTE:</b> This method is primarily used by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()}; it is not intended  to be called by user code, unless you
     * are implementing a custom  {@link com.smartgwt.client.widgets.grid.ListGrid#addSetSortHandler setSortHandler}).  For the
     * normal use case, calling this  method directly will fail to execute vital pre-steps.  If you are not implementing a
     * custom handler as described above, do not call this method directly - call <code>setSort()</code>  instead.
     * @param sortSpecifiers Array of {@link com.smartgwt.client.data.SortSpecifier} objects
     */
    public native void applySortToData(SortSpecifier... sortSpecifiers) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "applySortToData", "SortSpecifier...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.applySortToData(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(sortSpecifiers));
    }-*/;

	/**
     * Show a dialog to configure the sorting of multiple fields on this component.  Calls through to {@link
     * com.smartgwt.client.widgets.MultiSortDialog#askForSort MultiSortDialog.askForSort()}, passing this component as the
     * fieldSource and the current {@link com.smartgwt.client.widgets.DataBoundComponent#getSort sort-specification} if there
     * is one. <P> The generated multiSortDialog can be customized via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMultiSortDialogDefaults multiSortDialogDefaults},  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getMultiSortDialogProperties multiSortDialogProperties}.
     */
    public native void askForSort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "askForSort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.askForSort();
    }-*/;

	/**
     * Programmatically cause a field to auto-fit horizontally to it's contents or title. <P> Does not establish permanent
     * auto-fitting - use {@link com.smartgwt.client.widgets.grid.ListGrid#setAutoFitWidth setAutoFitWidth()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setAutoFitFieldWidths setAutoFitFieldWidths()} to do so. <P> Note that unlike
     * the ongoing autoFit set up by {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}, any specified
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getWidth ListGridField.width} will not be taken as a minimum width
     * - the field may shrink below the current specified width when this method is run.  However, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getMinWidth ListGridField.minWidth} will be respected. <P> As with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths}, the auto-fit sizing is determined
     * via the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach autoFitWidthApproach}.
     * @param fieldName 
     *
     * @return new width in pixels
     */
    public native int autoFitField(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "autoFitField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.autoFitField(fieldName);
        return ret;
    }-*/;

	/**
     * Perform a one-time horizontal auto-fit of the fields passed. Fields will be sized to match their contents or title (as
     * specified in {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach autoFitWidthApproach}) Does not
     * establish permanent auto-fitting - use {@link com.smartgwt.client.widgets.grid.ListGrid#setAutoFitWidth
     * setAutoFitWidth()} to do so. <P> Note that unlike the ongoing autoFit set up by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}, any specified {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getWidth ListGridField.width} will not be taken as a minimum width - the
     * field(s) may shrink below the current specified width when this method is run.  However, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getMinWidth ListGridField.minWidth} will be respected.
     */
    public native void autoFitFields() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "autoFitFields", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.autoFitFields();
    }-*/;

	/**
     * Perform a one-time horizontal auto-fit of the fields passed. Fields will be sized to match their contents or title (as
     * specified in {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitWidthApproach autoFitWidthApproach}) Does not
     * establish permanent auto-fitting - use {@link com.smartgwt.client.widgets.grid.ListGrid#setAutoFitWidth
     * setAutoFitWidth()} to do so. <P> Note that unlike the ongoing autoFit set up by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths autoFitFieldWidths} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}, any specified {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getWidth ListGridField.width} will not be taken as a minimum width - the
     * field(s) may shrink below the current specified width when this method is run.  However, {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getMinWidth ListGridField.minWidth} will be respected.
     * @param fields Array of fields to auto fit. If this parameter  is not passed, autoFitting will occur on all visible fields.
     */
    public native void autoFitFields(ListGridField... fields) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "autoFitFields", "ListGridField...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.autoFitFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields));
    }-*/;
	
	/**
     * Cancel the current edit without saving.
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void cancelEditing() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "cancelEditing", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.cancelEditing();
    }-*/;

	/**
     * Can this cell be edited?
     *  <P>
     *  The default implementation of <code>canEditCell()</code> respects the various property
     *  settings affecting editability:
     *  <ul><li>{@link com.smartgwt.client.widgets.grid.ListGridField#getCanEdit field.canEdit} can be set to disable editing
     *           for a field</li>
     * <li>If the grid is bound to a dataSource, the {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEditFieldAttribute
     * canEditFieldAttribute} value on the
     *          dataSource field may enable / disable editing</li>
     *  <li>a record with the {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordEditProperty recordEditProperty} set to
     *          false is not editable</li>
     *      <li>disabled records are not editable</li>
     *  </ul>
     *  You can override this method to control editability on a cell-by-cell basis.  For example,
     *  if you had a grid that allows editing of "orders", and you had a field "shipDate" that is
     *  normally editable, but should not be editable if the order is already "complete", you might
     *  implement <code>canEditCell()</code> as follows:
     *  <P>
     *  
     *  <pre>
     *     public boolean canEditCell(int rowNum, int colNum) {
     *       Record record = this.getRecord(rowNum);
     *       String fieldName = this.getFieldName(colNum);
     *       if (fieldName.equals("shipDate") && record.getAttribute("orderStatus").equals("complete") {
     *         return false;
     *       }
     *       // use default rules for all other fields
     *       return super.canEditCell(rowNum, colNum);
     *     };
     *  </pre>    
     *  <P>
     *  Notes on providing custom implementations:
     *  <ul>
     *  <li> In order to allow complete control over editing, <code>canEditCell()</code> is called
     *  very frequently.  If you see delays on row to row navigation, check that your implementation
     *  is efficient
     *  <li> If you change the editability of a cell on the fly, for example, during
     * {@link com.smartgwt.client.widgets.grid.ListGrid#addEditorExitHandler ListGrid.editorExit()} on another cell, call
     * refreshCell() to show or hide the editor
     *  <li> If this ListGrid allows new records to be created, <code>canEditCell()</code> may be
     *  called when there is no record available, in which case getRecord() will return null.  The
     * values input so far by the user are available via {@link com.smartgwt.client.widgets.grid.ListGrid#getEditValues
     * getEditValues()}.
     *  </ul>
     *  <p>
     *  <b>Note: This is an override point.</b>
     * 
     * 
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     *
     * @return Whether to allow editing this cell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native boolean canEditCell(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "canEditCell", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__canEditCell(rowNum, colNum);
        return ret == null ? false : ret;
    }-*/;

	/**
     * Indicates whether a given record or rowNum can be expanded.  The default implementation checks the value of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} and <code>record[{@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecordProperty canExpandRecordProperty}]</code>. <P> Override this
     * method for more specific control over individual record expansion. <P> <b>Note:</b> Rows with no underlying record in
     * the data array - for example newly added edit rows that have not yet been saved - cannot be expanded.
     * @param record record to work with
     * @param rowNum rowNum of the record to work with
     *
     * @return true if the record can be expanded
     */
    public native boolean canExpandRecord(ListGridRecord record, int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "canExpandRecord", "ListGridRecord,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__canExpandRecord(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum);
        if(ret == null || ret === undefined) { return false; }
        return ret == null ? false : ret;
    }-*/;

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is set to <code>true</code> then,
     * whenever an end-user or programmatic cell-selection is attempted, this method is called for  each cell in the selection.
     * If it returns false, the cell will not be selected.
     * @param rowNum rowNum being selected
     * @param colNum colNum being selected
     *
     * @return return false to disallow selection
     */
    public native boolean canSelectCell(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "canSelectCell", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__canSelectCell(rowNum, colNum);
        return ret == null ? false : ret;
    }-*/;

    /**
     * Add a cellSaved handler.
     * <p>
     * Fires after user edits have been successfully saved to the server, only for cells where the value was actually modified.
     * <p> If you want immediate notification of a changes <b>before</b> changes has been saved to the server, implement {@link
     * com.smartgwt.client.widgets.grid.ListGridField#addChangeHandler field.change()} or {@link
     * com.smartgwt.client.widgets.grid.ListGridField#addChangedHandler field.changed()} instead. <P> You can alternatively use
     * {@link com.smartgwt.client.widgets.grid.ListGridField#cellChanged ListGridField.cellChanged()} to get notification only
     * of saved changes for a specific field.  If both a listGridField and the containing listGrid have a handler for this
     * event, only the handler defined on the field is called.
     *
     * @param handler the cellSaved handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellSavedHandler(com.smartgwt.client.widgets.grid.events.CellSavedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellSavedEvent.getType()) == 0) setupCellSavedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellSavedEvent.getType());
    }

    private native void setupCellSavedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellChanged = $entry(function(){
            var param = {"_this": this, "record" : arguments[0], "newValue" : arguments[1], "oldValue" : arguments[2], "rowNum" : arguments[3], "colNum" : arguments[4], "grid" : arguments[5]};
            var event = @com.smartgwt.client.widgets.grid.events.CellSavedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellSavedEvent()();
            if (hasDefaultHandler) this.Super("cellChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellChanged"));
            obj.addProperties({cellChanged:  cellChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellChanged"));
            obj.cellChanged =  cellChanged             ;
        }
    }-*/;

    private void handleTearDownCellSavedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellSavedEvent.getType()) == 0) tearDownCellSavedEvent();
    }

    private native void tearDownCellSavedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellChanged")) delete obj.cellChanged;
    }-*/;

    /**
     * Add a cellClick handler.
     * <p>
     * Called when a cell receives a click event. <P> Note that returning false from this method will not prevent any specified
     * {@link com.smartgwt.client.widgets.grid.ListGrid#rowClick ListGrid.rowClick()} handler from firing.
     *
     * @param handler the cellClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellClickHandler(com.smartgwt.client.widgets.grid.events.CellClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellClickEvent.getType()) == 0) setupCellClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellClickEvent.getType());
    }

    private native void setupCellClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellClick"));
            obj.addProperties({cellClick: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellClick"));
            obj.cellClick = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellClickEvent.getType()) == 0) tearDownCellClickEvent();
    }

    private native void tearDownCellClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellClick")) delete obj.cellClick;
    }-*/;

    /**
     * Add a cellContextClick handler.
     * <p>
     * Called when a cell receives a contextclick event.
     *
     * @param handler the cellContextClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellContextClickHandler(com.smartgwt.client.widgets.grid.events.CellContextClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellContextClickEvent.getType()) == 0) setupCellContextClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellContextClickEvent.getType());
    }

    private native void setupCellContextClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellContextClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellContextClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellContextClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellContextClick"));
            obj.addProperties({cellContextClick: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellContextClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellContextClick"));
            obj.cellContextClick = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellContextClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellContextClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellContextClickEvent.getType()) == 0) tearDownCellContextClickEvent();
    }

    private native void tearDownCellContextClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellContextClick")) delete obj.cellContextClick;
    }-*/;

    /**
     * Add a cellDoubleClick handler.
     * <p>
     * Called when a cell receives a double click event.
     *
     * @param handler the cellDoubleClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellDoubleClickHandler(com.smartgwt.client.widgets.grid.events.CellDoubleClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellDoubleClickEvent.getType()) == 0) setupCellDoubleClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellDoubleClickEvent.getType());
    }

    private native void setupCellDoubleClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellDoubleClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellDoubleClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellDoubleClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellDoubleClick"));
            obj.addProperties({cellDoubleClick: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellDoubleClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellDoubleClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellDoubleClick"));
            obj.cellDoubleClick = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellDoubleClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellDoubleClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellDoubleClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellDoubleClickEvent.getType()) == 0) tearDownCellDoubleClickEvent();
    }

    private native void tearDownCellDoubleClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellDoubleClick")) delete obj.cellDoubleClick;
    }-*/;

    /**
     * Add a cellErrorIconHover handler.
     * <p>
     * Optional stringMethod to fire when the user hovers over the error icon of a cell with  validation errors.  The default
     * behavior is to show a hover canvas containing the validation error message text. Call {@link
     * com.smartgwt.client.widgets.grid.events.CellErrorIconHoverEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.CellErrorIconHoverHandler#onCellErrorIconHover} to suppress this default
     * behavior.
     *
     * @param handler the cellErrorIconHover handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellErrorIconHoverHandler(com.smartgwt.client.widgets.grid.events.CellErrorIconHoverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconHoverEvent.getType()) == 0) setupCellErrorIconHoverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellErrorIconHoverEvent.getType());
    }

    private native void setupCellErrorIconHoverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellErrorIconHover = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellErrorIconHoverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellErrorIconHoverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellErrorIconHover"));
            obj.addProperties({cellErrorIconHover: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconHover", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellErrorIconHover"));
            obj.cellErrorIconHover = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconHover", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellErrorIconHoverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconHoverEvent.getType()) == 0) tearDownCellErrorIconHoverEvent();
    }

    private native void tearDownCellErrorIconHoverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellErrorIconHover")) delete obj.cellErrorIconHover;
    }-*/;

    /**
     * Add a cellErrorIconOut handler.
     * <p>
     * Optional stringMethod to fire when the mouse moves off the error icon of a cell with  validation errors.
     *
     * @param handler the cellErrorIconOut handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellErrorIconOutHandler(com.smartgwt.client.widgets.grid.events.CellErrorIconOutHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconOutEvent.getType()) == 0) setupCellErrorIconOutEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellErrorIconOutEvent.getType());
    }

    private native void setupCellErrorIconOutEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellErrorIconOut = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellErrorIconOutEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellErrorIconOutEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellErrorIconOut"));
            obj.addProperties({cellErrorIconOut: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconOut", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellErrorIconOut"));
            obj.cellErrorIconOut = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconOut", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellErrorIconOutEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconOutEvent.getType()) == 0) tearDownCellErrorIconOutEvent();
    }

    private native void tearDownCellErrorIconOutEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellErrorIconOut")) delete obj.cellErrorIconOut;
    }-*/;

    /**
     * Add a cellErrorIconOver handler.
     * <p>
     * Optional stringMethod to fire when the mouse moves over the error icon of a cell with  validation errors.
     *
     * @param handler the cellErrorIconOver handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellErrorIconOverHandler(com.smartgwt.client.widgets.grid.events.CellErrorIconOverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconOverEvent.getType()) == 0) setupCellErrorIconOverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellErrorIconOverEvent.getType());
    }

    private native void setupCellErrorIconOverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellErrorIconOver = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellErrorIconOverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellErrorIconOverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellErrorIconOver"));
            obj.addProperties({cellErrorIconOver: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconOver", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellErrorIconOver"));
            obj.cellErrorIconOver = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellErrorIconOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellErrorIconOver", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellErrorIconOverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellErrorIconOverEvent.getType()) == 0) tearDownCellErrorIconOverEvent();
    }

    private native void tearDownCellErrorIconOverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellErrorIconOver")) delete obj.cellErrorIconOver;
    }-*/;

	/**
     * If this listGrid can be edited, this method will return true if the cell passed in has been edited, but the edits have
     * not yet been saved to the ListGrid's data object.
     * @param rowNum index of row to check for changes
     * @param colNum index of the col to check for changes
     *
     * @return returns true if the cell has unsaved edits
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean cellHasChanges(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "cellHasChanges", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.cellHasChanges(rowNum, colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Given a rowNum and a colNum or fieldName, determine whether we currently have stored validation errors for the
     * record/field in question.
     * @param rowNum index of row to check for validation errors
     * @param fieldID name of field, or index of column to check for validation                                      errors
     *
     * @return true if we have validation errors for the row/col in question
     * @see com.smartgwt.client.widgets.grid.ListGrid#hasErrors
     * @see com.smartgwt.client.widgets.grid.ListGrid#rowHasErrors
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Boolean cellHasErrors(int rowNum, String fieldID) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "cellHasErrors", "int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.cellHasErrors(rowNum, fieldID);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * Add a cellHover handler.
     * <p>
     * Called when the mouse hovers over a cell if this.canHover is true.   Returning false will suppress the hover text from
     * being shown if this.showHover is true.
     *
     * @param handler the cellHover handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellHoverHandler(com.smartgwt.client.widgets.grid.events.CellHoverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellHoverEvent.getType()) == 0) setupCellHoverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellHoverEvent.getType());
    }

    private native void setupCellHoverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellHover = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellHoverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellHoverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellHover"));
            obj.addProperties({cellHover: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellHover", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellHover"));
            obj.cellHover = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellHover", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellHoverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellHoverEvent.getType()) == 0) tearDownCellHoverEvent();
    }

    private native void tearDownCellHoverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellHover")) delete obj.cellHover;
    }-*/;

    /**
     * Add a cellMouseDown handler.
     * <p>
     * Called when a cell receives a mousedown event.
     *
     * @param handler the cellMouseDown handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellMouseDownHandler(com.smartgwt.client.widgets.grid.events.CellMouseDownHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellMouseDownEvent.getType()) == 0) setupCellMouseDownEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellMouseDownEvent.getType());
    }

    private native void setupCellMouseDownEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellMouseDown = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellMouseDownEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellMouseDownEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellMouseDown"));
            obj.addProperties({cellMouseDown: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellMouseDown(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellMouseDown", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellMouseDown"));
            obj.cellMouseDown = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellMouseDown(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellMouseDown", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellMouseDownEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellMouseDownEvent.getType()) == 0) tearDownCellMouseDownEvent();
    }

    private native void tearDownCellMouseDownEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellMouseDown")) delete obj.cellMouseDown;
    }-*/;

    /**
     * Add a cellMouseUp handler.
     * <p>
     * Called when a cell receives a mouseup event.
     *
     * @param handler the cellMouseUp handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellMouseUpHandler(com.smartgwt.client.widgets.grid.events.CellMouseUpHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellMouseUpEvent.getType()) == 0) setupCellMouseUpEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellMouseUpEvent.getType());
    }

    private native void setupCellMouseUpEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellMouseUp = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellMouseUpEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellMouseUpEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellMouseUp"));
            obj.addProperties({cellMouseUp: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellMouseUp(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellMouseUp", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellMouseUp"));
            obj.cellMouseUp = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellMouseUp(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellMouseUp", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellMouseUpEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellMouseUpEvent.getType()) == 0) tearDownCellMouseUpEvent();
    }

    private native void tearDownCellMouseUpEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellMouseUp")) delete obj.cellMouseUp;
    }-*/;

    /**
     * Add a cellOut handler.
     * <p>
     * Called when the mouse pointer leaves a cell
     *
     * @param handler the cellOut handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellOutHandler(com.smartgwt.client.widgets.grid.events.CellOutHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellOutEvent.getType()) == 0) setupCellOutEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellOutEvent.getType());
    }

    private native void setupCellOutEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellOut = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellOutEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellOutEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellOut"));
            obj.addProperties({cellOut: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellOut", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellOut"));
            obj.cellOut = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellOut", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellOutEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellOutEvent.getType()) == 0) tearDownCellOutEvent();
    }

    private native void tearDownCellOutEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellOut")) delete obj.cellOut;
    }-*/;

    /**
     * Add a cellOver handler.
     * <p>
     * Called when the mouse pointer enters a cell
     *
     * @param handler the cellOver handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellOverHandler(com.smartgwt.client.widgets.grid.events.CellOverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellOverEvent.getType()) == 0) setupCellOverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellOverEvent.getType());
    }

    private native void setupCellOverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellOver = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellOverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellOverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellOver"));
            obj.addProperties({cellOver: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellOver", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellOver"));
            obj.cellOver = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellOver", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellOverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellOverEvent.getType()) == 0) tearDownCellOverEvent();
    }

    private native void tearDownCellOverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellOver")) delete obj.cellOver;
    }-*/;

    /**
     * Add a cellSelectionChanged handler.
     * <p>
     * Called when (cell-based) selection changes within this grid.
     *
     * @param handler the cellSelectionChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellSelectionChangedHandler(com.smartgwt.client.widgets.grid.events.CellSelectionChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellSelectionChangedEvent.getType()) == 0) setupCellSelectionChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellSelectionChangedEvent.getType());
    }

    private native void setupCellSelectionChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellSelectionChanged = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellSelectionChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellSelectionChangedEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellSelectionChanged"));
            obj.addProperties({cellSelectionChanged: 
                function () {
                    var param = {"_this": this, "cellList" : arguments[0]};
                    var ret = cellSelectionChanged(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellSelectionChanged", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellSelectionChanged"));
            obj.cellSelectionChanged = 
                function () {
                    var param = {"_this": this, "cellList" : arguments[0]};
                    var ret = cellSelectionChanged(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellSelectionChanged", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellSelectionChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellSelectionChangedEvent.getType()) == 0) tearDownCellSelectionChangedEvent();
    }

    private native void tearDownCellSelectionChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellSelectionChanged")) delete obj.cellSelectionChanged;
    }-*/;

    /**
     * Add a cellValueHover handler.
     * <p>
     * Optional stringMethod to fire when the user hovers over a cell and the value is clipped. If
     * this.showClippedValuesOnHover is true, the default behavior is to show a hover canvas containing the HTML returned by
     * cellValueHoverHTML(). Call {@link com.smartgwt.client.widgets.grid.events.CellValueHoverEvent#cancel()} from within
     * {@link com.smartgwt.client.widgets.grid.events.CellValueHoverHandler#onCellValueHover} to suppress this default
     * behavior.
     *
     * @param handler the cellValueHover handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addCellValueHoverHandler(com.smartgwt.client.widgets.grid.events.CellValueHoverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.CellValueHoverEvent.getType()) == 0) setupCellValueHoverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.CellValueHoverEvent.getType());
    }

    private native void setupCellValueHoverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var cellValueHover = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.CellValueHoverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownCellValueHoverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("cellValueHover"));
            obj.addProperties({cellValueHover: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellValueHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellValueHover", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("cellValueHover"));
            obj.cellValueHover = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = cellValueHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("cellValueHover", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownCellValueHoverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.CellValueHoverEvent.getType()) == 0) tearDownCellValueHoverEvent();
    }

    private native void tearDownCellValueHoverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("cellValueHover")) delete obj.cellValueHover;
    }-*/;

	/**
     * Returns the HTML that is displayed by the default cellValueHover handler. Return null or an empty string to cancel the
     * hover. <p>Use <code>setCellValueHoverFormatter()</code> to provide a custom implementation.
     * @param record cell record as returned by getCellRecord()
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     * @param defaultHTML the HTML that would have been displayed by default.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     *
     * @return HTML to be displayed in the hover. If null or an empty string, then the hover is canceled.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     * @see com.smartgwt.client.widgets.grid.events.CellValueHoverEvent
     */
    public native String cellValueHoverHTML(ListGridRecord record, int rowNum, int colNum, String defaultHTML) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "cellValueHoverHTML", "ListGridRecord,int,int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.cellValueHoverHTML(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum, colNum, defaultHTML);
        return ret;
    }-*/;

	/**
     * Is the value in a given cell clipped?
     * @param rowNum row number of the cell
     * @param colNum column number of the cell
     *
     * @return null if there is no cell at the given row, column; otherwise, whether the value in the specified cell is clipped.
     * @see com.smartgwt.client.widgets.grid.events.CellValueHoverEvent
     */
    public native Boolean cellValueIsClipped(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "cellValueIsClipped", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.cellValueIsClipped(rowNum, colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Chart the data in this listGrid as a multi-series chart. <P> Each row provides a series of data.  Each series of data is
     * labeled by a value from one column, called the <code>labelField</code>. <P> For example, cell values are sales figures,
     * and fields are "Product", "August", "September", "October".  In this case each row gives a series: sales figures for
     * each of 3 months.  The <code>labelField</code> in this case is the "Product" field, meaning each row represents sales
     * figures for each of 3 months for a particular product.  This dataset can be charted via any multi-series chart: stacked
     * or clustered bar or column chart, line chart with multiple lines, or area chart (stacked lines). <P> By default, all
     * visible fields other than the label field are assumed to be labels for series values, but an explicit list of fields can
     * be provided as <code>dataFields</code>. <P> By default, all data is charted if all data is loaded, otherwise, data
     * visible in the viewport is charted.  An explicit set of rows can be provided via <code>dataRows</code>.
     * @param labelField name of the field
     *
     * @return created Chart instance
     * @see <a href="http://www.smartclient.com/smartgwtee/showcase/#gridCharting" target="examples">Grid Charting Example</a>
     */
    public native FacetChart chartData(String labelField) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "chartData", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.chartData(labelField);
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
     * @see ListGrid#chartData
     */
    public FacetChart chartData(String labelField, String[] dataFields){
        return chartData(labelField, dataFields, null, null, false);
    }

    /**
     * @see ListGrid#chartData
     */
    public FacetChart chartData(String labelField, String[] dataFields, ListGridRecord... dataRows){
        return chartData(labelField, dataFields, dataRows, null, false);
    }

    /**
     * @see ListGrid#chartData
     */
    public FacetChart chartData(String labelField, String[] dataFields, ListGridRecord[] dataRows, FacetChart chartProperties){
        return chartData(labelField, dataFields, dataRows, chartProperties, false);
    }

	/**
     * Chart the data in this listGrid as a multi-series chart. <P> Each row provides a series of data.  Each series of data is
     * labeled by a value from one column, called the <code>labelField</code>. <P> For example, cell values are sales figures,
     * and fields are "Product", "August", "September", "October".  In this case each row gives a series: sales figures for
     * each of 3 months.  The <code>labelField</code> in this case is the "Product" field, meaning each row represents sales
     * figures for each of 3 months for a particular product.  This dataset can be charted via any multi-series chart: stacked
     * or clustered bar or column chart, line chart with multiple lines, or area chart (stacked lines). <P> By default, all
     * visible fields other than the label field are assumed to be labels for series values, but an explicit list of fields can
     * be provided as <code>dataFields</code>. <P> By default, all data is charted if all data is loaded, otherwise, data
     * visible in the viewport is charted.  An explicit set of rows can be provided via <code>dataRows</code>.
     * @param labelField name of the field
     * @param dataFields optional list of fields to use as labels.  By      default, all fields are used.
     * @param dataRows set of records to chart.  Can be obtained by eg      {@link com.smartgwt.client.data.ResultSet#getRange
     * grid.data.getRange()}.
     * @param chartProperties properties to pass to the created chart
     * @param labelFieldFirst if true, use the labelField as the "first" set of labels,      for example, as the bar labels in a stacked bar chart,
     * whereas the second set of labels      would appear as the legend.
     *
     * @return created Chart instance
     * @see <a href="http://www.smartclient.com/smartgwtee/showcase/#gridCharting" target="examples">Grid Charting Example</a>
     */
    public native FacetChart chartData(String labelField, String[] dataFields, ListGridRecord[] dataRows, FacetChart chartProperties, boolean labelFieldFirst) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "chartData", "String,String[],ListGridRecord[],FacetChart,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.chartData(labelField, @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(dataFields), @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(dataRows), chartProperties == null ? null : chartProperties.@com.smartgwt.client.widgets.BaseWidget::getConfig()(), labelFieldFirst);
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * Clear the current criteria used to filter data.
     * @see com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_filter" target="examples">Databound filter Example</a>
     */
    public native void clearCriteria() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "clearCriteria", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearCriteria();
    }-*/;

    /**
     * @see ListGrid#clearCriteria
     */
    public void clearCriteria(DSCallback callback){
        clearCriteria(callback, null);
    }

	/**
     * Clear the current criteria used to filter data.
     * @param callback callback to invoke on completion
     * @param requestProperties additional properties to set on the DSRequest                                            that will be issued
     * @see com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_filter" target="examples">Databound filter Example</a>
     */
    public native void clearCriteria(DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "clearCriteria", "DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearCriteria(
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Clears any validation errors for some cell.
     * @param rowNum row index of cell to add validation error for
     * @param fieldName col index or field name of cell to add validation error for
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFieldError
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native void clearFieldError(int rowNum, int fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "clearFieldError", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearFieldError(rowNum, fieldName);
    }-*/;

	/**
     * Clear any stored validation errors for some row
     * @param rowNum index of row to clear validation error for
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRowErrors
     * @see com.smartgwt.client.docs.Validation Validation overview and related methods
     */
    public native void clearRowErrors(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "clearRowErrors", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearRowErrors(rowNum);
    }-*/;

	/**
     * This method clears any existing sort on this grid by calling {@link com.smartgwt.client.widgets.grid.ListGrid#setSort
     * setSort()} with a null parameter.  The internal list of {@link com.smartgwt.client.data.SortSpecifier}s is removed and
     * the grid is unsorted.
     */
    public native void clearSort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "clearSort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearSort();
    }-*/;

	/**
     * Closes the node represented by the "record" parameter, if it is a folder and is not already closed.  This method only
     * applies to {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} ListGrids.
     * @param record node to close
     *
     * @return true if the node was closed, false if it was not (either because it is not                   a folder, or because it was
     * already closed)
     */
    public native boolean closeGroup(Record record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "closeGroup", "Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.closeGroup(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret == null ? false : ret;
    }-*/;

	/**
     * Collapses a given {@link com.smartgwt.client.widgets.grid.ListGridRecord record} which has been previously expanded
     * using {@link com.smartgwt.client.widgets.grid.ListGrid#expandRecord expandRecord()}. <P> Depending on the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponentPoolingMode pooling mode}, this method may automatically
     * destroy expansionComponents.  By default, components created automatically by the ListGrid will be auto-destroyed.  This
     * behavior can be changed by setting a different pooling mode. <P> Note that components created via an override to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponent getExpansionComponent()} will <b><i>not</i></b> be
     * auto-destroyed - developers should override <code>collapseRecord</code> to take care of clean-up for such components.
     * @param record record to collapse
     */
    public native void collapseRecord(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "collapseRecord", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.collapseRecord(record.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Collapses the passed list of expanded {@link com.smartgwt.client.widgets.grid.ListGridRecord records}.  Calls {@link
     * com.smartgwt.client.widgets.grid.ListGrid#collapseRecord collapseRecord} for each passed record, but only marks the grid
     * for redraw once, after all records have been collapsed.
     * @param records records to collapse
     */
    public native void collapseRecords(ListGridRecord... records) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "collapseRecords", "ListGridRecord...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.collapseRecords(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records));
    }-*/;

	/**
     * Open a MultiGroupDialog to configure the fields used for grouping.
     */
    public native void configureGrouping() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "configureGrouping", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.configureGrouping();
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, this method
     * is called to create per-row or per-cell embedded components to display in the grid. <p> The colNum parameter is
     * applicable only when {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * showRecordComponentsByCell} is true. <p> If this row should not have a <code>recordComponent</code>, return null. <p>
     * This method should create and return a new component for the record passed in every time it is called and never return
     * the same Canvas instance twice.  To re-use components with different rows, set {@link
     * com.smartgwt.client.types.RecordComponentPoolingMode} to "recycle".  In this mode, in addition to implementing this
     * method, developers should also implement {@link com.smartgwt.client.widgets.grid.ListGrid#updateRecordComponent
     * updateRecordComponent()} which allows already created components to be altered for re-use in new records. See the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} overview for more information.
     * @param record record to create a component for
     * @param colNum cell to which the component applies
     *
     * @return return the component to embed in the passed record
     */
    protected native Canvas createRecordComponent(ListGridRecord record, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "createRecordComponent", "ListGridRecord,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__createRecordComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
     * Add a dataArrived handler.
     * <p>
     * Notification method fired when new data arrives from the server to be displayed in this ListGrid, (for example in
     * response to the user scrolling a new set of rows into view). Only applies to databound listGrids where the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getData data} attribute is a {@link com.smartgwt.client.data.ResultSet}. This
     * ResultSet may have been created manually and applied to the grid via a call to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setData ListGrid.setData()} or may have been created and automatically
     * assigned if {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData ListGrid.fetchData()} was used to populate the
     * grid.  This method is fired directly in response to {@link com.smartgwt.client.data.ResultSet#addDataArrivedHandler
     * dataArrived()} firing on the data object. <P> Note that <code>dataArrived()</code>, unlike {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addDataChangedHandler ListGrid.dataChanged()}, only fires in limited
     * circumstances - when data for a {@link com.smartgwt.client.data.ResultSet} arrives from the server due to a fetch or
     * cache invalidation, or as a result of filtering.  If you want to catch all data changes, you should instead react to
     * {@link com.smartgwt.client.widgets.grid.ListGrid#addDataChangedHandler ListGrid.dataChanged()}.
     *
     * @param handler the dataArrived handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addDataArrivedHandler(com.smartgwt.client.widgets.grid.events.DataArrivedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.DataArrivedEvent.getType()) == 0) setupDataArrivedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.DataArrivedEvent.getType());
    }

    private native void setupDataArrivedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var dataArrived = $entry(function(){
            var param = {"_this": this, "startRow" : arguments[0], "endRow" : arguments[1]};
            var event = @com.smartgwt.client.widgets.grid.events.DataArrivedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownDataArrivedEvent()();
            if (hasDefaultHandler) this.Super("dataArrived", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("dataArrived"));
            obj.addProperties({dataArrived:  dataArrived              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("dataArrived"));
            obj.dataArrived =  dataArrived             ;
        }
    }-*/;

    private void handleTearDownDataArrivedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.DataArrivedEvent.getType()) == 0) tearDownDataArrivedEvent();
    }

    private native void tearDownDataArrivedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("dataArrived")) delete obj.dataArrived;
    }-*/;

    /**
     * Add a dataChanged handler.
     * <p>
     * Notification method fired when the ListGrid's data changes, for any reason. <P>  Examples of why data changed might
     * be:<ul> <li> a call to {@link com.smartgwt.client.widgets.grid.ListGrid#addData ListGrid.addData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#updateData ListGrid.updateData()}, or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeData ListGrid.removeData()} <li> {@link
     * com.smartgwt.client.data.DataSource} updates from the server for {@link com.smartgwt.client.data.ResultSet} data
     * (triggered by record editing, etc.) <li> fetches arriving back from the server for {@link
     * com.smartgwt.client.data.ResultSet} data <li> changes to array data if made through APIs such as  Array.set(), 
     * Array.add(), etc. <li> cache invalidation <li> filtering </ul> Calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setData ListGrid.setData()} doesn't call this notification directly, but it
     * may fire if one of the above listed events is triggered (e.g. a server fetch for  {@link
     * com.smartgwt.client.data.ResultSet} data). <P> Note that the <code>operationType</code> parameter is optional and will
     * be passed and contain the operation (e.g. "update") if this notification was triggered by a fetch, an {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addData ListGrid.addData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#updateData ListGrid.updateData()}, or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#removeData ListGrid.removeData()}, or a {@link
     * com.smartgwt.client.data.DataSource} update for {@link com.smartgwt.client.data.ResultSet} data (the first three reasons
     * listed above) but otherwise will be null.
     *
     * @param handler the dataChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addDataChangedHandler(com.smartgwt.client.widgets.grid.events.DataChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.DataChangedEvent.getType()) == 0) setupDataChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.DataChangedEvent.getType());
    }

    private native void setupDataChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var dataChanged = $entry(function(){
            var param = {"_this": this, "operationType" : arguments[0]};
            var event = @com.smartgwt.client.widgets.grid.events.DataChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownDataChangedEvent()();
            if (hasDefaultHandler) this.Super("dataChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("dataChanged"));
            obj.addProperties({dataChanged:  dataChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("dataChanged"));
            obj.dataChanged =  dataChanged             ;
        }
    }-*/;

    private void handleTearDownDataChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.DataChangedEvent.getType()) == 0) tearDownDataChangedEvent();
    }

    private native void tearDownDataChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("dataChanged")) delete obj.dataChanged;
    }-*/;

	/**
     * Deselect a contiguous range of records by index. <P> This is a synonym for <code>selectRange(startRow, endRow,
     * false);</code>
     * @param startRow start of selection range
     * @param endRow end of selection range (non-inclusive)
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native void deselectRange(int startRow, int endRow) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "deselectRange", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.deselectRange(startRow, endRow);
    }-*/;

	/**
     * Cancel outstanding edits, discarding edit values, and hiding editors for the record[s] passed in if appropriate. <P> If
     * no rows are passed in, all outstanding edit values will be dropped.  This will <b>not</b> automatically end editing;
     * call {@link com.smartgwt.client.widgets.grid.ListGrid#endEditing endEditing()} <b>before</b> calling discardAllEdits()
     * if you also want to end editing. <P> Note that this also clears the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved removed} state of any records that have been marked as
     * removed.
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void discardAllEdits() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "discardAllEdits", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.discardAllEdits();
    }-*/;

    /**
     * @see ListGrid#discardAllEdits
     */
    public void discardAllEdits(int[] rows){
        discardAllEdits(rows, false);
    }

	/**
     * Cancel outstanding edits, discarding edit values, and hiding editors for the record[s] passed in if appropriate. <P> If
     * no rows are passed in, all outstanding edit values will be dropped.  This will <b>not</b> automatically end editing;
     * call {@link com.smartgwt.client.widgets.grid.ListGrid#endEditing endEditing()} <b>before</b> calling discardAllEdits()
     * if you also want to end editing. <P> Note that this also clears the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved removed} state of any records that have been marked as
     * removed.
     * @param rows allows you to specify which row(s) to drop edits for
     * @param dontHideEditor By default this method will hide the editor if                              it is currently showing for any row in the
     * grid. Passing in                              this parameter will leave the editor visible (and just reset              
     *                the edit values underneath the editor).
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void discardAllEdits(int[] rows, boolean dontHideEditor) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "discardAllEdits", "int[],boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.discardAllEdits(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(rows), dontHideEditor);
    }-*/;
	
	/**
     * Cancel outstanding edits for the specified rows, discarding edit values, and hiding editors if appropriate. <P> Note
     * that if this method is called on a new edit row (created via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditingNew startEditingNew()} for example), which has not yet been saved,
     * this method will remove the row entirely. <P> Also note that this method will clear the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved removed} state of records that have been marked as removed.
     * @param rowNum Row to cancel
     * @param colNum Column to cancel. Note that this parameter is ignored in ListGrids but                        may be required in
     * subclasses of ListGrid where each cell represents                        one record in the data set (EG CubeGrid)
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void discardEdits(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "discardEdits", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.discardEdits(rowNum, colNum);
    }-*/;

	/**
     * Cancel outstanding edits for the specified rows, discarding edit values, and hiding editors if appropriate. <P> Note
     * that if this method is called on a new edit row (created via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditingNew startEditingNew()} for example), which has not yet been saved,
     * this method will remove the row entirely. <P> Also note that this method will clear the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved removed} state of records that have been marked as removed.
     * @param rowNum Row to cancel
     * @param colNum Column to cancel. Note that this parameter is ignored in ListGrids but                        may be required in
     * subclasses of ListGrid where each cell represents                        one record in the data set (EG CubeGrid)
     * @param dontHideEditor By default this method will hide the editor if                              it is currently showing for the row in
     * question. Passing in                              this parameter will leave the editor visible (and just reset          
     *                    the edit values underneath the editor).
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void discardEdits(int rowNum, int colNum, Boolean dontHideEditor) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "discardEdits", "int,int,Boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.discardEdits(rowNum, colNum, dontHideEditor == null ? null : dontHideEditor.@java.lang.Boolean::booleanValue()());
    }-*/;
	
	/**
     * Modify the grid UI to reflect the parameter sortSpecifiers.  For a single sortSpecifier,  this consists of marking the
     * field with a directional arrow in its header button (if it  visible). <P> If multiple fields are sorted, those that are
     * visible show a directional icon and a small {@link com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralStyle
     * sort-numeral} indicating that field's index in the sort  configuration. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addSort addSort()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#toggleSort toggleSort()} APIs for information on making changes to the current
     * sort configuration. <p> <b>NOTE:</b> This method is primarily used by {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()}; it is not intended  to be called by user code, unless you
     * are implementing a custom  {@link com.smartgwt.client.widgets.grid.ListGrid#addSetSortHandler setSortHandler}).  For the
     * normal use case, calling this  method directly will fail to execute vital pre-steps.  If you are not implementing a
     * custom handler as described above, do not call this method directly - call <code>setSort()</code>  instead.
     * @param sortSpecifiers Array of {@link com.smartgwt.client.data.SortSpecifier} objects
     */
    public native void displaySort(SortSpecifier... sortSpecifiers) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "displaySort", "SortSpecifier...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.displaySort(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(sortSpecifiers));
    }-*/;

    /**
     * Add a drawAreaChanged handler.
     * <p>
     * Notification method that fires when the drawArea changes due to scrolling.  Receives the previous drawArea co-ordinates
     * as parameters.  Call {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawArea ListGrid.getDrawArea()} to get the new
     * drawArea co-ordinates. <P> Note that if this grid is showing any {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, they will not be included in the
     * <code>oldStartCol</code>, <code>oldEndCol</code> range reported by this method. Frozen fields are assumed never to be
     * scrolled out of view.
     *
     * @param handler the drawAreaChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addDrawAreaChangedHandler(com.smartgwt.client.widgets.grid.events.DrawAreaChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.DrawAreaChangedEvent.getType()) == 0) setupDrawAreaChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.DrawAreaChangedEvent.getType());
    }

    private native void setupDrawAreaChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var drawAreaChanged = $entry(function(){
            var param = {"_this": this, "oldStartRow" : arguments[0], "oldEndRow" : arguments[1], "oldStartCol" : arguments[2], "oldEndCol" : arguments[3]};
            var event = @com.smartgwt.client.widgets.grid.events.DrawAreaChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownDrawAreaChangedEvent()();
            if (hasDefaultHandler) this.Super("drawAreaChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("drawAreaChanged"));
            obj.addProperties({drawAreaChanged:  drawAreaChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("drawAreaChanged"));
            obj.drawAreaChanged =  drawAreaChanged             ;
        }
    }-*/;

    private void handleTearDownDrawAreaChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.DrawAreaChangedEvent.getType()) == 0) tearDownDrawAreaChangedEvent();
    }

    private native void tearDownDrawAreaChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("drawAreaChanged")) delete obj.drawAreaChanged;
    }-*/;

    /**
     * Add a editComplete handler.
     * <p>
     * Callback fired when inline edits have been successfully saved. <P> No default implementation.
     *
     * @param handler the editComplete handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addEditCompleteHandler(com.smartgwt.client.widgets.grid.events.EditCompleteHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.EditCompleteEvent.getType()) == 0) setupEditCompleteEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.EditCompleteEvent.getType());
    }

    private native void setupEditCompleteEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var editComplete = $entry(function(){
            var param = {"_this": this, "rowNum" : arguments[0], "colNum" : arguments[1], "newValues" : arguments[2], "oldValues" : arguments[3], "editCompletionEvent" : arguments[4], "dsResponse" : arguments[5]};
            var event = @com.smartgwt.client.widgets.grid.events.EditCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownEditCompleteEvent()();
            if (hasDefaultHandler) this.Super("editComplete", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("editComplete"));
            obj.addProperties({editComplete:  editComplete              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("editComplete"));
            obj.editComplete =  editComplete             ;
        }
    }-*/;

    private void handleTearDownEditCompleteEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.EditCompleteEvent.getType()) == 0) tearDownEditCompleteEvent();
    }

    private native void tearDownEditCompleteEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("editComplete")) delete obj.editComplete;
    }-*/;

    /**
     * Add a editFailed handler.
     * <p>
     * Called when an attempt to save inline edits fails, due to a validation error or other server error. <P> The default
     * implementation of editFailed does nothing for normal validation errors, which are displayed before editFailed() is
     * called.  For any other errors, the default implementation will call {@link
     * com.smartgwt.client.rpc.HandleErrorCallback#handleError HandleErrorCallback.handleError()}, which by default will result
     * in a warning dialog.
     *
     * @param handler the editFailed handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addEditFailedHandler(com.smartgwt.client.widgets.grid.events.EditFailedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.EditFailedEvent.getType()) == 0) setupEditFailedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.EditFailedEvent.getType());
    }

    private native void setupEditFailedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var editFailed = $entry(function(){
            var param = {"_this": this, "rowNum" : arguments[0], "colNum" : arguments[1], "newValues" : arguments[2], "oldValues" : arguments[3], "editCompletionEvent" : arguments[4], "dsResponse" : arguments[5]};
            var event = @com.smartgwt.client.widgets.grid.events.EditFailedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownEditFailedEvent()();
            if (hasDefaultHandler) this.Super("editFailed", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("editFailed"));
            obj.addProperties({editFailed:  editFailed              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("editFailed"));
            obj.editFailed =  editFailed             ;
        }
    }-*/;

    private void handleTearDownEditFailedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.EditFailedEvent.getType()) == 0) tearDownEditFailedEvent();
    }

    private native void tearDownEditFailedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("editFailed")) delete obj.editFailed;
    }-*/;

    /**
     * Add a editorEnter handler.
     * <p>
     * Callback fired when the user starts editing a new cell. <P> This callback is typically used to establish dynamic default
     * values via {@link com.smartgwt.client.widgets.grid.ListGrid#setEditValue ListGrid.setEditValue()} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setEditValues ListGrid.setEditValues()}. <P> Can also be overridden on a
     * per-field basis via {@link com.smartgwt.client.widgets.grid.ListGridField#addEditorEnterHandler field.editorEnter}.
     *
     * @param handler the editorEnter handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addEditorEnterHandler(com.smartgwt.client.widgets.grid.events.EditorEnterHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.EditorEnterEvent.getType()) == 0) setupEditorEnterEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.EditorEnterEvent.getType());
    }

    private native void setupEditorEnterEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var editorEnter = $entry(function(){
            var param = {"_this": this, "record" : arguments[0], "value" : arguments[1], "rowNum" : arguments[2], "colNum" : arguments[3]};
            var event = @com.smartgwt.client.widgets.grid.events.EditorEnterEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownEditorEnterEvent()();
            if (hasDefaultHandler) this.Super("editorEnter", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("editorEnter"));
            obj.addProperties({editorEnter:  editorEnter              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("editorEnter"));
            obj.editorEnter =  editorEnter             ;
        }
    }-*/;

    private void handleTearDownEditorEnterEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.EditorEnterEvent.getType()) == 0) tearDownEditorEnterEvent();
    }

    private native void tearDownEditorEnterEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("editorEnter")) delete obj.editorEnter;
    }-*/;

    /**
     * Add a editorExit handler.
     * <p>
     * Callback fired when the user attempts to navigate away from the current edit cell, or complete the current edit. <P>
     * Call {@link com.smartgwt.client.widgets.grid.events.EditorExitEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.EditorExitHandler#onEditorExit} from this method to cancel the default behavior
     * (Saving / cancelling the current edit / moving to the next edit cell). <P> This callback is typically used to
     * dynamically update values or value maps for related fields (via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setEditValue ListGrid.setEditValue()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setEditorValueMap ListGrid.setEditorValueMap()} respectively, or to implement
     * custom navigation (via {@link com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing(rowNum,colNum)}. <P>
     * Can be overridden at the field level as field.editorExit.
     *
     * @param handler the editorExit handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addEditorExitHandler(com.smartgwt.client.widgets.grid.events.EditorExitHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.EditorExitEvent.getType()) == 0) setupEditorExitEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.EditorExitEvent.getType());
    }

    private native void setupEditorExitEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var editorExit = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.EditorExitEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownEditorExitEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("editorExit"));
            obj.addProperties({editorExit: 
                function () {
                    var param = {"_this": this, "editCompletionEvent" : arguments[0], "record" : arguments[1], "newValue" : arguments[2], "rowNum" : arguments[3], "colNum" : arguments[4]};
                    var ret = editorExit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("editorExit", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("editorExit"));
            obj.editorExit = 
                function () {
                    var param = {"_this": this, "editCompletionEvent" : arguments[0], "record" : arguments[1], "newValue" : arguments[2], "rowNum" : arguments[3], "colNum" : arguments[4]};
                    var ret = editorExit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("editorExit", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownEditorExitEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.EditorExitEvent.getType()) == 0) tearDownEditorExitEvent();
    }

    private native void tearDownEditorExitEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("editorExit")) delete obj.editorExit;
    }-*/;

	/**
     * Complete the current edit by storing the value and hiding the inline editor. Note that if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits} is true, the value will be saved to the
     * server.
     * @see com.smartgwt.client.widgets.grid.ListGrid#startEditing
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void endEditing() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "endEditing", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.endEditing();
    }-*/;

	/**
     * Expands a given {@link com.smartgwt.client.widgets.grid.ListGridRecord record} by creating a subcomponent and inserting
     * it in to the record's grid-row.  A number of built-in {@link com.smartgwt.client.types.ExpansionMode expansionModes} are
     * supported by the default implementation of {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponent
     * getExpansionComponent()} and you can override that method to provide your own expansion behavior. <P> Once a record has
     * been expanded, the currently visible expansion component may be retrieved via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCurrentExpansionComponent getCurrentExpansionComponent()}.
     * @param record record to expand
     */
    public native void expandRecord(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "expandRecord", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.expandRecord(record.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Expands the passed list of {@link com.smartgwt.client.widgets.grid.ListGridRecord records} by creating a subcomponent
     * for each record and inserting them it in to the record's grid-row.  Calls {@link
     * com.smartgwt.client.widgets.grid.ListGrid#expandRecord expandRecord} for each passed record, but only marks the grid for
     * redraw once, after all expansions are complete.
     * @param records records to expand
     */
    public native void expandRecords(ListGridRecord... records) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "expandRecords", "ListGridRecord...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.expandRecords(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records));
    }-*/;

	/**
     * Exports this component's data with client-side formatters applied, so is suitable for direct  display to users, using
     * the specified {@link com.smartgwt.client.data.DSRequest#getExportAs export format}. <P> A variety of DSRequest settings,
     * such as {@link com.smartgwt.client.data.DSRequest#getExportAs exportAs} and  {@link
     * com.smartgwt.client.data.DSRequest#getExportFilename DSRequest.exportFilename}, affect the exporting process:  see
     * {@link com.smartgwt.client.data.DSRequest#getExportResults exportResults} for further detail. <P> This feature requires
     * the Smart GWT server. <P> If your ListGrid has custom formatters, formatted values will be exported by default, with 
     * HTML normalized to text where possible. Since some levels of HTML normalizing aren't possible,  this may result in
     * missing or incorrect export values. In this case, you have three options: <ul> <li>Set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues exportRawValues} on the field.  This will export    
     * the raw underlying value of the field; your formatter will not be called</li> <li>Have your formatter call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#isExportingClientData isExportingClientData()}     and perform whatever
     * alternative formatting you require if that method returns true</li> <li>Set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawNumbers exportRawNumbers} on the field.  This will export    
     * the raw underlying number of the field; your formatter will not be called</li> </ul> <P> Ordinarily, calls to this
     * method go through the static classMethod  {@link com.smartgwt.client.data.DataSource#exportClientData
     * DataSource.exportClientData()}.  In this case, no server-side DataSources are required.  However, if this component is 
     * {@link com.smartgwt.client.widgets.DataBoundComponent#setDataSource databound} and you specify a valid  {@link
     * com.smartgwt.client.data.DSRequest#getOperationId operationId} in the properties passed to this method, the call will go
     * through the instance method {@link com.smartgwt.client.data.DataSource#exportClientData DataSource.exportClientData()}
     * instead.  As the  documentation for that method explains, this allows you more control on the server side.   This
     * approach requires both the Smart GWT server and server-side DataSource definitions. <P> To export data from this
     * component's dataSource,  see {@link com.smartgwt.client.widgets.DataBoundComponent#exportData exportData}, which does
     * not include client-side  formatters, but <b>does</b> include formatters declared in the <code>.ds.xml</code> file.
     * <code>exportData()</code> relies on both the Smart GWT server and server-side DataSources.
     * @see com.smartgwt.client.data.DataSource#exportClientData
     */
    public native void exportClientData() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "exportClientData", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.exportClientData();
    }-*/;

    /**
     * @see ListGrid#exportClientData
     */
    public void exportClientData(DSRequest requestProperties){
        exportClientData(requestProperties, null);
    }

	/**
     * Exports this component's data with client-side formatters applied, so is suitable for direct  display to users, using
     * the specified {@link com.smartgwt.client.data.DSRequest#getExportAs export format}. <P> A variety of DSRequest settings,
     * such as {@link com.smartgwt.client.data.DSRequest#getExportAs exportAs} and  {@link
     * com.smartgwt.client.data.DSRequest#getExportFilename DSRequest.exportFilename}, affect the exporting process:  see
     * {@link com.smartgwt.client.data.DSRequest#getExportResults exportResults} for further detail. <P> This feature requires
     * the Smart GWT server. <P> If your ListGrid has custom formatters, formatted values will be exported by default, with 
     * HTML normalized to text where possible. Since some levels of HTML normalizing aren't possible,  this may result in
     * missing or incorrect export values. In this case, you have three options: <ul> <li>Set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawValues exportRawValues} on the field.  This will export    
     * the raw underlying value of the field; your formatter will not be called</li> <li>Have your formatter call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#isExportingClientData isExportingClientData()}     and perform whatever
     * alternative formatting you require if that method returns true</li> <li>Set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getExportRawNumbers exportRawNumbers} on the field.  This will export    
     * the raw underlying number of the field; your formatter will not be called</li> </ul> <P> Ordinarily, calls to this
     * method go through the static classMethod  {@link com.smartgwt.client.data.DataSource#exportClientData
     * DataSource.exportClientData()}.  In this case, no server-side DataSources are required.  However, if this component is 
     * {@link com.smartgwt.client.widgets.DataBoundComponent#setDataSource databound} and you specify a valid  {@link
     * com.smartgwt.client.data.DSRequest#getOperationId operationId} in the properties passed to this method, the call will go
     * through the instance method {@link com.smartgwt.client.data.DataSource#exportClientData DataSource.exportClientData()}
     * instead.  As the  documentation for that method explains, this allows you more control on the server side.   This
     * approach requires both the Smart GWT server and server-side DataSource definitions. <P> To export data from this
     * component's dataSource,  see {@link com.smartgwt.client.widgets.DataBoundComponent#exportData exportData}, which does
     * not include client-side  formatters, but <b>does</b> include formatters declared in the <code>.ds.xml</code> file.
     * <code>exportData()</code> relies on both the Smart GWT server and server-side DataSources.
     * @param requestProperties Request properties for the export.  Note that specifying {@link com.smartgwt.client.data.DSRequest#getExportData
     * exportData} on the request properties  allows the developer to pass in an explicit data set to export.
     * @param callback Optional callback.  If  you specify {@link com.smartgwt.client.data.DSRequest#getExportToClient exportToClient}: false
     * in the request  properties, this callback will fire after export completes.  Otherwise the callback will  fire right
     * before the download request is made to the server.
     * @see com.smartgwt.client.data.DataSource#exportClientData
     */
    public native void exportClientData(DSRequest requestProperties, RPCCallback callback) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "exportClientData", "DSRequest,RPCCallback");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.exportClientData(requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()(), 
			$entry( function(response, rawData, request) { 
				if(callback!=null) callback.@com.smartgwt.client.rpc.RPCCallback::execute(Lcom/smartgwt/client/rpc/RPCResponse;Ljava/lang/Object;Lcom/smartgwt/client/rpc/RPCRequest;)(
					@com.smartgwt.client.rpc.RPCResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(response), 
					rawData, 
					@com.smartgwt.client.rpc.RPCRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(request)
				);
			}));
    }-*/;
	
	/**
     * Based on the relationship between the DataSource this component is bound to and the DataSource specified as the "schema"
     * argument, call fetchData() to retrieve records in this grid that are related to the passed-in record. <P> Relationships
     * between DataSources are declared via {@link com.smartgwt.client.data.DataSourceField#getForeignKey
     * DataSourceField.foreignKey}. <P> For example, given two related DataSources "orders" and "orderItems", where we want to
     * fetch the "orderItems" that belong to a given "order".  "orderItems" should declare a field that is a {@link
     * com.smartgwt.client.data.DataSourceField#getForeignKey foreignKey} to the "orders" table (for example, it might be named
     * "orderId" with foreignKey="orders.id").  Then, to load the records related to a given "order", call fetchRelatedData()
     * on the component bound to "orderItems", pass the "orders" DataSource as the "schema" and pass a record from the "orders"
     * DataSource as the "record" argument. <P> Note that multiple foreign keys into the schema are supported by this method.
     * @param record DataSource record
     * @param schema schema of the DataSource record, or                            DataBoundComponent already bound to that schema
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void fetchRelatedData(ListGridRecord record, Canvas schema) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fetchRelatedData", "ListGridRecord,Canvas");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.fetchRelatedData(record.@com.smartgwt.client.core.DataClass::getJsObj()(), schema == null ? null : schema.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()());
    }-*/;

    /**
     * @see ListGrid#fetchRelatedData
     */
    public void fetchRelatedData(ListGridRecord record, Canvas schema, DSCallback callback){
        fetchRelatedData(record, schema, callback, null);
    }

	/**
     * Based on the relationship between the DataSource this component is bound to and the DataSource specified as the "schema"
     * argument, call fetchData() to retrieve records in this grid that are related to the passed-in record. <P> Relationships
     * between DataSources are declared via {@link com.smartgwt.client.data.DataSourceField#getForeignKey
     * DataSourceField.foreignKey}. <P> For example, given two related DataSources "orders" and "orderItems", where we want to
     * fetch the "orderItems" that belong to a given "order".  "orderItems" should declare a field that is a {@link
     * com.smartgwt.client.data.DataSourceField#getForeignKey foreignKey} to the "orders" table (for example, it might be named
     * "orderId" with foreignKey="orders.id").  Then, to load the records related to a given "order", call fetchRelatedData()
     * on the component bound to "orderItems", pass the "orders" DataSource as the "schema" and pass a record from the "orders"
     * DataSource as the "record" argument. <P> Note that multiple foreign keys into the schema are supported by this method.
     * @param record DataSource record
     * @param schema schema of the DataSource record, or                            DataBoundComponent already bound to that schema
     * @param callback callback to invoke on completion
     * @param requestProperties additional properties to set on the DSRequest                                            that will be issued
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void fetchRelatedData(ListGridRecord record, Canvas schema, DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fetchRelatedData", "ListGridRecord,Canvas,DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.fetchRelatedData(record.@com.smartgwt.client.core.DataClass::getJsObj()(), schema == null ? null : schema.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), 
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Can the field be edited?  This method looks at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} for
     * the grid as well as the {@link com.smartgwt.client.widgets.grid.ListGridField#getCanEdit ListGridField.canEdit} value,
     * to determine whether editing is allowed. This method's return value is not authoritative for editibility since {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} could return a more specific value. <p> For a
     * detailed discussion, see the documentation at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit}.
     * @param field field object, number, or name
     *
     * @return whether field can be edited
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native boolean fieldIsEditable(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fieldIsEditable", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.fieldIsEditable(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret == null ? false : ret;
    }-*/;

	/**
     * Can the field be edited?  This method looks at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} for
     * the grid as well as the {@link com.smartgwt.client.widgets.grid.ListGridField#getCanEdit ListGridField.canEdit} value,
     * to determine whether editing is allowed. This method's return value is not authoritative for editibility since {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} could return a more specific value. <p> For a
     * detailed discussion, see the documentation at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit}.
     * @param field field object, number, or name
     *
     * @return whether field can be edited
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native boolean fieldIsEditable(int field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fieldIsEditable", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.fieldIsEditable(field);
        return ret == null ? false : ret;
    }-*/;

	/**
     * Can the field be edited?  This method looks at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit} for
     * the grid as well as the {@link com.smartgwt.client.widgets.grid.ListGridField#getCanEdit ListGridField.canEdit} value,
     * to determine whether editing is allowed. This method's return value is not authoritative for editibility since {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canEditCell canEditCell()} could return a more specific value. <p> For a
     * detailed discussion, see the documentation at {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit canEdit}.
     * @param field field object, number, or name
     *
     * @return whether field can be edited
     * @see com.smartgwt.client.docs.FieldName FieldName
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native boolean fieldIsEditable(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fieldIsEditable", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.fieldIsEditable(field);
        return ret == null ? false : ret;
    }-*/;

	/**
     * Check whether a field is currently visible
     * @param field field to be checked
     *
     * @return true if the field is currently visible, false otherwise.
     */
    public native boolean fieldIsVisible(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "fieldIsVisible", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.fieldIsVisible(field);
        return ret == null ? false : ret;
    }-*/;

    /**
     * Add a fieldStateChanged handler.
     * <p>
     * Notification method executed when columns are resized or reordered, or fields are shown or hidden. frozen or unfrozen. 
     * Has no default implementation.
     *
     * @param handler the fieldStateChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addFieldStateChangedHandler(com.smartgwt.client.widgets.grid.events.FieldStateChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.FieldStateChangedEvent.getType()) == 0) setupFieldStateChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.FieldStateChangedEvent.getType());
    }

    private native void setupFieldStateChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var fieldStateChanged = $entry(function(){
            var param = {"_this": this};
            var event = @com.smartgwt.client.widgets.grid.events.FieldStateChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownFieldStateChangedEvent()();
            if (hasDefaultHandler) this.Super("fieldStateChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("fieldStateChanged"));
            obj.addProperties({fieldStateChanged:  fieldStateChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("fieldStateChanged"));
            obj.fieldStateChanged =  fieldStateChanged             ;
        }
    }-*/;

    private void handleTearDownFieldStateChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.FieldStateChangedEvent.getType()) == 0) tearDownFieldStateChangedEvent();
    }

    private native void tearDownFieldStateChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("fieldStateChanged")) delete obj.fieldStateChanged;
    }-*/;

	/**
     * If the filter editor ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor}) is visible
     * for this grid, this method will perform a filter based on the current values in the editor.
     */
    public native void filterByEditor() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "filterByEditor", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.filterByEditor();
    }-*/;

    /**
     * Add a filterEditorSubmit handler.
     * <p>
     * Optional notification fired when the user performs a filter using the
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor Filter Editor}.  May fire as criteria values are
     * being edited if 
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterOnKeypress ListGrid.filterOnKeypress} is true, otherwise will
     * fire when the user clicks the filter
     *  button or presses the Enter key while focus is in the Filter Editor.
     *  <p>
     *  Use event.cancel()
     *  
     *  to cancel the default behavior - you <b>must</b> cancel the default behavior if your
     * code is going to call {@link com.smartgwt.client.widgets.grid.ListGrid#filterData ListGrid.filterData()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCriteria ListGrid.setCriteria()} or any other API that
     *  affects the criteria applied to the grid.
     *  <P>
     *  The <code>criteria</code> parameter contains the current criteria applied to the
     *  grid including edits the user has just made using the Filter Editor.  This matches
     * what is returned if you call {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditorCriteria
     * ListGrid.getFilterEditorCriteria()}.
     *  <P>
     *  If you wish to access the <code>criteria</code> applied to the grid without picking
     * up any edits to the Filter Editor, use {@link com.smartgwt.client.widgets.grid.ListGrid#getCriteria
     * ListGrid.getCriteria()} instead.
     *  <P>
     *  Developers may wish to perform a filter using the Filter Editor values from code
     *  running outside the standard filterEditorSubmit flow.  For example, if you wanted a
     *  confirmation dialog to be shown before filtering was performed, you would cancel the
     *  default behavior as described above, but then need to replicate the default behavior
     *  once the user confirms that they want to proceed.  To replicate the default behavior, 
     *  just call:
     *  <pre>
     *   grid.filterData(grid.getFilterEditorCriteria());
     *  </pre>
     * or, to ensure the specified {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle
     * ListGrid.autoFetchTextMatchStyle} is picked up
     *  
     *  
     *  <pre>
     *   DSRequest request = new DSRequest();
     *   request.setTextMatchStyle(grid.getAutoFetchTextMatchStyle());
     *   grid.filterData(grid.getFilterEditorCriteria(), null,
     *        request);
     *  </pre>
     *  
     * 
     * 
     *
     * @param handler the filterEditorSubmit handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addFilterEditorSubmitHandler(com.smartgwt.client.widgets.grid.events.FilterEditorSubmitHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.FilterEditorSubmitEvent.getType()) == 0) setupFilterEditorSubmitEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.FilterEditorSubmitEvent.getType());
    }

    private native void setupFilterEditorSubmitEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var filterEditorSubmit = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.FilterEditorSubmitEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownFilterEditorSubmitEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("filterEditorSubmit"));
            obj.addProperties({filterEditorSubmit: 
                function () {
                    var param = {"_this": this, "criteria" : arguments[0]};
                    var ret = filterEditorSubmit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("filterEditorSubmit", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("filterEditorSubmit"));
            obj.filterEditorSubmit = 
                function () {
                    var param = {"_this": this, "criteria" : arguments[0]};
                    var ret = filterEditorSubmit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("filterEditorSubmit", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownFilterEditorSubmitEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.FilterEditorSubmitEvent.getType()) == 0) tearDownFilterEditorSubmitEvent();
    }

    private native void tearDownFilterEditorSubmitEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("filterEditorSubmit")) delete obj.filterEditorSubmit;
    }-*/;

	/**
     * Puts keyboard focus into the specified cell, showing a highlighted (roll-over style) appearance, and ensuring that
     * arrow-key navigation will start from the specified cell. <P> Only applies where {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true.
     * @param row Index of target row
     * @param col Index of target col
     * @see com.smartgwt.client.widgets.grid.ListGrid#focusInRow
     */
    public native void focusInCell(Integer row, Integer col) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "focusInCell", "Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.focusInCell(row == null ? null : row.@java.lang.Integer::intValue()(), col == null ? null : col.@java.lang.Integer::intValue()());
    }-*/;

	/**
     * If the filter editor ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor}) is visible
     * for this grid, this method will explicitly put focus into the specified field in the filter editor.
     */
    public native void focusInFilterEditor() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "focusInFilterEditor", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.focusInFilterEditor();
    }-*/;

	/**
     * If the filter editor ({@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor}) is visible
     * for this grid, this method will explicitly put focus into the specified field in the filter editor.
     * @param fieldName Name of the field to put focus into. If unspecified focus will go                             to the first field in the
     * editor
     */
    public native void focusInFilterEditor(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "focusInFilterEditor", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.focusInFilterEditor(fieldName);
    }-*/;
	
	/**
     * Puts keyboard focus into the specified row, showing a highlighted (roll-over style) appearance, and ensuring that
     * arrow-key navigation will start from the specified row. <P> Only applies where {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is false.
     * @param row Index of target row
     * @see com.smartgwt.client.widgets.grid.ListGrid#focusInCell
     */
    public native void focusInRow(Integer row) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "focusInRow", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.focusInRow(row == null ? null : row.@java.lang.Integer::intValue()());
    }-*/;

    /**
     * Add a formulaUpdated handler.
     * <p>
     * Notification fired when a user either creates a new formula field or edits an existing formula field.
     *
     * @param handler the formulaUpdated handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addFormulaUpdatedHandler(com.smartgwt.client.widgets.events.FormulaUpdatedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.events.FormulaUpdated.getType()) == 0) setupFormulaUpdatedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.events.FormulaUpdated.getType());
    }

    private native void setupFormulaUpdatedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var formulaUpdated = $entry(function(){
            var param = {"_this": this, "field" : arguments[0], "formula" : arguments[1]};
            var event = @com.smartgwt.client.widgets.events.FormulaUpdated::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownFormulaUpdatedEvent()();
            if (hasDefaultHandler) this.Super("formulaUpdated", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("formulaUpdated"));
            obj.addProperties({formulaUpdated:  formulaUpdated              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("formulaUpdated"));
            obj.formulaUpdated =  formulaUpdated             ;
        }
    }-*/;

    private void handleTearDownFormulaUpdatedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.events.FormulaUpdated.getType()) == 0) tearDownFormulaUpdatedEvent();
    }

    private native void tearDownFormulaUpdatedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("formulaUpdated")) delete obj.formulaUpdated;
    }-*/;

	/**
     * Freeze the indicated field, so that it remains in place and visible when horizontal scrolling occurs.
     * @param field field or fields to freeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void freezeField(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "freezeField", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Freeze the indicated field, so that it remains in place and visible when horizontal scrolling occurs.
     * @param field field or fields to freeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void freezeField(Integer field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "freezeField", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(field == null ? null : field.@java.lang.Integer::intValue()());
    }-*/;

	/**
     * Freeze the indicated field, so that it remains in place and visible when horizontal scrolling occurs.
     * @param field field or fields to freeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void freezeField(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "freezeField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(field);
    }-*/;

	/**
     * Freeze the indicated field, so that it remains in place and visible when horizontal scrolling occurs.
     * @param field field or fields to freeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void freezeField(String[] field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "freezeField", "String[]");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(field);
    }-*/;

	/**
     * Returns an array of every rowNum for which we have pending (unsubmitted) edits. This will return records that have been
     * marked as removed (see {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} as well
     * as records with unsaved changes to field values.
     *
     * @return Array of rowNums for rows with edit values pending submission.
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native int[] getAllEditRows() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getAllEditRows", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getAllEditRows();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfint(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Get the complete array of fields for this ListGrid, including fields that are not currently visible or were specified
     * implicitly via {@link com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}. <P> This list of fields is
     * only valid once the ListGrid has been {@link com.smartgwt.client.widgets.Canvas#draw drawn} or once {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFields setFields()} has been called explicitly.  If called earlier, only
     * the list of directly specified fields will be returned (the Array passed to create()). <P> This Array should be treated
     * as <b>read-only</b>.  To modify the set of visible fields, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#showField showField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} and related APIs.  To update properties of individual
     * fields, use {@link com.smartgwt.client.widgets.grid.ListGrid#setFieldProperties setFieldProperties()} or more specific
     * APIs such as {@link com.smartgwt.client.widgets.grid.ListGrid#setFieldTitle setFieldTitle()}.
     *
     * @return Array of all fields in the ListGrid
     */
    public native ListGridField[] getAllFields() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getAllFields", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getAllFields();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridField(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Return the base styleName for this cell.  Has the following implementation by default: <ul> <li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditFailedBaseStyle this.editFailedBaseStyle} is defined, and the     cell
     * is displaying a validation error return this value.</li> <li>If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditPendingBaseStyle this.editFailedPendingStyle} is defined, and     the
     * cell is displaying an edit value that has not yet been saved (see     {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAutoSaveEdits autoSaveEdits}) return this value.</li> <li>Otherwise return
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordBaseStyleProperty record[listGrid.recordBaseStyleProperty]},  
     * if defined, otherwise {@link com.smartgwt.client.widgets.grid.ListGridField#getBaseStyle field.baseStyle}.</li> </ul> If
     * no custom style is found for the cell as described above, the default baseStyle will be returned. If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle baseStyle} is specified this will be used. Otherwise for grids
     * showing fixed height rows which match {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalCellHeight
     * normalCellHeight} {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle} will be used. For
     * grids with variable, or modified cell heights, {@link com.smartgwt.client.widgets.grid.ListGrid#getTallBaseStyle
     * tallBaseStyle} will be used. <P> Note also that enabling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFastCellUpdates fastCellUpdates} will cause the <code>tallBaseStyle</code>
     * to be used rather than {@link com.smartgwt.client.widgets.grid.ListGrid#getNormalBaseStyle normalBaseStyle}. <P> As
     * noted under {@link com.smartgwt.client.widgets.grid.ListGrid#getEnforceVClipping enforceVClipping}, cell content which
     * renders taller than the available space within a cell may cause rows to expand even if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}  is true. This can lead to
     * misaligned rows when frozen columns are used. Developers should be aware that changing cell styling such that there is
     * increased borders or padding will reduce the available space for content within the specified cell height, making this
     * scenario more common. To fix this, specify a larger cellHeight, or set enforceVClipping to true. <p> <b>Note: This is an
     * override point.</b>
     * @param record Record associated with this cell. May be <code>null</code>                                  for a new edit row at the
     * end of this grid's data set.
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     *
     * @return CSS class for this cell.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCellStyle
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_hilite_replace" target="examples">Hilite cells (replace style) Example</a>
     */
    protected native String getBaseStyle(ListGridRecord record, int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getBaseStyle", "ListGridRecord,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getBaseStyle(record != null ? record.@com.smartgwt.client.core.DataClass::getJsObj()() : null, rowNum, colNum);
        return ret;
    }-*/;

	/**
     * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides.
     * <p> "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE
     * attribute of an HTML element. <p> <b>Note: This is an override point.</b>
     * @param record cell record as returned by getCellRecord
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     *
     * @return CSS text for this cell
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCellStyle
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_hilite_add" target="examples">Hilite cells (add style) Example</a>
     */
    protected native String getCellCSSText(ListGridRecord record, int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellCSSText", "ListGridRecord,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(record==null) { return null;}
        var ret = self.__getCellCSSText(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum, colNum);
        return ret;
    }-*/;

	/**
     * Returns the current set of errors for this cell.
     * @param rowNum index of row to check for validation errors.
     * @param fieldName field to check for validation errors - can be fieldName                                          or index of the column.
     *
     * @return array of error messages (strings) for the specified cell. If no validation                  errors are present, returns
     * null.
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native String[] getCellErrors(int rowNum, String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellErrors", "int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCellErrors(rowNum, fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfString(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHoverComponents showHoverComponents} is set, this method is
     * called to get the component to show as a hover for the current cell. <P> By default, this method returns one of a set of
     * builtin components, according to the value of {@link com.smartgwt.client.types.HoverMode listGrid.hoverMode}.  You can
     * override this method to return any component you wish to provide as a hoverComponent, or invoke the superclass method to
     * have the default hover component generated, then further customize it. <P> By default, components returned by
     * <code>getCellHoverComponent()</code> will be automatically destroyed when the hover is hidden.  To prevent this, set
     * {@link com.smartgwt.client.widgets.Canvas#getHoverAutoDestroy Canvas.hoverAutoDestroy} to false on the returned
     * component. <P> If you return a component that fetches data or loads content dynamically: <ol> <li> set
     * rpcRequest.promptStyle to "cursor" or set rpcRequest.showPrompt to false on any       network requests, or the default
     * masking that blocks the screen during network requests       will dismiss the hover</li> <li> as covered above, your
     * component may have been automatically destroyed by the time your       content has been loaded.  Check {@link
     * com.smartgwt.client.widgets.Canvas#getDestroyed Canvas.destroyed} before taking action in an       asynchronous callback
     * </li> <li> if your component grows in size after data is loaded, and it would then be rendered      partially
     * off-screen, it will be automatically re-positioned to keep it on-screen.        However this will not automatically
     * happen in cases where you provide HTML content that      changes size after initial render, in which case a call to     
     * {@link com.smartgwt.client.widgets.Canvas#adjustForContent Canvas.adjustForContent()} will be required.  See that API
     * for details. </li> </ol>
     * @param record record to get the hoverComponent for
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     *
     * @return the component to show as a hover
     */
    protected native Canvas getCellHoverComponent(Record record, Integer rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellHoverComponent", "Record,Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getCellHoverComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns the page offsets and size of the cell at the passed row and column.  If auto-sizing is enabled, sizes are not
     * definitive until the grid has finished drawing, so calling this method before drawing completes will return the
     * configured column sizes.
     * @param rowNum row index of the cell
     * @param colNum column index of the cell
     *
     * @return the page rect of the passed cell, or null if undrawn
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native Integer[] getCellPageRect(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellPageRect", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCellPageRect(rowNum, colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfInteger(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getRowSpan row spanning}, returns the number of cells
     * spanned by the cell at the given coordinates. <P> If the passed coordinates are in the middle of a series of spanned
     * cells, the row span of the spanning cell is returned.  For example, if row 2 col 0 spans 3 cells, calls to
     * <code>getCellRowSpan()</code> for row 2 col 0, row 3 col 0, row 4 col 0 will all return 3. <P> This method returns row
     * span information for the current rendered cells.  In contrast, if the grid is about to be redrawn, a call to
     * <code>getRowSpan()</code> may return row span values for how the grid is about to be drawn.  Also, user-provided
     * getRowSpan() functions are not required to operate properly when called outside of the grid rendering loop. <P>
     * <b>Note:</b> This method is a utility method for developers - it is not called directly by the grid rendering path and
     * therefore is not intended for override. To set up custom row-spanning behavior, override {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowSpan getRowSpan()} instead.
     * @param rowNum row number of cell to return the row span for
     * @param colNum column number of cell to return the row span for
     *
     * @return number of cells spanned by the cell that spans through these coordinates
     */
    public native int getCellRowSpan(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellRowSpan", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCellRowSpan(rowNum, colNum);
        return ret;
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is active, returns the {@link
     * com.smartgwt.client.widgets.grid.CellSelection} object that tracks and manages the current selection.  Returns null if
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is false.
     *
     * @return current cellSelection
     */
    public native CellSelection getCellSelection() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellSelection", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCellSelection();
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.CellSelection::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * When using {@link com.smartgwt.client.widgets.grid.ListGrid#getRowSpan row spanning}, returns the row number where a
     * row-spanning cell starts. <P> For example, if row 2 col 0 spans 3 cells, <code>getCellStartRow()</code> for row 2 col 0,
     * row 3 col 0, row 4 col 0 will all return 2, because that's the row when spanning starts.
     * @param rowNum row number of cell for which the start row should be returned
     * @param colNum column number of cell for which the start row should be returned
     *
     * @return row number where spanning starts
     */
    public native int getCellStartRow(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellStartRow", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCellStartRow(rowNum, colNum);
        return ret;
    }-*/;

	/**
     * Return the CSS class for a cell. By default this method has the following implementation:<br> - return any custom style
     * for the record ({@link com.smartgwt.client.widgets.grid.GridRenderer#getRecordCustomStyleProperty
     * GridRenderer.recordCustomStyleProperty})    if defined.<br> - create a style name based on the result of {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getBaseStyle GridRenderer.getBaseStyle()} and the    state of the record
     * using the rules described in {@link com.smartgwt.client.docs.CellStyleSuffixes}. <p> Cell Styles are customizable by:
     * <ul> <li>attaching a custom style to a record by setting     <code>record[this.recordCustomStyleProperty]</code> to some
     * valid CSS style name.   <li>modifying the base style returned by getBaseStyle() [see that method for further     
     * documentation on this] <li>overriding this function </ul> <p> In addition to this, {@link
     * com.smartgwt.client.widgets.grid.GridRenderer#getCellCSSText getCellCSSText()} may be overriden to provide custom
     * cssText to apply on top of the styling attributes derived from the named style. <p> <b>Note: This is an override
     * point.</b>
     * @param record record object for this row and column
     * @param rowNum number of the row
     * @param colNum number of the column
     *
     * @return CSS style for this cell.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getBaseStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    protected native String getCellStyle(ListGridRecord record, int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCellStyle", "ListGridRecord,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(record==null) { return null;}
        var ret = self.__getCellStyle(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum, colNum);
        return ret;
    }-*/;

	/**
     * Return the left offset (in local coordinate space) of a particular column.
     * @param colNum number of the column
     *
     * @return left offset of the passed colNum, or null if not yet drawn or no such column
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native Integer getColumnLeft(Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getColumnLeft", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getColumnLeft(colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * Return the left coordinate for a given column number as a GLOBAL coordinate
     * @param colNum number of the column
     *
     * @return page left offset of the passed colNum, or null if undrawn or no such column
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native Integer getColumnPageLeft(Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getColumnPageLeft", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getColumnPageLeft(colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * Return the width of a particular column.
     * @param colNum number of the column
     *
     * @return width of the column, or <code>null</code> if undrawn or no such column.
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native Integer getColumnWidth(int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getColumnWidth", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getColumnWidth(colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * Returns the expansion component derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponent
     * getExpansionComponent()} currently visible in some record, or null if the specified record is not showing an expansion
     * component.
     * @param record rowNum or record to get the expansionComponent for
     *
     * @return the currently visible expansion component for the expanded row.
     */
    public native Canvas getCurrentExpansionComponent(Integer record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCurrentExpansionComponent", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCurrentExpansionComponent(record == null ? null : record.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns the expansion component derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponent
     * getExpansionComponent()} currently visible in some record, or null if the specified record is not showing an expansion
     * component.
     * @param record rowNum or record to get the expansionComponent for
     *
     * @return the currently visible expansion component for the expanded row.
     */
    public native Canvas getCurrentExpansionComponent(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCurrentExpansionComponent", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCurrentExpansionComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns an array of widths of the visible fields in this <code>ListGrid</code>, in px.  This method is implemented by
     * calling {@link com.smartgwt.client.widgets.grid.ListGrid#getFieldWidth getFieldWidth()} for each field. If field widths
     * cannot be determined, the returned array will contain nulls.
     *
     * @return field widths in px
     */
    public native Integer[] getCurrentFieldWidths() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCurrentFieldWidths", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCurrentFieldWidths();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfInteger(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    	
	/**
     * Method to calculate and return the default width of a field. This method is called to calculate the size of each field's
     * content as part of the {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFitFieldWidths field auto fit} behavior.
     * Note that this method returns a size for <i>content</i>, so will not be consulted if {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidthApproach autoFitWidthApproach} is set  to
     * <code>"title"</code>. <P> If {@link com.smartgwt.client.widgets.grid.ListGridField#getDefaultWidth
     * ListGridField.defaultWidth} is specified, this will be returned. <P> Otherwise, the default implementation varies by
     * {@link com.smartgwt.client.types.ListGridFieldType field type}. For fields of type <code>"icon"</code>, or fields which
     * show only a {@link com.smartgwt.client.widgets.grid.ListGridField#getValueIcons valueIcon} as a value, and for boolean
     * fields which show a checkbox value, the width will be calculated based on the icon size and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getIconPadding iconPadding}. For other fields the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFieldContentWidth getFieldContentWidth()} method will be used to calculate
     * a width based on the rendered width of content. Note that for <code>"image"</code> type fields, this method will rely on
     * the {@link com.smartgwt.client.widgets.grid.ListGridField#getImageWidth ListGridField.imageWidth} being specified. <P>
     * Note that this width is the default width of "content" - it does not take into account the rendered size of the field
     * title.
     * @param DefaultFieldWidthCustomizer customizer
     */
    public native void setDefaultFieldWidthCustomizer(DefaultFieldWidthCustomizer customizer) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setDefaultFieldWidthCustomizer", "DefaultFieldWidthCustomizer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.getDefaultFieldWidth = $debox($entry(function(field) {
        	var returnValue = customizer.@com.smartgwt.client.widgets.grid.DefaultFieldWidthCustomizer::getWidth(Lcom/smartgwt/client/widgets/grid/ListGridField;)(
					@com.smartgwt.client.widgets.grid.ListGridField::new(Lcom/google/gwt/core/client/JavaScriptObject;)(field));
        	return $wnd.SmartGWT.convertToPrimitiveType(returnValue);
    	}));
    }-*/;

	/**
     * Get a field value for some record with default field formatters applied. <P> This method differs from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFormattedValue getDefaultFormattedValue()} in a couple of ways.
     * Firstly, this method does not rely on the rowNum and colNum parameters to find the record and field in the grid.<br>
     * Secondly, unlike {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFormattedValue getDefaultFormattedValue()}
     * this method <i>will</i> call any explicit cell formatter specified on the field passed in (though it will not call a
     * {@link com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter component level formatter} if one exists). <P> This is
     * useful for cases where a developer wishes to display a formatted value for some record and field combination which does
     * not necessarily map to a cell displayed in the ListGrid. <P> If <code>rowNum</code> and <code>colNum</code> parameters
     * are passed through to the field level cell formatter if one exists. If not explicitly provided these are defaulted to
     * -1.
     * @param record the record object
     * @param field the field object
     *
     * @return Default formatted value
     * @see com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter
     */
    public native String getDefaultFormattedFieldValue(Record record, ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getDefaultFormattedFieldValue", "Record,ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDefaultFormattedFieldValue(record.@com.smartgwt.client.core.DataClass::getJsObj()(), field.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

    /**
     * @see ListGrid#getDefaultFormattedFieldValue
     */
    public String getDefaultFormattedFieldValue(Record record, ListGridField field, int rowNum){
        return getDefaultFormattedFieldValue(record, field, rowNum, (Integer) null);
    }

	/**
     * Get a field value for some record with default field formatters applied. <P> This method differs from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDefaultFormattedValue getDefaultFormattedValue()} in a couple of ways.
     * Firstly, this method does not rely on the rowNum and colNum parameters to find the record and field in the grid.<br>
     * Secondly, unlike {@link com.smartgwt.client.widgets.grid.ListGrid#getDefaultFormattedValue getDefaultFormattedValue()}
     * this method <i>will</i> call any explicit cell formatter specified on the field passed in (though it will not call a
     * {@link com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter component level formatter} if one exists). <P> This is
     * useful for cases where a developer wishes to display a formatted value for some record and field combination which does
     * not necessarily map to a cell displayed in the ListGrid. <P> If <code>rowNum</code> and <code>colNum</code> parameters
     * are passed through to the field level cell formatter if one exists. If not explicitly provided these are defaulted to
     * -1.
     * @param record the record object
     * @param field the field object
     * @param rowNum rowNum (passed to any field level cell formatter)
     * @param colNum colNum (passed to any field level cell formatter)
     *
     * @return Default formatted value
     * @see com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter
     */
    public native String getDefaultFormattedFieldValue(Record record, ListGridField field, int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getDefaultFormattedFieldValue", "Record,ListGridField,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDefaultFormattedFieldValue(record.@com.smartgwt.client.core.DataClass::getJsObj()(), field.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum, colNum);
        return ret;
    }-*/;
	
	/**
     * Get the value for some cell with default formatters applied. <P> This method is useful for cases where a developer
     * wishes to conditionally customize a cell's formatting, but needs to see what the default formatted value would be. <P>
     * For example - a developer might wish to apply a custom {@link
     * com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter formatter} to some <code>link</code> type field, and be
     * able to return the default active link HTML in some cases. In this case a formatter could check for the conditions in
     * which custom formatting should be applied and run appropriate custom logic to generate a value for display - otherwise
     * return the result of this method to leave the standard formatted-value intact.
     * @param record the cell's record object
     * @param rowNum rowNum for the cell
     * @param colNum colNum for the cell
     *
     * @return Cell value with default formatters applied
     * @see com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter
     */
    public native String getDefaultFormattedValue(Record record, int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getDefaultFormattedValue", "Record,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDefaultFormattedValue(record.@com.smartgwt.client.core.DataClass::getJsObj()(), rowNum, colNum);
        return ret;
    }-*/;

	/**
     * Returns the extents of the rows and columns currently visible in this grid's viewport. <P> Note: if there are any {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getFrozen frozen fields}, they are not included in the draw area range
     * returned by this method. Frozen fields are assumed to never be scrolled out of view.  The column coordinates returned by
     * this method will only include unfrozen columns.
     *
     * @return The row/col co-ordinates currently visible in the viewport as    [startRow, endRow, startCol, endCol].
     */
    public native Integer[] getDrawArea() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getDrawArea", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDrawArea();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfInteger(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Get the drawn height of a row.
     * @param rowNum 
     *
     * @return height
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native int getDrawnRowHeight(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getDrawnRowHeight", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDrawnRowHeight(rowNum);
        return ret;
    }-*/;

	/**
     * Returns the index of the column being edited or  -1 if there is no current edit column.
     *
     * @return index of the current edit column
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native int getEditCol() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEditCol", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEditCol();
        if(ret == null){ret = -1;}
        return ret;
    }-*/;

	/**
     * Returns the current value of a cell. If the cell has an outstanding edit value, this will be returned, otherwise the
     * underlying value of the record will be returned.
     * @param record rowNum of the record being edited, or an Object                                      containing values for all the
     * record's primary keys
     * @param field colNum or fieldName of the cell
     *
     * @return Current edit value, or underlying value for the cell
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Object getEditedCell(int record, int field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEditedCell", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEditedCell(record, field);
        return $wnd.SmartGWT.convertToJavaType(ret);
    }-*/;

	/**
     * Returns the index of the row being edited or  -1 if there is no current edit row.
     *
     * @return index of the current edit row
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native int getEditRow() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEditRow", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEditRow();
        if(ret == null){ret = -1;}
        return ret;
    }-*/;

	/**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     * @param rowNum index of the row for which the editValue should be returned
     * @param colNum index of the field, or fieldName, for which value should be                              returned
     *
     * @return edit value for the field in question
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Object getEditValue(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEditValue", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEditValue(rowNum, colNum);
        return $wnd.SmartGWT.convertToJavaType(ret);
    }-*/;

	/**
     * Returns the column number of the most recent mouse event.
     *
     * @return column number, or -2 if beyond last drawn column
     */
    public native int getEventColumn() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEventColumn", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEventColumn();
        return ret;
    }-*/;

	/**
     * Returns the column number of the most recent mouse event.
     * @param x optional x-coordinate to obtain column number for, in lieu of the x                        coordinate of the last mouse
     * event
     *
     * @return column number, or -2 if beyond last drawn column
     */
    public native int getEventColumn(Integer x) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEventColumn", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEventColumn(x == null ? null : x.@java.lang.Integer::intValue()());
        return ret;
    }-*/;
	
	/**
     * Returns the row number of the most recent mouse event.
     *
     * @return row number, or -2 if beyond last drawn row
     */
    public native int getEventRow() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEventRow", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEventRow();
        return ret;
    }-*/;

	/**
     * Returns the row number of the most recent mouse event.
     * @param y optional y-coordinate to obtain row number, in lieu of the y                        coordinate of the last mouse event
     *
     * @return row number, or -2 if beyond last drawn row
     */
    public native int getEventRow(Integer y) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getEventRow", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getEventRow(y == null ? null : y.@java.lang.Integer::intValue()());
        return ret;
    }-*/;
	
	/**
     * Returns the list of {@link com.smartgwt.client.widgets.grid.ListGridRecord records} from this ListGrid that are {@link
     * com.smartgwt.client.widgets.grid.ListGrid#expandRecord expanded}
     *
     * @return All expanded records in the grid
     */
    public native ListGridRecord[] getExpandedRecords() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getExpandedRecords", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getExpandedRecords();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Gets the embedded-component to show as a given record's expansionComponent.  This component is then housed in {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionLayout a VLayout} and embedded into a record's row. <P> By
     * default, this method returns one of a set of built-in components, according to the value of {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode}.  You can override this method to return any component
     * you wish to provide as an expansionComponent. <P> As long as the record is expanded, this component may be retrieved via
     * a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getCurrentExpansionComponent getCurrentExpansionComponent()}.
     * <P> When an expanded record is collapsed, the component is disassociated from the record and may or may not be
     * automatically destroyed.  By default, built-in components will be destroyed on unembed according to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionComponentPoolingMode pooling mode} being used.  Custom expansion
     * components, created via an override of getExpansionComponents(), will <b><i>not</i></b> be auto-destroyed - developers
     * should override {@link com.smartgwt.client.widgets.grid.ListGrid#collapseRecord collapseRecord()} to take care of
     * clean-up for such components.
     * @param record record to get the expansionComponent for
     *
     * @return the component to embed
     */
    protected native Canvas getExpansionComponent(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getExpansionComponent", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getExpansionComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, background color
     * to use  for the cell at the given rowNum and colNum. <p> See {@link com.smartgwt.client.docs.ExportBGColor} for an
     * overview.
     * @param rowNum row number of cell
     * @param colNum column number of cell
     * @param record the record object behind the row being exported
     *
     * @return background color to use for the cell, or null to use the default                    background color.
     * See {@link com.smartgwt.client.docs.CSSColor CSSColor}
     */
    public native String getExportBGColor(int rowNum, int colNum, Record record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getExportBGColor", "int,int,Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getExportBGColor(rowNum, colNum, record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, background color
     * to use  for the given colNum. <p> See {@link com.smartgwt.client.docs.ExportBGColor} for an overview.
     * @param colNum column number
     *
     * @return background color to use for the column, or null to use the default                    background color.
     * See {@link com.smartgwt.client.docs.CSSColor CSSColor}
     */
    public native String getExportColumnBGColor(int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getExportColumnBGColor", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getExportColumnBGColor(colNum);
        return ret;
    }-*/;

	/**
     * When exporting data to Excel/OpenOffice format using {@link com.smartgwt.client.widgets.grid.ListGrid#exportData
     * exportData()} or {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exportClientData()}, background color
     * to use  for the given rowNum. <p> See {@link com.smartgwt.client.docs.ExportBGColor} for an overview.
     * @param rowNum row number
     * @param record the record object behind the row being exported
     *
     * @return background color to use for the row, or null to use the default                    background color.
     * See {@link com.smartgwt.client.docs.CSSColor CSSColor}
     */
    public native String getExportRowBGColor(int rowNum, Record record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getExportRowBGColor", "int,Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getExportRowBGColor(rowNum, record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * Given a column number or field name, return the field definition of a field which is visible in the grid.  To retrieve
     * the definition of <i>any</i> field, including hidden ones, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFieldByName getFieldByName()}. <P> When using {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getFields DataBinding}, the field definition may be a mix of information
     * derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}.
     * @param colNum number or name of the field
     *
     * @return field definition
     */
    public native ListGridField getField(int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getField", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getField(colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.ListGridField::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Given a column number or field name, return the field definition of a field which is visible in the grid.  To retrieve
     * the definition of <i>any</i> field, including hidden ones, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFieldByName getFieldByName()}. <P> When using {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getFields DataBinding}, the field definition may be a mix of information
     * derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDataSource dataSource}.
     * @param colNum number or name of the field
     *
     * @return field definition
     * @see com.smartgwt.client.docs.FieldName FieldName
     */
    public native ListGridField getField(String colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getField(colNum);
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.ListGridField::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Given a field name, return the appropriate field definition.  Unlike  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getField getField()}, this method will return the field definition even if
     * it's not visible in the grid.
     * @param fieldName name of the field to retrieve.
     * See {@link com.smartgwt.client.docs.FieldName FieldName}
     *
     * @return field definition
     * @see com.smartgwt.client.docs.FieldName FieldName
     */
    public native ListGridField getFieldByName(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldByName", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldByName(fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.ListGridField::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns the pixel width of the content of a visible field in this grid.
     * @param field field to test
     *
     * @return drawn width of this fields content
     */
    public native Integer getFieldContentWidth(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldContentWidth", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldContentWidth(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * Given a column number or field id, return the field name of a field.
     * @param colNum number or id of the field.
     *
     * @return Name of the field.
     */
    public native String getFieldName(int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldName", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldName(colNum);
        return ret;
    }-*/;

	/**
     * Given a field or field id, return it's index in the fields array
     * @param fieldID field number or field.name
     *
     * @return index of the field within this.fields
     */
    public native int getFieldNum(String fieldID) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldNum", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldNum(fieldID);
        return ret;
    }-*/;

	/**
     * Given a field or field id, return it's index in the fields array
     * @param fieldID field number or field.name
     *
     * @return index of the field within this.fields
     */
    public native int getFieldNum(int fieldID) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldNum", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldNum(fieldID);
        return ret;
    }-*/;

	/**
     * Return the title of a field, specified by name or index.
     * @param fieldId name or index of the field
     *
     * @return Field title.
     */
    public native String getFieldTitle(String fieldId) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldTitle", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldTitle(fieldId);
        return ret;
    }-*/;

	/**
     * Return the title of a field, specified by name or index.
     * @param fieldId name or index of the field
     *
     * @return Field title.
     */
    public native String getFieldTitle(int fieldId) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldTitle", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldTitle(fieldId);
        return ret;
    }-*/;

	/**
     * Returns a numeric value for the width of some field within this <code>ListGrid</code>.
     * @param fieldNum Index or name of the field for which the width is to be                                   determined.
     *
     * @return width of the field in px, or <code>null</code> if the width can't be                   determined.
     */
    public native Integer getFieldWidth(int fieldNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFieldWidth", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldWidth(fieldNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, this method will
     * return the criteria currently displayed in the <code>filterEditor</code>. Note that these values may differ from the
     * criteria returned by {@link com.smartgwt.client.widgets.grid.ListGrid#getCriteria getCriteria()} if the filter editor
     * values have been modified without performing an actual filter.
     *
     * @return criteria currently displayed in the filterEditor
     */
    public native Criteria getFilterEditorCriteria() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFilterEditorCriteria", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFilterEditorCriteria();
        if(ret == null) return null;
        return @com.smartgwt.client.data.Criteria::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, this method will
     * return the criteria currently displayed in the <code>filterEditor</code>. Note that these values may differ from the
     * criteria returned by {@link com.smartgwt.client.widgets.grid.ListGrid#getCriteria getCriteria()} if the filter editor
     * values have been modified without performing an actual filter.
     * @param omitHiddenFields By default this method will include criteria applied to   fields, including criteria that are not actually
     * visible/editable in the filterEditor for the   grid. Pass in this parameter to get only values for visible fields
     * returned.
     *
     * @return criteria currently displayed in the filterEditor
     */
    public native Criteria getFilterEditorCriteria(Boolean omitHiddenFields) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFilterEditorCriteria", "Boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFilterEditorCriteria(omitHiddenFields == null ? null : omitHiddenFields.@java.lang.Boolean::booleanValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.data.Criteria::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * Extracts and returns the criteria for the passed field from the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor filterEditor}.  The result can be an  {@link
     * com.smartgwt.client.data.AdvancedCriteria}, if the field in question produces more than one restriction, such as
     * separate <code>greaterThan</code> and <code>lessThan</code> criteria for a range.
     * @param fieldName name of the field to get the criteria for
     *
     * @return the passed field's filterEditor criterion
     */
    public native Criterion getFilterEditorCriterion(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFilterEditorCriterion", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFilterEditorCriterion(fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.data.Criterion::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Get the row that currently has keyboard focus.  Arrow key navigation moves relative to this row.
     *
     * @return rowNum of the current focus row
     */
    public native Integer getFocusRow() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFocusRow", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFocusRow();
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

	/**
     * For grids with frozen columns, this method is called to retrieve the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollOverCanvas frozenRollOverCanvas} when the user moves over a new
     * row or cell if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas showRollOverCanvas} is true, or
     * when the user moves over the selected record if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas showSelectedRollOverCanvas}  is true. <P> The
     * default implementation uses the {@link com.smartgwt.client.types.AutoChild} subystem to create the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollOverCanvas frozenRollOverCanvas} based on the
     * <code>rollOverCanvas</code> auto child settings.  It may be overridden for custom behavior. <P> Note that for efficiency
     * this should not typically create a new Canvas every time that it is called. Instead usually a single rollOver canvas
     * should be created and updated to reflect the current rollOver row if necessary. <p> Return null to avoid showing a
     * <code>rollOverCanvas</code> for this row. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas getRollOverCanvas()}. <p> <b>Note: This is an override
     * point.</b>
     * @param rowNum index of the current rollOver row.
     * @param colNum index of the current rollOver column. This parameter will be null unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is true for the grid.
     *
     * @return the embedded component
     */
    protected native Canvas getFrozenRollOverCanvas(Integer rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFrozenRollOverCanvas", "Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getFrozenRollOverCanvas(rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * For grids with frozen columns, this method is called to retrieve the  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollUnderCanvas frozenRollUnderCanvas} when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollUnderCanvas showing a rollUnder canvas} or showing a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollUnderCanvas rollUnder canvas for the selected record}. <P>
     * The default implementation uses the {@link com.smartgwt.client.types.AutoChild} subystem to create the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas} auto child. It may be overridden for
     * custom behavior. <P> Note that for efficiency this should not typically create a new Canvas every time that it is
     * called. Instead usually a single rollOver canvas should be created and updated to reflect the current rollOver row if
     * necessary. <p> Return null to avoid showing a <code>rollUnderCanvas</code> for frozen fields for this row. <P> See also
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas getRollUnderCanvas()}. <p> <b>Note: This is an
     * override point.</b>
     * @param rowNum index of the current rollOver row.
     * @param colNum index of the current rollOver column. This parameter will be null unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is true for the grid.
     *
     * @return the embedded component
     */
    protected native Canvas getFrozenRollUnderCanvas(Integer rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getFrozenRollUnderCanvas", "Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getFrozenRollUnderCanvas(rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is <code>true</code> this
     * method is called for each field which will show a grid summary value (as described in {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getShowGridSummary ListGridField.showGridSummary}) to get the summary
     * value to display below the relevant column. <P> The default implementation is as follows: <ul><li>If this is a databound
     * grid and not all data is loaded, returns null for every field</li>     <li>Otherwise if {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getGridSummary ListGridField.getGridSummary()} is defined, calls that
     * method passing         in the current data set for the grid</li>     <li>If {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getGridSummary ListGridField.getGridSummary()} is undefined, makes use of
     * the          {@link com.smartgwt.client.widgets.grid.ListGrid#getGridSummaryFunction standard summary function} for the
     * field to          calculate the summary based on the current data set</li> </ul> This method may return an array of
     * values. This implies that the grid summary should show multiple rows. Note that if a field has more than one
     * summaryFunction specified, this method will pick up values from each summary function and return them in an array,
     * meaning these summaries will show up on multiple rows in the grid. <P> This method may be overridden to completely
     * customize the summary value displayed for columns in this grid. An example use case would be when summary information is
     * available on the client and does not need to be calculated directly from the data. <P> <b>Note:</b> this method will not
     * be called if {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource} is
     * specified.
     * @param field field for which the summary value should be returned
     *
     * @return summary value to display for the specified field.
     */
    public native Object getGridSummary(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGridSummary", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getGridSummary(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        return $wnd.SmartGWT.convertToJavaType(ret);
    }-*/;

	/**
     * This method returns the data  displayed in the  {@link com.smartgwt.client.widgets.grid.ListGrid#getSummaryRow
     * summaryRow} when {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary showGridSummary} is true. <P> By
     * default this will call {@link com.smartgwt.client.widgets.grid.ListGrid#getGridSummary getGridSummary()} for each field
     * and generate an array of records containing the resulting values. <P> This method   may return multiple records if more
     * than one summary row is desired.
     *
     * @return summary record(s)
     */
    public native ListGridRecord[] getGridSummaryData() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGridSummaryData", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGridSummaryData();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns the true row index for a grouped record excluding group and summary records. Records in closed groups are
     * included in number. <p> Function is not applicable for non-grouped grids and will return -1 if called.
     * @param record record to number
     *
     * @return row index for record or -1 for group or summary records
     */
    public native int getGroupedRecordIndex(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupedRecordIndex", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGroupedRecordIndex(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this method will  return the 
     * group summary data displayed  at the end of the group. <P> This method may  return multiple records if more than one
     * summary row per group is desired.
     * @param records the records in the group, for which the summary values                                  are being calculated
     * @param groupNode object with specified groupValue and groupName for this group
     *
     * @return summary record(s)
     */
    public native ListGridRecord[] getGroupSummaryData(Record[] records, Record groupNode) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupSummaryData", "Record[],Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGroupSummaryData(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records), groupNode.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this method will  return the 
     * group summary data displayed  at the end of the group. <P> This method may  return multiple records if more than one
     * summary row per group is desired.
     * @param records the records in the group, for which the summary values                                  are being calculated
     * @param groupNode object with specified groupValue and groupName for this group
     * @param recalculate if set to false and the node has existing summary data,                                 returns the stored summary data,
     * rather than recalculating
     *
     * @return summary record(s)
     */
    public native ListGridRecord[] getGroupSummaryData(Record[] records, Record groupNode, Boolean recalculate) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupSummaryData", "Record[],Record,Boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGroupSummaryData(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records), groupNode.@com.smartgwt.client.core.DataClass::getJsObj()(), recalculate == null ? null : recalculate.@java.lang.Boolean::booleanValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * If this grid {@link com.smartgwt.client.widgets.grid.ListGrid#getIsGrouped is grouped}, this method will return the
     * current selection. Unlike the standard {@link com.smartgwt.client.widgets.grid.ListGrid#getSelection getSelection
     * method}, this method will return {@link com.smartgwt.client.widgets.grid.ListGrid#isGroupNode group nodes} in addition
     * to standard {@link com.smartgwt.client.widgets.grid.ListGridRecord}s within the grid's data.
     *
     * @return Selected group header nodes and record data objects.   If this grid is not grouped, standard {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelection listGrid selection}   will be returned.
     */
    public native ListGridRecord[] getGroupTreeSelection() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupTreeSelection", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGroupTreeSelection();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
     * @see ListGrid#getGroupTreeSelection
     */
    public ListGridRecord[] getGroupTreeSelection(boolean excludePartialSelection){
        return getGroupTreeSelection(excludePartialSelection, false);
    }

	/**
     * If this grid {@link com.smartgwt.client.widgets.grid.ListGrid#getIsGrouped is grouped}, this method will return the
     * current selection. Unlike the standard {@link com.smartgwt.client.widgets.grid.ListGrid#getSelection getSelection
     * method}, this method will return {@link com.smartgwt.client.widgets.grid.ListGrid#isGroupNode group nodes} in addition
     * to standard {@link com.smartgwt.client.widgets.grid.ListGridRecord}s within the grid's data.
     * @param excludePartialSelection By default a group header node is considered   selected if any members of the group are selected. If this flag is passed
     * in, only   header nodes where <b>all</b> members of the group are selected will be included   in the returned results.
     * @param groupNodesOnly If this parameter is passed as <code>true</code>,    this method will return just the group header nodes from the group
     * tree. If omitted   or false, both header nodes and data records will be returned.
     *
     * @return Selected group header nodes and record data objects.   If this grid is not grouped, standard {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelection listGrid selection}   will be returned.
     */
    public native ListGridRecord[] getGroupTreeSelection(boolean excludePartialSelection, boolean groupNodesOnly) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupTreeSelection", "boolean,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getGroupTreeSelection(excludePartialSelection, groupNodesOnly);
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu showHeaderContextMenu} is <code>true</code>
     * this method returns the menu items to be displayed in the default header context menu. <P> This method is called at
     * various times, including during redraws, as the mouse moves over a ListGrid header button and each time the menu is
     * actually displayed - this allows for  dynamic content depending on the current state of the grid and its fields. <P>
     * Consequently, this method should not instantiate any classes, because they'll be re-created on each call, resulting in a
     * leak - your implementation should return an array of menuItem  config-blocks only, so you shouldn't instantiate actual
     * Menu instances to apply as the  {@link com.smartgwt.client.widgets.menu.MenuItem#getSubmenu submenu} of items - instead,
     * set submenu to a simple array of menuItems.  If your use-case necessitates that class instances are created, because
     * specific submenus have a different Menu class, for example, you should keep a reference to them and  either, if their
     * content is dynamic, destroy and recreate them with the new items, or just return the existing instances otherwise.  <P>
     * The default set of menu items includes items for built-in ListGrid features like showing  and hiding fields, freezing
     * fields or grouping by them, and other functions.
     * @param fieldNum Index of the field the user clicked in the    {@link com.smartgwt.client.widgets.grid.ListGrid#getFields fields} array.
     * <b>Note:</b> if the user right-clicked the sorter button    this parameter will be <code>null</code>.
     *
     * @return 
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    protected native MenuItem[] getHeaderContextMenuItems(Integer fieldNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getHeaderContextMenuItems", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getHeaderContextMenuItems(fieldNum == null ? null : fieldNum.@java.lang.Integer::intValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfMenuItem(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * Return the menus items that should be shown in a menu triggered from a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpan}.
     * @param headerSpan the component representing the headerSpan.  This component will                            have all the properties
     * specified via {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpans}.
     *
     * @return return false instead to avoid showing a menu
     */
    protected native MenuItem[] getHeaderSpanContextMenuItems(HeaderSpan headerSpan) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getHeaderSpanContextMenuItems", "HeaderSpan");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getHeaderSpanContextMenuItems(headerSpan.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfMenuItem(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Return the pointer to a particular record by record number. Synonym for {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellRecord getCellRecord()}.
     * @param recordNum row index of record to return.
     *
     * @return Record object for the row.
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCellRecord
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditedRecord
     */
    public native ListGridRecord getRecord(int recordNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRecord", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRecord(recordNum);
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Retrieve the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponent} currently being
     * shown at the given coordinates. <p> <code>recordComponents</code> are dynamically assigned to row/cell coordinates and,
     * depending on the {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode
     * recordComponentPoolingMode}, any kind of redraw of the containing ListGrid (due to sort change, scrolling, editing etc)
     * may cause a <code>recordComponent</code> to be assigned to another row, {@link com.smartgwt.client.widgets.Canvas#clear
     * clear()ed} or permanently {@link com.smartgwt.client.widgets.Canvas#destroy destroy()ed}. <p> Hence you should always
     * call <code>getRecordComponent()</code> right before taking action on the <code>recordComponent</code> - don't cache the
     * component associated with row/cell coordinate.  Similarly, it's invalid to call <code>getRecordComponent()</code> during
     * a redraw (for example, from {@link com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter formatting} code).
     * <p> It's always invalid to try to use a <code>recordComponent</code> outside of a ListGrid (by eg adding it to some
     * other layout). <p> If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * showRecordComponentsByCell} is true and the colNum parameter is not passed, the call will return the first component in
     * the passed rowNum. <p> Returns null if there is no component at the specified coordinates.
     * @param rowNum row number to get record component for
     *
     * @return record component, or null if none is shown at these coordintes
     */
    public native Canvas getRecordComponent(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRecordComponent", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRecordComponent(rowNum);
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Retrieve the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponent} currently being
     * shown at the given coordinates. <p> <code>recordComponents</code> are dynamically assigned to row/cell coordinates and,
     * depending on the {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode
     * recordComponentPoolingMode}, any kind of redraw of the containing ListGrid (due to sort change, scrolling, editing etc)
     * may cause a <code>recordComponent</code> to be assigned to another row, {@link com.smartgwt.client.widgets.Canvas#clear
     * clear()ed} or permanently {@link com.smartgwt.client.widgets.Canvas#destroy destroy()ed}. <p> Hence you should always
     * call <code>getRecordComponent()</code> right before taking action on the <code>recordComponent</code> - don't cache the
     * component associated with row/cell coordinate.  Similarly, it's invalid to call <code>getRecordComponent()</code> during
     * a redraw (for example, from {@link com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter formatting} code).
     * <p> It's always invalid to try to use a <code>recordComponent</code> outside of a ListGrid (by eg adding it to some
     * other layout). <p> If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell
     * showRecordComponentsByCell} is true and the colNum parameter is not passed, the call will return the first component in
     * the passed rowNum. <p> Returns null if there is no component at the specified coordinates.
     * @param rowNum row number to get record component for
     * @param colNum optional column number to get the record component for
     *
     * @return record component, or null if none is shown at these coordintes
     */
    public native Canvas getRecordComponent(int rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRecordComponent", "int,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRecordComponent(rowNum, colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * Returns the {@link com.smartgwt.client.types.RecordDropPosition} for some record drop operation. This value is passed to
     * the {@link com.smartgwt.client.widgets.grid.ListGrid#recordDrop recordDrop()} event notification method. <P> Default
     * implementation determines the position to return based on the specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordDropAppearance recordDropAppearance} for the grid and the {@link
     * com.smartgwt.client.util.EventHandler#getY y-coordinate of the drop event}.
     *
     * @return record drop position.
     */
    public native RecordDropPosition getRecordDropPosition() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRecordDropPosition", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRecordDropPosition();
        if(ret == null) return null;
        var enumValues = @com.smartgwt.client.types.RecordDropPosition::values()();
        return @com.smartgwt.client.util.EnumUtil::getEnum([Lcom/smartgwt/client/types/ValueEnum;Ljava/lang/String;)(enumValues, ret);
    }-*/;

	/**
     * Get the index of the provided record. <P> This is essentially the same as calling listGrid.data.indexOf(record), except
     * that the currently visible range of records is checked first.  This is important for responsiveness in functions that
     * respond to user actions when the user is working near the end of a very large dataset (eg 500k records).
     * @param record the record whose index is to be retrieved
     *
     * @return index of the record, or -1 if not found
     */
    public native int getRecordIndex(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRecordIndex", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRecordIndex(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * Returns the {@link com.smartgwt.client.data.DataSource} containing data related to the passed record.  Used when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.types.ExpansionMode} is "related". The default implementation returns the DataSource specified in
     * {@link com.smartgwt.client.widgets.grid.ListGridRecord#getDetailDS ListGridRecord.detailDS} if set, otherwise {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getDetailDS detailDS}.
     * @param record The record to get the Related dataSource for.
     *
     * @return The related DataSource for the "record" param
     */
    public native DataSource getRelatedDataSource(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRelatedDataSource", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getRelatedDataSource(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.data.DataSource::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * This method is called to retrieve the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas}
     * when the user moves over a new row or cell if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRollOverCanvas
     * showRollOverCanvas} is true, or when the user moves over the selected record if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollOverCanvas showSelectedRollOverCanvas}  is true. <P> The
     * default implementation uses the {@link com.smartgwt.client.types.AutoChild} subystem to create the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollOverCanvas rollOverCanvas} auto child. It may be overridden for custom
     * behavior. <P> Note that for efficiency this should not typically create a new Canvas every time that it is called.
     * Instead usually a single rollOver canvas should be created and updated to reflect the current rollOver row if necessary.
     * <p> Return null to avoid showing a <code>rollOverCanvas</code> for this row. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollOverCanvas getFrozenRollOverCanvas()}. <p> <b>Note: This is an
     * override point.</b>
     * @param rowNum index of the current rollOver row.
     * @param colNum index of the current rollOver column. This parameter will be null unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is true for the grid.
     *
     * @return the embedded component
     */
    protected native Canvas getRollOverCanvas(Integer rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRollOverCanvas", "Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getRollOverCanvas(rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * This method is called to retrieve the {@link com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas
     * rollUnderCanvas} when the user moves over a new row or cell if  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRollUnderCanvas showing a rollUnder canvas} or showing a {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowSelectedRollUnderCanvas rollUnder canvas for the selected record}. <P>
     * The default implementation uses the {@link com.smartgwt.client.types.AutoChild} subystem to create the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRollUnderCanvas rollUnderCanvas} auto child. It may be overridden for
     * custom behavior. <P> Note that for efficiency this should not typically create a new Canvas every time that it is
     * called. Instead usually a single rollOver canvas should be created and updated to reflect the current rollOver row if
     * necessary. <p> Return null to avoid showing a <code>rollUnderCanvas</code> for this row. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFrozenRollUnderCanvas getFrozenRollUnderCanvas()}. <p> <b>Note: This is an
     * override point.</b>
     * @param rowNum index of the current rollOver row.
     * @param colNum index of the current rollOver column. This parameter will be null unless {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseCellRollOvers useCellRollOvers} is true for the grid.
     *
     * @return the embedded component
     */
    protected native Canvas getRollUnderCanvas(Integer rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRollUnderCanvas", "Integer,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getRollUnderCanvas(rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns any currently stored validation errors for this row in the following format:<br> 
     * &nbsp;&nbsp;<code>{fieldName:[array of error messages], ...}</code>
     * @param rowNum index of row to check for validation errors.
     *
     * @return object showing validation error arrays by field for the row passed in                      - if no validation errors
     * stored for the row, null is returned.
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCellErrors
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Map getRowErrors(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRowErrors", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRowErrors(rowNum);
        return @com.smartgwt.client.util.JSOHelper::convertToMap(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Return the height this row should be.  Default is this.cellHeight. If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights} is false, the row may be rendered
     * taller than this specified size. <P> If records will be variable height, you should switch on {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getVirtualScrolling virtualScrolling}. <P> Note if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getAllowRowSpanning row spanning} is enabled, this method should return the
     * height of a single row (with rowSpan set to 1).
     * @param record cell record as returned by getCellRecord
     * @param rowNum row number
     *
     * @return height in pixels
     */
    public native int getRowHeight(ListGridRecord record, int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRowHeight", "ListGridRecord,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__getRowHeight(record != null ? record.@com.smartgwt.client.core.DataClass::getJsObj()() : null, rowNum);
        return ret;
    }-*/;

	/**
     * Synonym of {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordIndex getRecordIndex()}.
     * @param record the record whose index is to be retrieved
     *
     * @return index of the record, or -1 if not found
     */
    public native int getRowNum(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRowNum", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRowNum(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * Returns the Y-coordinate for a given row number as a page-relative coordinate.  See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowTop getRowTop()}.
     * @param rowNum 
     *
     * @return Y-coordinate
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native int getRowPageTop(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRowPageTop", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRowPageTop(rowNum);
        return ret;
    }-*/;

	/**
     * Returns the top coordinate for a given row number, relative to the top of body content.  Use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowPageTop getRowPageTop()} for a page-relative coordinate. <P> This method
     * is reliable only for rows that are currently drawn, which is generally only rows that are visible in the viewport.  If
     * row heights vary (see <code>fixedRowHeights</code>), coordinates for rows that are not currently shown are rough
     * approximations.
     * @param rowNum 
     *
     * @return Y-coordinate
     * @see com.smartgwt.client.docs.Positioning Positioning overview and related methods
     */
    public native int getRowTop(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getRowTop", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getRowTop(rowNum);
        return ret;
    }-*/;

	/**
     * Returns the first selected record in this grid. <p> This method is appropriate if the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is  {@link
     * com.smartgwt.client.types.SelectionStyle#SINGLE}, or if you only care about the first selected record in a
     * multiple-record selection. To access all selected records, use {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSelection getSelection()} instead. <p> <strong>NOTE:</strong> If a record
     * is returned, it should be treated as read-only and not modified.
     *
     * @return the first selected record, or null if no record is selected.
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_remove" target="examples">Databound remove Example</a>
     */
    public native ListGridRecord getSelectedRecord() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSelectedRecord", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSelectedRecord();
        if(ret == null) return null;
        return @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns all selected records in this grid. <p> <strong>NOTE:</strong> Records in the returned array should be treated as
     * read-only and not modified.
     *
     * @return array of selected records, which will be empty if no record is selected.
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native ListGridRecord[] getSelectedRecords() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSelectedRecords", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSelectedRecords();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns all selected records in this grid. <p> <strong>NOTE:</strong> Records in the returned array should be treated as
     * read-only and not modified.
     * @param excludePartialSelections When true, partially selected records will not be returned.                                   Otherwise, both fully and
     * partially selected records are                                   returned.
     *
     * @return array of selected records, which will be empty if no record is selected.
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native ListGridRecord[] getSelectedRecords(boolean excludePartialSelections) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSelectedRecords", "boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSelectedRecords(excludePartialSelections);
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;
	
	/**
     * Returns the current {@link com.smartgwt.client.data.SortSpecifier SortSpecifiers} for this ListGrid. Will return null if
     * this grid has never been sorted (and has no specified {@link com.smartgwt.client.widgets.grid.ListGrid#getInitialSort
     * initialSort} or {@link com.smartgwt.client.widgets.grid.ListGrid#getSortField sortField}). <P> Note that if sorting was
     * applied via {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort()} [rather than {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()}] the sortSpecifiers returned will have been created based
     * on the specified sort field / direction passed into {@link com.smartgwt.client.widgets.grid.ListGrid#sort sort()}.
     *
     * @return current sort specifiers for this grid (may be null if  this grid is unsorted).
     */
    public native SortSpecifier[] getSort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSort();
        if(ret == null) return null;
        return @com.smartgwt.client.util.ConvertTo::arrayOfSortSpecifier(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Returns the number of fields involved in this grid's current sort configuration.
     *
     * @return the number of fields this grid is currently sorted on.
     */
    public native int getSortFieldCount() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSortFieldCount", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSortFieldCount();
        return ret;
    }-*/;

	/**
     * When multiple fields are sorted, this method returns the HTML for the sort-numeral that appears after the sort-arrows in
     * the header-buttons of sorted fields.  If you don't want sort-numerals in the header-buttons, you can override this
     * method to return null or an empty string, or set {@link com.smartgwt.client.widgets.grid.ListGrid#getShowSortNumerals
     * showSortNumerals} to false. <P> Note that the sortIndex passed in is zero based. The default implementation of this
     * method returns an HTML element with the {@link com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralStyle
     * sortNumeralStyle} applied to it, containing the specified sortIndex incremented by 1 (therefore showing the more
     * user-friendly 1-based numbering system).
     * @param fieldName The name of a sort-field to get the  {@link com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralStyle sortNumeral}
     * HTML for.
     * @param sortIndex The sort index for the field.
     *
     * @return The HTML for this field's sortNumeral.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     */
    public native String getSortNumeralHTML(String fieldName, int sortIndex) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSortNumeralHTML", "String,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSortNumeralHTML(fieldName, sortIndex);
        return ret;
    }-*/;

	/**
     * Returns the {@link com.smartgwt.client.data.SortSpecifier} for the passed fieldName, or null if the field is not sorted.
     * @param fieldName The name of a field, visible, hidden or existing only in the dataSource
     *
     * @return for the passed fieldName, or null if the field is not sorted.
     */
    public native SortSpecifier getSortSpecifier(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSortSpecifier", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSortSpecifier(fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.data.SortSpecifier::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Get the computed value of a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddSummaryFields summary field}.
     * @param field field that has a summary format
     * @param record record to use to compute formula value
     *
     * @return formula result
     */
    public native String getSummaryFieldValue(ListGridField field, Record record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getSummaryFieldValue", "ListGridField,Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getSummaryFieldValue(field.@com.smartgwt.client.core.DataClass::getJsObj()(), record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

	/**
     * If we're showing a {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu headerContextMenu} for this
     * grid and {@link com.smartgwt.client.widgets.grid.ListGrid#getCanFreezeFields this.canFreezeFields} is true, this string
     * will be shown as the title for the menu item to toggle whether a field is frozen or unfrozen. <P> Default implementation
     * evaluates and returns {@link com.smartgwt.client.widgets.grid.ListGrid#getFreezeFieldText freezeFieldText} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUnfreezeFieldText unfreezeFieldText} depending on whether the field is
     * currently frozen.
     * @param field field to get the menu item title for
     *
     * @return Title to show in the menu item.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     */
    public native String getToggleFreezeText(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getToggleFreezeText", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getToggleFreezeText(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret;
    }-*/;

    /**
     * Add a groupByComplete handler.
     * <p>
     * Callback fired when the listGrid is grouped or ungrouped. <P> Unlike {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addGroupByHandler ListGrid.groupBy()}, this notification will fire when
     * grouping is complete, and the {@link com.smartgwt.client.widgets.grid.ListGrid#getData ListGrid.data} object has been
     * updated. On successful grouping the <code>fields</code> argument will list the new  grouping and the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupTree ListGrid.groupTree} will have been updated to reflect the grouped
     * data. <P> Note that the <code>fields</code> argument may be an empty array if the data is not grouped. This implies that
     * a user or developer explicitly ungrouped the grid, or that a groupBy attempt failed due to the data length exceeding 
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByMaxRecords ListGrid.groupByMaxRecords}.
     *
     * @param handler the groupByComplete handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addGroupByCompleteHandler(com.smartgwt.client.widgets.grid.events.GroupByCompleteHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupByCompleteEvent.getType()) == 0) setupGroupByCompleteEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.GroupByCompleteEvent.getType());
    }

    private native void setupGroupByCompleteEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var groupByComplete = $entry(function(){
            var param = {"_this": this, "fields" : arguments[0]};
            var event = @com.smartgwt.client.widgets.grid.events.GroupByCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownGroupByCompleteEvent()();
            if (hasDefaultHandler) this.Super("groupByComplete", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("groupByComplete"));
            obj.addProperties({groupByComplete:  groupByComplete              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("groupByComplete"));
            obj.groupByComplete =  groupByComplete             ;
        }
    }-*/;

    private void handleTearDownGroupByCompleteEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupByCompleteEvent.getType()) == 0) tearDownGroupByCompleteEvent();
    }

    private native void tearDownGroupByCompleteEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("groupByComplete")) delete obj.groupByComplete;
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst sortByGroupFirst} is active, the sorting 
     * {@link com.smartgwt.client.data.SortSpecifier#getNormalizer normalizer} applied for implicit sorting by the field(s)
     * used for grouping. <P> No default implementation.
     * @param record record to normalize
     * @param fieldName name of the field on which sorting occurred.
     * See {@link com.smartgwt.client.docs.FieldName FieldName}
     * @param context the grid is passed to allow property and method access
     *
     * @return normalized value for sorting
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupSortDirection
     */
    public native Object groupSortNormalizer(ListGridRecord record, String fieldName, ListGrid context) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "groupSortNormalizer", "ListGridRecord,String,ListGrid");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.groupSortNormalizer(record.@com.smartgwt.client.core.DataClass::getJsObj()(), fieldName, context == null ? null : context.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()());
        return $wnd.SmartGWT.convertToJavaType(ret);
    }-*/;

    /**
     * Add a groupStateChanged handler.
     * <p>
     * Notification method executed whenever the groupState of this grid changes. Group state is accessible via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupState ListGrid.getGroupState()}, and contains group state information.
     *
     * @param handler the groupStateChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addGroupStateChangedHandler(com.smartgwt.client.widgets.grid.events.GroupStateChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupStateChangedEvent.getType()) == 0) setupGroupStateChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.GroupStateChangedEvent.getType());
    }

    private native void setupGroupStateChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var groupStateChanged = $entry(function(){
            var param = {"_this": this};
            var event = @com.smartgwt.client.widgets.grid.events.GroupStateChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownGroupStateChangedEvent()();
            if (hasDefaultHandler) this.Super("groupStateChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("groupStateChanged"));
            obj.addProperties({groupStateChanged:  groupStateChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("groupStateChanged"));
            obj.groupStateChanged =  groupStateChanged             ;
        }
    }-*/;

    private void handleTearDownGroupStateChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupStateChangedEvent.getType()) == 0) tearDownGroupStateChangedEvent();
    }

    private native void tearDownGroupStateChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("groupStateChanged")) delete obj.groupStateChanged;
    }-*/;

    /**
     * Add a groupBy handler.
     * <p>
     * Callback fired when the user attempts to group or ungroup the listGrid, or when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#groupBy ListGrid.groupBy()} is called programmatically.  This event may be
     * cancelled. <P> This notification is fired before the {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTree data}
     * is updated to reflect the grouping. See also {@link com.smartgwt.client.widgets.grid.ListGrid#addGroupByCompleteHandler
     * ListGrid.groupByComplete()}.
     *
     * @param handler the groupBy handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addGroupByHandler(com.smartgwt.client.widgets.grid.events.GroupByHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupByEvent.getType()) == 0) setupGroupByEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.GroupByEvent.getType());
    }

    private native void setupGroupByEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var handleGroupBy = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.GroupByEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownGroupByEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("handleGroupBy"));
            obj.addProperties({handleGroupBy: 
                function () {
                    var param = {"_this": this, "fields" : arguments[0], "specifiers" : arguments[1]};
                    var ret = handleGroupBy(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("handleGroupBy", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("handleGroupBy"));
            obj.handleGroupBy = 
                function () {
                    var param = {"_this": this, "fields" : arguments[0], "specifiers" : arguments[1]};
                    var ret = handleGroupBy(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("handleGroupBy", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownGroupByEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.GroupByEvent.getType()) == 0) tearDownGroupByEvent();
    }

    private native void tearDownGroupByEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("handleGroupBy")) delete obj.handleGroupBy;
    }-*/;

	/**
     * Whether the grid as a whole has any unsaved edits, in any row. Note that this method will return true if any rows are
     * {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved marked as removed} in addition to any rows that have
     * pending unsaved edits.
     *
     * @return returns true of any unsaved edits are present
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean hasChanges() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hasChanges", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.hasChanges();
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Does this grid currently have errors associated with editValues for any row in the grid.
     *
     * @return true if there are unresolved errors, false otherwise
     * @see com.smartgwt.client.widgets.grid.ListGrid#rowHasErrors
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellHasErrors
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Boolean hasErrors() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hasErrors", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.hasErrors();
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * Add a headerDoubleClick handler.
     * <p>
     * Handle a double click in the list header. <P> By default, calls {@link
     * com.smartgwt.client.widgets.grid.ListGrid#autoFitField ListGrid.autoFitField()} if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAutoFitFields ListGrid.canAutoFitFields} is true and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getHeaderAutoFitEvent ListGrid.headerAutoFitEvent} is
     * <code>"doubleClick"</code>.
     *
     * @param handler the headerDoubleClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addHeaderDoubleClickHandler(com.smartgwt.client.widgets.grid.events.HeaderDoubleClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderDoubleClickEvent.getType()) == 0) setupHeaderDoubleClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.HeaderDoubleClickEvent.getType());
    }

    private native void setupHeaderDoubleClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var headerDoubleClick = $entry(function(){
            var param = {"_this": this, "fieldNum" : arguments[0]};
            var event = @com.smartgwt.client.widgets.grid.events.HeaderDoubleClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownHeaderDoubleClickEvent()();
            if (hasDefaultHandler) this.Super("headerDoubleClick", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("headerDoubleClick"));
            obj.addProperties({headerDoubleClick:  headerDoubleClick              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("headerDoubleClick"));
            obj.headerDoubleClick =  headerDoubleClick             ;
        }
    }-*/;

    private void handleTearDownHeaderDoubleClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderDoubleClickEvent.getType()) == 0) tearDownHeaderDoubleClickEvent();
    }

    private native void tearDownHeaderDoubleClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("headerDoubleClick")) delete obj.headerDoubleClick;
    }-*/;

    /**
     * Add a headerHover handler.
     * <p>
     * Handle a hover over a button in the header.
     *
     * @param handler the headerHover handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addHeaderHoverHandler(com.smartgwt.client.widgets.grid.events.HeaderHoverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderHoverEvent.getType()) == 0) setupHeaderHoverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.HeaderHoverEvent.getType());
    }

    private native void setupHeaderHoverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var headerHover = $entry(function(){
            var param = {"_this": this, "fieldNum" : arguments[0]};
            var event = @com.smartgwt.client.widgets.grid.events.HeaderHoverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownHeaderHoverEvent()();
            if (hasDefaultHandler) this.Super("headerHover", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("headerHover"));
            obj.addProperties({headerHover:  headerHover              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("headerHover"));
            obj.headerHover =  headerHover             ;
        }
    }-*/;

    private void handleTearDownHeaderHoverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderHoverEvent.getType()) == 0) tearDownHeaderHoverEvent();
    }

    private native void tearDownHeaderHoverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("headerHover")) delete obj.headerHover;
    }-*/;

	/**
     * Returns the HTML that is displayed by the default {@link com.smartgwt.client.widgets.grid.ListGrid#addHeaderHoverHandler
     * headerHover} handler. Return null or an empty string to cancel the hover. <p>Use <code>setHeaderHoverFormatter()</code>
     * to provide a custom implementation.
     * @param fieldNum field number for the header that was hovered
     * @param defaultHTML the HTML that would have been displayed by default.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     *
     * @return HTML to be displayed in the hover. If null or an empty string, then the hover is canceled.
     * See {@link com.smartgwt.client.docs.HTMLString HTMLString}
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowClippedHeaderTitlesOnHover
     * @see com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public native String headerHoverHTML(int fieldNum, String defaultHTML) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "headerHoverHTML", "int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.headerHoverHTML(fieldNum, defaultHTML);
        return ret;
    }-*/;

	/**
     * Is the field title for the specified field clipped?
     * @param fieldNum field number for the header button title to test
     *
     * @return whether the field title for the specified field is clipped
     * @see com.smartgwt.client.widgets.grid.ListGrid#getClipHeaderTitles
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    public native boolean headerTitleClipped(int fieldNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "headerTitleClipped", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.headerTitleClipped(fieldNum);
        return ret == null ? false : ret;
    }-*/;

	/**
     * Hides the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field}, if currently shown.
     * @see com.smartgwt.client.widgets.grid.ListGrid#showDragHandles
     */
    public native void hideDragHandles() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideDragHandles", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideDragHandles();
    }-*/;

	/**
     * Force a field to be hidden.<br><br> NOTE: If a field.showIf expression exists, it will be destroyed. <P> Note also that
     * if multiple fields are to be hidden it is more efficient to call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideFields hideFields()} passing in the array of fields to hide rather than to
     * call this method repeatedly.  In particular, this will ensure {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recalculateSummaries recalculateSummaries()} is only run once.
     * @param field field to hide
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void hideField(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideField(field);
    }-*/;

	/**
     * Force a field to be hidden.<br><br> NOTE: If a field.showIf expression exists, it will be destroyed. <P> Note also that
     * if multiple fields are to be hidden it is more efficient to call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideFields hideFields()} passing in the array of fields to hide rather than to
     * call this method repeatedly.  In particular, this will ensure {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recalculateSummaries recalculateSummaries()} is only run once.
     * @param field field to hide
     * @param suppressRelayout if passed, don't relayout non-explicit sized fields                                      to fit the available space
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void hideField(String field, boolean suppressRelayout) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideField", "String,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideField(field, suppressRelayout);
    }-*/;
	
	/**
     * Force an array of fields to be hidden. <P> NOTE: If a field.showIf expression exists, it will be destroyed. <P> When
     * hiding multiple fields, this method should be called rather than calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} repeatedly for each field to hide.
     * @param fields fields to hide
     */
    public native void hideFields(String... fields) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideFields", "String...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields));
    }-*/;

	/**
     * Force an array of fields to be hidden. <P> NOTE: If a field.showIf expression exists, it will be destroyed. <P> When
     * hiding multiple fields, this method should be called rather than calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} repeatedly for each field to hide.
     * @param fields fields to hide
     */
    public native void hideFields(ListGridField... fields) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideFields", "ListGridField...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields));
    }-*/;

	/**
     * Force an array of fields to be hidden. <P> NOTE: If a field.showIf expression exists, it will be destroyed. <P> When
     * hiding multiple fields, this method should be called rather than calling {@link
     * com.smartgwt.client.widgets.grid.ListGrid#hideField hideField()} repeatedly for each field to hide.
     * @param fields fields to hide
     * @param suppressRelayout if passed, don't relayout non-explicit sized fields                                      to fit the available space
     */
    public native void hideFields(String[] fields, boolean suppressRelayout) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "hideFields", "String[],boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.hideFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields), suppressRelayout);
    }-*/;
	
    /**
     * Add a hilitesChanged handler.
     * <p>
     * Notification method executed whenever the end user uses the HiliteEditor to change the set of hilites applied to this
     * grid.  This method will not be called after a purely programmatic change to the hilites made with a call to {@link
     * com.smartgwt.client.widgets.DataBoundComponent#setHilites setHilites()}.  The array of currently applied hilite objects
     * is accessible via {@link com.smartgwt.client.widgets.DataBoundComponent#getHilites getHilites()}.
     *
     * @param handler the hilitesChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addHilitesChangedHandler(com.smartgwt.client.widgets.grid.events.HilitesChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.HilitesChangedEvent.getType()) == 0) setupHilitesChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.HilitesChangedEvent.getType());
    }

    private native void setupHilitesChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var hilitesChanged = $entry(function(){
            var param = {"_this": this};
            var event = @com.smartgwt.client.widgets.grid.events.HilitesChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownHilitesChangedEvent()();
            if (hasDefaultHandler) this.Super("hilitesChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("hilitesChanged"));
            obj.addProperties({hilitesChanged:  hilitesChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("hilitesChanged"));
            obj.hilitesChanged =  hilitesChanged             ;
        }
    }-*/;

    private void handleTearDownHilitesChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.HilitesChangedEvent.getType()) == 0) tearDownHilitesChangedEvent();
    }

    private native void tearDownHilitesChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("hilitesChanged")) delete obj.hilitesChanged;
    }-*/;

	/**
     * Invalidates the currently visible set of {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents
     * recordComponents} and gets fresh ones for the visible rows in the grid according to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode recordComponentPoolingMode} <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#refreshRecordComponent refreshRecordComponent()} which allows you to refresh a
     * specific recordComponent
     */
    public native void invalidateRecordComponents() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "invalidateRecordComponents", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.invalidateRecordComponents();
    }-*/;

	/**
     * Identifies whether the passed-in field is the specially generated {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCheckboxField checkboxField} used when {@link
     * com.smartgwt.client.types.SelectionAppearance} is "checkbox".  Use this method in your custom event handlers to avoid
     * inappropriately performing actions when the checkboxField is clicked on.
     * @param field field to test
     *
     * @return whether the provided field is the checkbox field
     */
    public native Boolean isCheckboxField(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isCheckboxField", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isCheckboxField(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Whether a given {@link com.smartgwt.client.widgets.grid.ListGridRecord record} is expanded or collapsed.
     * @param record record in question
     *
     * @return true if the node is expanded
     */
    public native Boolean isExpanded(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isExpanded", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isExpanded(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Identifies whether the passed-in field is the specially generated {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getExpansionField expansionField} used when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true.  Use this method in your custom
     * event handlers to avoid inappropriately performing actions when the expansionField is clicked on.
     * @param field field to test
     *
     * @return whether the provided field is the expansion field
     */
    public native Boolean isExpansionField(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isExpansionField", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isExpansionField(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Returns true if this component is currently  {@link com.smartgwt.client.widgets.grid.ListGrid#exportClientData exporting
     * client data}.  This method can be called from custom cell formatters if you need to return a different formatted value
     * for an export than for a live ListGrid
     *
     * @return returns true if this component is currently exporting client data
     * @see com.smartgwt.client.widgets.grid.ListGrid#exportClientData
     */
    public native boolean isExportingClientData() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isExportingClientData", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isExportingClientData();
        return ret == null ? false : ret;
    }-*/;

	/**
     * If this listGrid is {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped}, is the record passed in a group
     * header node.
     * @param record record to test
     *
     * @return returns true if the record passed in is a group header node
     */
    public native boolean isGroupNode(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isGroupNode", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(record==null){return false};
        var ret = self.isGroupNode(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret == null ? false : ret;
    }-*/;

	/**
     * When using tree-oriented selection modes like {@link com.smartgwt.client.widgets.tree.TreeGrid#getCascadeSelection
     * TreeGrid.cascadeSelection}, returns true if the record is considered partially selected because only some of it's
     * children are selected.
     * @param record record to check
     *
     * @return true if record is partially selected; false otherwise
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native Boolean isPartiallySelected(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isPartiallySelected", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isPartiallySelected(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Identifies whether the passed-in field is the specially generated {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRowNumberField rowNumberField} used when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers showRowNumbers} is true.  Use this method in your custom
     * event handlers to avoid inappropriately performing actions when the rowNumberField is clicked on.
     * @param field field to test
     *
     * @return whether the provided field is the rowNumberField
     */
    public native Boolean isRowNumberField(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isRowNumberField", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isRowNumberField(field.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Returns true if the record is selected.
     * @param record record to check
     *
     * @return true if record is selected; false otherwise
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native Boolean isSelected(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isSelected", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isSelected(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Returns true if the passed fieldName is in the current sort-specification.
     * @param fieldName The name of a field, visible, hidden or existing only in the dataSource
     *
     * @return True if the passed field is sorted, false otherwise
     */
    public native Boolean isSortField(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isSortField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isSortField(fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Returns whether the supplied record is a group or grid summary record.  Useful in conjunction with {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupMembers getGroupMembers()} for determining which records are group
     * summary records.
     * @param record Record object such as from {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupMembers getGroupMembers()}
     *
     * @return whether record is summary
     */
    public native boolean isSummaryRecord(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "isSummaryRecord", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.isSummaryRecord(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret == null ? false : ret;
    }-*/;

	/**
     * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a
     * looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that
     * developers use <code>markForRedraw()</code> instead of calling {@link com.smartgwt.client.widgets.Canvas#redraw
     * Canvas.redraw()} directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread
     * of execution will only lead to a single DOM manipulation which greatly improves application performance.
     * @see com.smartgwt.client.docs.Drawing Drawing overview and related methods
     */
    public native void markForRedraw() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markForRedraw", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markForRedraw();
    }-*/;

	/**
     * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a
     * looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that
     * developers use <code>markForRedraw()</code> instead of calling {@link com.smartgwt.client.widgets.Canvas#redraw
     * Canvas.redraw()} directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread
     * of execution will only lead to a single DOM manipulation which greatly improves application performance.
     * @param reason reason for performing the redraw
     * @see com.smartgwt.client.docs.Drawing Drawing overview and related methods
     */
    public native void markForRedraw(String reason) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markForRedraw", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markForRedraw(reason);
    }-*/;
	
	/**
     * Marks a record deleted such that a later call to {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits saveEdits()}
     * or {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits saveAllEdits()} will cause a "remove" {@link
     * com.smartgwt.client.data.DSRequest} to be submitted. <P> A removed record is disabled and non-editable, and uses {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRemovedCSSText removedCSSText} for its CSS style, which by default will
     * show strikethrough text. <P> Contrast this method with removeSelectedData(), which immediately submits a DSRequest to
     * remove the selected records from the dataset. <P> Records that have been marked for removal using this method may be
     * 'unmarked' via a call to {@link com.smartgwt.client.widgets.grid.ListGrid#unmarkRecordRemoved unmarkRecordRemoved()}, or
     * by discarding edit values ({@link com.smartgwt.client.widgets.grid.ListGrid#discardEdits discardEdits()}).
     * @param rowNum row number for the record to mark
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void markRecordRemoved(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markRecordRemoved", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markRecordRemoved(rowNum);
    }-*/;

	/**
     * Marks an array of records deleted such that a later call to {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits
     * saveEdits()} or  {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits saveAllEdits()} will cause a "remove"
     * {@link com.smartgwt.client.data.DSRequest} to be submitted. <P> This method is similar to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} but should be more efficient in
     * avoiding unneeded duplicate refreshes due to the multiple records getting marked.
     * @param records records or indices to mark removed
     * @see com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void markRecordsRemoved(ListGridRecord... records) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markRecordsRemoved", "ListGridRecord...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markRecordsRemoved(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records));
    }-*/;

	/**
     * Marks an array of records deleted such that a later call to {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits
     * saveEdits()} or  {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits saveAllEdits()} will cause a "remove"
     * {@link com.smartgwt.client.data.DSRequest} to be submitted. <P> This method is similar to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} but should be more efficient in
     * avoiding unneeded duplicate refreshes due to the multiple records getting marked.
     * @param records records or indices to mark removed
     * @see com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void markRecordsRemoved(int records) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markRecordsRemoved", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markRecordsRemoved(records);
    }-*/;

	/**
     * Marks an array of records deleted such that a later call to {@link com.smartgwt.client.widgets.grid.ListGrid#saveEdits
     * saveEdits()} or  {@link com.smartgwt.client.widgets.grid.ListGrid#saveAllEdits saveAllEdits()} will cause a "remove"
     * {@link com.smartgwt.client.data.DSRequest} to be submitted. <P> This method is similar to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} but should be more efficient in
     * avoiding unneeded duplicate refreshes due to the multiple records getting marked.
     * @param records records or indices to mark removed
     * @see com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void markRecordsRemoved(RecordList records) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markRecordsRemoved", "RecordList");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markRecordsRemoved(records == null ? null : records.@com.smartgwt.client.core.BaseClass::getOrCreateJsObj()());
    }-*/;

	/**
     * Marks the currently selected records as removed, as though {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()} had been called.
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void markSelectionRemoved() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "markSelectionRemoved", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.markSelectionRemoved();
    }-*/;

    /**
     * Add a bodyKeyPress handler.
     * <p>
     * Handle a keyPress event on the body. <P> Default implementation handles navigating between records with arrow keys, and
     * activating records with space and enter.
     *
     * @param handler the bodyKeyPress handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addBodyKeyPressHandler(com.smartgwt.client.widgets.grid.events.BodyKeyPressHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.BodyKeyPressEvent.getType()) == 0) setupBodyKeyPressEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.BodyKeyPressEvent.getType());
    }

    private native void setupBodyKeyPressEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onBodyKeyPress = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.BodyKeyPressEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownBodyKeyPressEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onBodyKeyPress"));
            obj.addProperties({onBodyKeyPress: 
                function () {
                    var param = {"_this": this};
                    var ret = onBodyKeyPress(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onBodyKeyPress", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onBodyKeyPress"));
            obj.onBodyKeyPress = 
                function () {
                    var param = {"_this": this};
                    var ret = onBodyKeyPress(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onBodyKeyPress", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownBodyKeyPressEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.BodyKeyPressEvent.getType()) == 0) tearDownBodyKeyPressEvent();
    }

    private native void tearDownBodyKeyPressEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onBodyKeyPress")) delete obj.onBodyKeyPress;
    }-*/;

    /**
     * Add a recordCollapse handler.
     * <p>
     * Handler fired when a record is collapsed in a grid with <code>canExpandRecords</code> set to true. Allows the collapse
     * to be cancelled.
     *
     * @param handler the recordCollapse handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRecordCollapseHandler(com.smartgwt.client.widgets.grid.events.RecordCollapseHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordCollapseEvent.getType()) == 0) setupRecordCollapseEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RecordCollapseEvent.getType());
    }

    private native void setupRecordCollapseEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onCollapseRecord = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RecordCollapseEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRecordCollapseEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onCollapseRecord"));
            obj.addProperties({onCollapseRecord: 
                function () {
                    var param = {"_this": this, "record" : arguments[0]};
                    var ret = onCollapseRecord(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onCollapseRecord", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onCollapseRecord"));
            obj.onCollapseRecord = 
                function () {
                    var param = {"_this": this, "record" : arguments[0]};
                    var ret = onCollapseRecord(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onCollapseRecord", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRecordCollapseEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordCollapseEvent.getType()) == 0) tearDownRecordCollapseEvent();
    }

    private native void tearDownRecordCollapseEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onCollapseRecord")) delete obj.onCollapseRecord;
    }-*/;

    /**
     * Add a recordExpand handler.
     * <p>
     * Handler fired when a record is expanded in a grid with <code>canExpandRecords</code> set to true. Allows the expansion
     * to be cancelled.
     *
     * @param handler the recordExpand handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRecordExpandHandler(com.smartgwt.client.widgets.grid.events.RecordExpandHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordExpandEvent.getType()) == 0) setupRecordExpandEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RecordExpandEvent.getType());
    }

    private native void setupRecordExpandEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onExpandRecord = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RecordExpandEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRecordExpandEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onExpandRecord"));
            obj.addProperties({onExpandRecord: 
                function () {
                    var param = {"_this": this, "record" : arguments[0]};
                    var ret = onExpandRecord(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onExpandRecord", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onExpandRecord"));
            obj.onExpandRecord = 
                function () {
                    var param = {"_this": this, "record" : arguments[0]};
                    var ret = onExpandRecord(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onExpandRecord", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRecordExpandEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordExpandEvent.getType()) == 0) tearDownRecordExpandEvent();
    }

    private native void tearDownRecordExpandEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onExpandRecord")) delete obj.onExpandRecord;
    }-*/;

    /**
     * Add a headerClick handler.
     * <p>
     * Handler fired when the user clicks a header in this listGrid before any other processing occurs. Call {@link
     * com.smartgwt.client.widgets.grid.events.HeaderClickEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.HeaderClickHandler#onHeaderClick} to suppress the default header click handling
     *
     * @param handler the headerClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addHeaderClickHandler(com.smartgwt.client.widgets.grid.events.HeaderClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderClickEvent.getType()) == 0) setupHeaderClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.HeaderClickEvent.getType());
    }

    private native void setupHeaderClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onHeaderClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.HeaderClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownHeaderClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onHeaderClick"));
            obj.addProperties({onHeaderClick: 
                function () {
                    var param = {"_this": this, "fieldNum" : arguments[0]};
                    var ret = onHeaderClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onHeaderClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onHeaderClick"));
            obj.onHeaderClick = 
                function () {
                    var param = {"_this": this, "fieldNum" : arguments[0]};
                    var ret = onHeaderClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onHeaderClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownHeaderClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.HeaderClickEvent.getType()) == 0) tearDownHeaderClickEvent();
    }

    private native void tearDownHeaderClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onHeaderClick")) delete obj.onHeaderClick;
    }-*/;

    /**
     * Add a recordClick handler.
     * <p>
     * Executed when the listGrid receives a 'click' event on an enabled, non-separator record. The default implementation does
     * nothing -- override to perform some action when any record or field is clicked.<br> A record event handler can be
     * specified either as a function to execute, or as a string of script to evaluate. If the handler is defined as a string
     * of script, all the parameters below will be available as variables for use in the script.<br> To do something specific
     * if a particular field is clicked, add a recordClick method or string of script to that field (same parameters) when
     * you're setting up the list.<br> <b>Notes:</b><ul> <li>This will not be called if the click is below the last item of the
     * list.</li> <li>This method is called from the default implementation of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#rowClick ListGrid.rowClick()}, so if that method is overridden this method may
     * not be fired.</li></ul>
     *
     * @param handler the recordClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRecordClickHandler(com.smartgwt.client.widgets.grid.events.RecordClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordClickEvent.getType()) == 0) setupRecordClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RecordClickEvent.getType());
    }

    private native void setupRecordClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onRecordClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RecordClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRecordClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onRecordClick"));
            obj.addProperties({onRecordClick: 
                function () {
                    var param = {"_this": this, "viewer" : arguments[0], "record" : arguments[1], "recordNum" : arguments[2], "field" : arguments[3], "fieldNum" : arguments[4], "value" : arguments[5], "rawValue" : arguments[6]};
                    var ret = onRecordClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRecordClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onRecordClick"));
            obj.onRecordClick = 
                function () {
                    var param = {"_this": this, "viewer" : arguments[0], "record" : arguments[1], "recordNum" : arguments[2], "field" : arguments[3], "fieldNum" : arguments[4], "value" : arguments[5], "rawValue" : arguments[6]};
                    var ret = onRecordClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRecordClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRecordClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordClickEvent.getType()) == 0) tearDownRecordClickEvent();
    }

    private native void tearDownRecordClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onRecordClick")) delete obj.onRecordClick;
    }-*/;

    /**
     * Add a recordDrop handler.
     * <p>
     * Process a drop of one or more records on a ListGrid record. <P> This method can be overridden to provide custom drop
     * behaviors, and is a more appropriate override point than the lower level {@link com.smartgwt.client.widgets.Canvas#drop
     * Canvas.drop()} handler. <P> If this is a self-drop, records are simply reordered. <P> For a drop from another widget,
     * {@link com.smartgwt.client.widgets.grid.ListGrid#transferDragData ListGrid.transferDragData()} is called, which
     * depending on the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragDataAction dragDataAction} specified on the
     * source widget, may either remove the source records from the original list (<code>dragDataAction:"move"</code>) or just
     * provide a copy to this list (<code>dragDataAction:"copy"</code>). <P> If this grid is databound, the new records will be
     * added to the dataset by calling {@link com.smartgwt.client.data.DataSource#addData DataSource.addData()}.  Further, if
     * the new records were dragged from another databound component, and {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getAddDropValues addDropValues} is true, {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getDropValues getDropValues} will be called for every item being dropped.
     * <P> For multi-record drops, Queuing is automatically used to combine all DSRequests into a single HTTP Request (see
     * QuickStart Guide, Server Framework chapter).  This allows the server to persist all changes caused by the drop in a
     * single transaction (and this is automatically done when using the built-in server DataSources with Power Edition and
     * above). <P> Note that reordering records has no effect on a databound grid. <P> The newly dropped data is then selected
     * automatically. <P> If these default persistence behaviors are undesirable, Call {@link
     * com.smartgwt.client.widgets.grid.events.RecordDropEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.RecordDropHandler#onRecordDrop} to cancel them, then and implement your own
     * behavior, typically by using grid.updateData() or addData() to add new records. <p><b>NOTE:</b> the records you receive
     * in this event are the actual Records from the source component.  Use {@link
     * com.smartgwt.client.data.DataSource#copyRecords DataSource.copyRecords()} to create a copy before modifying the records
     * or using them with updateData() or addData(). <P> NOTE: for a drop beyond the last visible record of a ListGrid,
     * <code>targetRecord</code> will be null and the <code>index</code> will be one higher than the last record.  This
     * includes a drop into an empty ListGrid, where <code>index</code> will be 0.
     *
     * @param handler the recordDrop handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRecordDropHandler(com.smartgwt.client.widgets.grid.events.RecordDropHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordDropEvent.getType()) == 0) setupRecordDropEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RecordDropEvent.getType());
    }

    private native void setupRecordDropEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onRecordDrop = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RecordDropEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRecordDropEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onRecordDrop"));
            obj.addProperties({onRecordDrop: 
                function () {
                    var param = {"_this": this, "dropRecords" : arguments[0], "targetRecord" : arguments[1], "index" : arguments[2], "dropPosition" : arguments[3], "sourceWidget" : arguments[4]};
                    var ret = onRecordDrop(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRecordDrop", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onRecordDrop"));
            obj.onRecordDrop = 
                function () {
                    var param = {"_this": this, "dropRecords" : arguments[0], "targetRecord" : arguments[1], "index" : arguments[2], "dropPosition" : arguments[3], "sourceWidget" : arguments[4]};
                    var ret = onRecordDrop(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRecordDrop", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRecordDropEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordDropEvent.getType()) == 0) tearDownRecordDropEvent();
    }

    private native void tearDownRecordDropEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onRecordDrop")) delete obj.onRecordDrop;
    }-*/;

    /**
     * Add a removeRecordClick handler.
     * <p>
     * Handler fired when the user clicks the "remove" icon if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords ListGrid.canRemoveRecords} is true. Default behavior will
     * remove the record from the data set, or if we're {@link com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval
     * deferring removal} mark the record as removed [or for records already marked as removed, clear this removed marker]. <P>
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval ListGrid.warnOnRemoval} is set, this method will
     * also show a warning dialog to users allowing them to cancel the removal. <P> This event may be cancelled to suppress the
     * default behavior.
     *
     * @param handler the removeRecordClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRemoveRecordClickHandler(com.smartgwt.client.widgets.grid.events.RemoveRecordClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RemoveRecordClickEvent.getType()) == 0) setupRemoveRecordClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RemoveRecordClickEvent.getType());
    }

    private native void setupRemoveRecordClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var onRemoveRecordClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RemoveRecordClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRemoveRecordClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("onRemoveRecordClick"));
            obj.addProperties({onRemoveRecordClick: 
                function () {
                    var param = {"_this": this, "rowNum" : arguments[0]};
                    var ret = onRemoveRecordClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRemoveRecordClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("onRemoveRecordClick"));
            obj.onRemoveRecordClick = 
                function () {
                    var param = {"_this": this, "rowNum" : arguments[0]};
                    var ret = onRemoveRecordClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("onRemoveRecordClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRemoveRecordClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RemoveRecordClickEvent.getType()) == 0) tearDownRemoveRecordClickEvent();
    }

    private native void tearDownRemoveRecordClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("onRemoveRecordClick")) delete obj.onRemoveRecordClick;
    }-*/;

	/**
     * Opens the node represented by the "record" parameter, if it is a folder and is not already open.  This method only
     * applies to {@link com.smartgwt.client.widgets.grid.ListGrid#groupBy grouped} ListGrids.
     * @param record node to open
     *
     * @return true if the node was opened, false if it was not (either because it is not                   a folder, or because it was
     * already open)
     */
    public native boolean openGroup(Record record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "openGroup", "Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.openGroup(record.@com.smartgwt.client.core.DataClass::getJsObj()());
        return ret == null ? false : ret;
    }-*/;

	/**
     * Refresh the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary}, by either re-calculating
     * from already-loaded data or doing a new fetch from the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSummaryRowDataSource summaryRowDataSource}. <P> Note unlike {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recalculateSummaries recalculateSummaries()}, this method will not force a
     * refresh of field-level summaries (see {@link com.smartgwt.client.widgets.grid.ListGridField#getRecordSummaryFunction
     * ListGridField.recordSummaryFunction}) or group level summaries (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary}).
     */
    public native void recalculateGridSummary() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "recalculateGridSummary", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.recalculateGridSummary();
    }-*/;

	/**
     * Recalculates values for fields with {@link com.smartgwt.client.widgets.grid.ListGridField#getRecordSummaryFunction
     * summary-functions} or  {@link com.smartgwt.client.widgets.grid.ListGridField#getUserFormula user formulae} defined and
     * for values displayed in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summary rows}.
     */
    public native void recalculateSummaries() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "recalculateSummaries", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.recalculateSummaries();
    }-*/;

    /**
     * @see ListGrid#recalculateSummaries
     */
    public void recalculateSummaries(Record... records){
        recalculateSummaries(records, null);
    }

	/**
     * Recalculates values for fields with {@link com.smartgwt.client.widgets.grid.ListGridField#getRecordSummaryFunction
     * summary-functions} or  {@link com.smartgwt.client.widgets.grid.ListGridField#getUserFormula user formulae} defined and
     * for values displayed in the {@link com.smartgwt.client.widgets.grid.ListGrid#getShowGridSummary grid summary} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary group summary rows}.
     * @param records Optional array of records to recalculate summaries for,                  or null for all records
     * @param fields Optional array of fields to recalculate summaries                 for, or null for all fields <P> Note that the records
     * should be from {@link com.smartgwt.client.widgets.grid.ListGrid#getData data}; thus, if the grid is grouped,  the
     * records should be from the grouped data rather than {@link com.smartgwt.client.widgets.grid.ListGrid#getOriginalData
     * originalData}.
     */
    public native void recalculateSummaries(Record[] records, ListGridField... fields) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "recalculateSummaries", "Record[],ListGridField...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.recalculateSummaries(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records), @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields));
    }-*/;
	
	/**
     * Executed when the listGrid receives a 'click' event on an enabled, non-separator record. The default implementation does
     * nothing -- override to perform some action when any record or field is clicked.<br> A record event handler can be
     * specified either as a function to execute, or as a string of script to evaluate. If the handler is defined as a string
     * of script, all the parameters below will be available as variables for use in the script.<br> To do something specific
     * if a particular field is clicked, add a recordClick method or string of script to that field (same parameters) when
     * you're setting up the list.<br> <b>Notes:</b><ul> <li>This will not be called if the click is below the last item of the
     * list.</li> <li>This method is called from the default implementation of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#rowClick rowClick()}, so if that method is overridden this method may not be
     * fired.</li></ul>
     * @param viewer the listGrid that contains the click event
     * @param record the record that was clicked on
     * @param recordNum number of the record clicked on in the current set of                                  displayed records (starts with 0)
     * @param field the field that was clicked on (field definition)
     * @param fieldNum number of the field clicked on in the listGrid.fields                                  array
     * @param value value of the cell (after valueMap, etc. applied)
     * @param rawValue raw value of the cell (before valueMap, etc applied)
     *
     * @return return false to cancel default behavior
     * @see com.smartgwt.client.widgets.grid.ListGrid#rowClick
     */
    public native boolean recordClick(ListGrid viewer, ListGridRecord record, int recordNum, ListGridField field, int fieldNum, Object value, Object rawValue) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "recordClick", "ListGrid,ListGridRecord,int,ListGridField,int,Object,Object");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.recordClick(viewer == null ? null : viewer.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), record.@com.smartgwt.client.core.DataClass::getJsObj()(), recordNum, field.@com.smartgwt.client.core.DataClass::getJsObj()(), fieldNum, value, rawValue);
        return ret == null ? false : ret;
    }-*/;

    /**
     * Add a recordDoubleClick handler.
     * <p>
     * Executed when the listGrid receives a 'doubleClick' event on an enabled, non-separator record. The default
     * implementation does nothing -- override to perform some action when any record or field is double clicked.<br> A record
     * event handler can be specified either as a function to execute, or as a string of script to evaluate. If the handler is
     * defined as a string of script, all the parameters below will be available as variables for use in the script.<br> To do
     * something specific if a particular field is double clicked, add a recordDoubleClick method or string of script to that
     * field (same parameters) when you're setting up the list.<br> <b>Notes:</b><ul> <li>This will not be called if the click
     * is below the last item of the list.</li> <li>This method is called from the default implementation of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#rowDoubleClick ListGrid.rowDoubleClick()}, so if that method is overridden
     * this method may not be fired.</li></ul>
     *
     * @param handler the recordDoubleClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRecordDoubleClickHandler(com.smartgwt.client.widgets.grid.events.RecordDoubleClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent.getType()) == 0) setupRecordDoubleClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent.getType());
    }

    private native void setupRecordDoubleClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var recordDoubleClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRecordDoubleClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("recordDoubleClick"));
            obj.addProperties({recordDoubleClick: 
                function () {
                    var param = {"_this": this, "viewer" : arguments[0], "record" : arguments[1], "recordNum" : arguments[2], "field" : arguments[3], "fieldNum" : arguments[4], "value" : arguments[5], "rawValue" : arguments[6]};
                    var ret = recordDoubleClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("recordDoubleClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("recordDoubleClick"));
            obj.recordDoubleClick = 
                function () {
                    var param = {"_this": this, "viewer" : arguments[0], "record" : arguments[1], "recordNum" : arguments[2], "field" : arguments[3], "fieldNum" : arguments[4], "value" : arguments[5], "rawValue" : arguments[6]};
                    var ret = recordDoubleClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("recordDoubleClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRecordDoubleClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent.getType()) == 0) tearDownRecordDoubleClickEvent();
    }

    private native void tearDownRecordDoubleClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("recordDoubleClick")) delete obj.recordDoubleClick;
    }-*/;

	/**
     * Returns true if the specified record is marked as removed via a call to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}
     * @param rowNum index of row to verify
     *
     * @return true if the specified record has been marked for removal
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean recordMarkedAsRemoved(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "recordMarkedAsRemoved", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.recordMarkedAsRemoved(rowNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Redraw just the {@link com.smartgwt.client.widgets.grid.ListGrid#getHeader grid header}
     * @param rightNow If true, redraw the grid header with a direct inline call          to its redraw() method.  Otherwise,           {@link
     * com.smartgwt.client.widgets.Canvas#markForRedraw mark the header for redraw}
     */
    public native void redrawHeader(boolean rightNow) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "redrawHeader", "boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.redrawHeader(rightNow);
    }-*/;

	/**
     * Refresh an individual cell without redrawing the grid. <P> The cell's value, CSS class, and CSS text will be refreshed,
     * to the current values returned by getCellValue(), getCellStyle() and getCellCSSText() respectively.
     * @param rowNum row number of cell to refresh
     * @param colNum column number of cell to refresh
     * @see com.smartgwt.client.widgets.grid.ListGrid#refreshCellStyle
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_datatypes_calculated" target="examples">Calculated Example</a>
     */
    public native void refreshCell(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshCell", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshCell(rowNum, colNum);
    }-*/;

	/**
     * Refresh the styling of an individual cell without redrawing the grid. <P> The cell's CSS class and CSS text will be
     * refreshed, to the current values returned by getCellStyle() and getCellCSSText() respectively. <P> The cell's contents
     * (as returned by getCellValue()) will <b>not</b> be refreshed.  To refresh both styling and contents, call refreshCell()
     * instead.
     * @param rowNum row number of cell to refresh
     * @param colNum column number of cell to refresh
     * @see com.smartgwt.client.widgets.grid.ListGrid#refreshCell
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public native void refreshCellStyle(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshCellStyle", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshCellStyle(rowNum, colNum);
    }-*/;

	/**
     * Unlike {@link com.smartgwt.client.widgets.grid.ListGrid#invalidateCache invalidateCache} this will perform an
     * asynchronous (background) refresh of this component's data and then call the provided callback method on completion.  A
     * grid needs to have a {@link com.smartgwt.client.data.DataSource} associated with it to use this method. <p> If
     * <code>refreshData()</code> is called while the grid is waiting for a response from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} the <code>refreshData()</code> call will be aborted.
     * This is because the fetch has higher priority. <p> If {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()} is called while the grid is waiting for a response from <code>refreshData()</code>  and the
     * <code>fetchData()</code> call has altered the criteria or sort specifiers, the <code>refreshData()</code> call will be
     * aborted. <p> If data is being edited or has been edited without being saved when <code>refreshData()</code> is called,
     * the data will be retained so you can save it after the refresh is complete. If you however want to throw away your
     * edited but unsaved data when calling <code>refreshData()</code> you first need to call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#discardAllEdits discardAllEdits()} which will discard any unsaved edited data.
     * <p> Note that for a TreeGrid with {@link com.smartgwt.client.widgets.tree.TreeGrid#getLoadDataOnDemand
     * TreeGrid.loadDataOnDemand}: true, all currently opened parent nodes will be re-fetched, except for {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getDataFetchMode paged} TreeGrids, for which only opened parent nodes that are
     * <i>visible</i> or contain <i>visible</i> children are re-fetched.  We do this in a single queued batch of fetches to
     * maximize efficiency. <p> By design, {@link com.smartgwt.client.widgets.grid.ListGrid#addDataChangedHandler
     * dataChanged()} is not fired after <code>refreshData()</code>, as the Framework is not in a position to know if data has
     * actually changed (which would require traversing the entire dataset to determine) and whether criteria, sort or other
     * specifiers of the dataset also have not changed. Applications that need to take action on <code>refreshData()</code>
     * should use the callback to do so.
     * @see com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * @see com.smartgwt.client.widgets.grid.ListGrid#invalidateCache
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void refreshData() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshData", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshData();
    }-*/;

	/**
     * Unlike {@link com.smartgwt.client.widgets.grid.ListGrid#invalidateCache invalidateCache} this will perform an
     * asynchronous (background) refresh of this component's data and then call the provided callback method on completion.  A
     * grid needs to have a {@link com.smartgwt.client.data.DataSource} associated with it to use this method. <p> If
     * <code>refreshData()</code> is called while the grid is waiting for a response from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#fetchData fetchData()} the <code>refreshData()</code> call will be aborted.
     * This is because the fetch has higher priority. <p> If {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()} is called while the grid is waiting for a response from <code>refreshData()</code>  and the
     * <code>fetchData()</code> call has altered the criteria or sort specifiers, the <code>refreshData()</code> call will be
     * aborted. <p> If data is being edited or has been edited without being saved when <code>refreshData()</code> is called,
     * the data will be retained so you can save it after the refresh is complete. If you however want to throw away your
     * edited but unsaved data when calling <code>refreshData()</code> you first need to call {@link
     * com.smartgwt.client.widgets.grid.ListGrid#discardAllEdits discardAllEdits()} which will discard any unsaved edited data.
     * <p> Note that for a TreeGrid with {@link com.smartgwt.client.widgets.tree.TreeGrid#getLoadDataOnDemand
     * TreeGrid.loadDataOnDemand}: true, all currently opened parent nodes will be re-fetched, except for {@link
     * com.smartgwt.client.widgets.tree.TreeGrid#getDataFetchMode paged} TreeGrids, for which only opened parent nodes that are
     * <i>visible</i> or contain <i>visible</i> children are re-fetched.  We do this in a single queued batch of fetches to
     * maximize efficiency. <p> By design, {@link com.smartgwt.client.widgets.grid.ListGrid#addDataChangedHandler
     * dataChanged()} is not fired after <code>refreshData()</code>, as the Framework is not in a position to know if data has
     * actually changed (which would require traversing the entire dataset to determine) and whether criteria, sort or other
     * specifiers of the dataset also have not changed. Applications that need to take action on <code>refreshData()</code>
     * should use the callback to do so.
     * @param callback callback method to run once the refresh completes.
     * @see com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * @see com.smartgwt.client.widgets.grid.ListGrid#invalidateCache
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void refreshData(DSCallback callback) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshData", "DSCallback");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshData(
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}));
    }-*/;
	
	/**
     * Re-evaluates {@link com.smartgwt.client.widgets.grid.ListGridField#showIf ListGridField.showIf()} for each field,
     * dynamically showing and hiding the appropriate set of fields
     */
    public native void refreshFields() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshFields", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshFields();
    }-*/;

	/**
     * Discards any {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponent} currently
     * assigned to the specified record (or cell) and gets a fresh one, according to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode recordComponentPoolingMode} <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#invalidateRecordComponents invalidateRecordComponents()} which allows you to
     * refresh all record components that are currently visible in the grid.
     * @param rowNum Row to refresh
     */
    public native void refreshRecordComponent(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshRecordComponent", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshRecordComponent(rowNum);
    }-*/;

	/**
     * Discards any {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents recordComponent} currently
     * assigned to the specified record (or cell) and gets a fresh one, according to the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getRecordComponentPoolingMode recordComponentPoolingMode} <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#invalidateRecordComponents invalidateRecordComponents()} which allows you to
     * refresh all record components that are currently visible in the grid.
     * @param rowNum Row to refresh
     * @param colNum Column to refresh. This parameter should be passed      if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} is true.
     */
    public native void refreshRecordComponent(int rowNum, Integer colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshRecordComponent", "int,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshRecordComponent(rowNum, colNum == null ? null : colNum.@java.lang.Integer::intValue()());
    }-*/;
	
	/**
     * Refresh an entire row of cells without redrawing the grid. <P> The cells' values, CSS classes, and CSS text will be
     * refreshed, to the current values returned by getCellValue(), getCellStyle() and getCellCSSText() respectively.
     * @param rowNum row number of cell to refresh
     * @see com.smartgwt.client.widgets.grid.ListGrid#refreshCellStyle
     * @see com.smartgwt.client.widgets.grid.ListGrid#refreshCell
     * @see com.smartgwt.client.docs.Appearance Appearance overview and related methods
     */
    public native void refreshRow(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "refreshRow", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshRow(rowNum);
    }-*/;

	/**
     * Programmatically regroup the grid according to the current grouping configuration.
     * @see com.smartgwt.client.widgets.grid.ListGrid#groupBy
     */
    public native void regroup() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "regroup", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.regroup();
    }-*/;

	/**
     * Remove a record from this ListGrid. <P> If this grid is bound to a DataSource, it will perform a DataSource "remove"
     * operation to remove records from this component's DataSource. <P> Otherwise the data will be removed from the grid's
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getData data} object. <P> To make changes to the local data object even
     * when a DataSource is present, use {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally}.
     * @param data listGrid record, or primary key values of record to delete.
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void removeData(Record data) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeData", "Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeData(data.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

    /**
     * @see ListGrid#removeData
     */
    public void removeData(Record data, DSCallback callback){
        removeData(data, callback, null);
    }

	/**
     * Remove a record from this ListGrid. <P> If this grid is bound to a DataSource, it will perform a DataSource "remove"
     * operation to remove records from this component's DataSource. <P> Otherwise the data will be removed from the grid's
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getData data} object. <P> To make changes to the local data object even
     * when a DataSource is present, use {@link com.smartgwt.client.widgets.grid.ListGrid#getSaveLocally saveLocally}.
     * @param data listGrid record, or primary key values of record to delete.
     * @param callback method to call on operation completion.   Note that if this is method does not trigger a dataSource remove operation,
     * the callback   will still be fired when the data has been removed, but the <code>dsResponse</code> parameter   will be
     * null.
     * @param requestProperties additional properties to set on any DSRequest                                          that will be issued
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native void removeData(Record data, DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeData", "Record,DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeData(data.@com.smartgwt.client.core.DataClass::getJsObj()(), 
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Removes an embedded component previously associated with the provided record. If a Canvas is passed as the
     * <code>record</code> parameter, it is assumed to be a component and the record is detected automatically from it.  If
     * <code>destroyOnUnEmbed</code> is <code>true</code> for the component, it will also be destroyed.
     * @param record record that the component was previously attached     to or the component itself
     */
    public native void removeEmbeddedComponent(ListGridRecord record) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeEmbeddedComponent", "ListGridRecord");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeEmbeddedComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Removes an embedded component previously associated with the provided record. If a Canvas is passed as the
     * <code>record</code> parameter, it is assumed to be a component and the record is detected automatically from it.  If
     * <code>destroyOnUnEmbed</code> is <code>true</code> for the component, it will also be destroyed.
     * @param record record that the component was previously attached     to or the component itself
     * @param component component to unembed, or the colNum in which it appears
     */
    public native void removeEmbeddedComponent(ListGridRecord record, Integer component) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeEmbeddedComponent", "ListGridRecord,Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeEmbeddedComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()(), component == null ? null : component.@java.lang.Integer::intValue()());
    }-*/;
	
	/**
     * Method fired when the user clicks the "remove" icon if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanRemoveRecords canRemoveRecords} is true. Default behavior will remove
     * the record from the data set, or if we're {@link com.smartgwt.client.widgets.grid.ListGrid#getDeferRemoval deferring
     * removal} mark record as removed [or for records already marked as removed, clear this removed marker]. <P> If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getWarnOnRemoval warnOnRemoval} is set, this method will also show a warning
     * dialog to users allowing them to cancel the removal. <P> This method may be called directly to cause a record to be
     * removed or marked for removal as if the user had hit the "remove" icon. <P> To be notified when a "remove" click occurs,
     * developers should add a {@link com.smartgwt.client.widgets.grid.ListGrid#addRemoveRecordClickHandler *
     * RemoveRecordClickHandler}.
     * @param rowNum Row on which the icon was clicked
     */
    public native void removeRecordClick(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeRecordClick", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeRecordClick(rowNum);
    }-*/;

	/**
     * Remove the currently selected records from this component. If this is a databound grid, the records will be removed
     * directly from the DataSource. <P> If no records are selected, no action is taken. The grid will automatically be updated
     * if the record deletion succeeds.
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#remove_grid_form_category" target="examples">Remove Example</a>
     */
    public native void removeSelectedData() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeSelectedData", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeSelectedData();
    }-*/;

    /**
     * @see ListGrid#removeSelectedData
     */
    public void removeSelectedData(DSCallback callback){
        removeSelectedData(callback, null);
    }

	/**
     * Remove the currently selected records from this component. If this is a databound grid, the records will be removed
     * directly from the DataSource. <P> If no records are selected, no action is taken. The grid will automatically be updated
     * if the record deletion succeeds.
     * @param callback callback to fire when the data has been removed
     * @param requestProperties additional properties to set on the DSRequest                                          that will be issued
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#remove_grid_form_category" target="examples">Remove Example</a>
     */
    public native void removeSelectedData(DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "removeSelectedData", "DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeSelectedData(
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Reorder a particular field
     * @param fieldNum Number of the field to reorder
     * @param moveToPosition New position for that field
     */
    public native void reorderField(int fieldNum, int moveToPosition) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "reorderField", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.reorderField(fieldNum, moveToPosition);
    }-*/;

	/**
     * Reorder a set of adjacent fields, from start to end exclusive at the end, by distance moveDelta.<br><br> NOTE: start and
     * end coordinates are in terms of the currently visible fields, not the full set of fields.
     * @param start Start of the range of fields to move, inclusive
     * @param end End of the range of fields to move, non-inclusive
     * @param moveDelta Distance to move by
     */
    public native void reorderFields(int start, int end, int moveDelta) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "reorderFields", "int,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.reorderFields(start, end, moveDelta);
    }-*/;

	/**
     * Resize a particular field to a new width. Note that this method will also set {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth} to false if it was previously
     * true.
     * @param fieldNum Number of the field to resize
     * @param newWidth New width of the field
     */
    public native void resizeField(int fieldNum, int newWidth) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "resizeField", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.resizeField(fieldNum, newWidth);
    }-*/;

	/**
     * If a list has become unsorted due to data modification or a call to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#unsort unsort()}, this method will resort the list by the previous {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setSort sort-specifier} array, if there is one, or by the previous sort-field
     * and -direction.
     */
    public native void resort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "resort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.resort();
    }-*/;

	/**
     * Event handler for when rows in the body are clicked upon. The default implementation handles firing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()} if appropriate, and fires {@link
     * com.smartgwt.client.widgets.grid.ListGridField#addRecordClickHandler ListGridField.recordClick()} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recordClick recordClick()} if set. Developers should typically implement
     * recordClick rather than overriding this method. <P> Note that this method fires in addition to any specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addCellClickHandler ListGrid.cellClick()} handler (even if that method cancels
     * the event as a whole by returning <code>false</code>).
     * @param record record object returned from getCellRecord()
     * @param recordNum index of the row where the click occurred
     * @param fieldNum index of the col where the click occurred
     * @see com.smartgwt.client.widgets.grid.ListGrid#recordClick
     */
    public native void rowClick(ListGridRecord record, int recordNum, int fieldNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowClick", "ListGridRecord,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.rowClick(record.@com.smartgwt.client.core.DataClass::getJsObj()(), recordNum, fieldNum);
    }-*/;

	/**
     * Event handler for when rows in the body are clicked upon. The default implementation handles firing {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()} if appropriate, and fires {@link
     * com.smartgwt.client.widgets.grid.ListGridField#addRecordClickHandler ListGridField.recordClick()} and/or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#recordClick recordClick()} if set. Developers should typically implement
     * recordClick rather than overriding this method. <P> Note that this method fires in addition to any specified {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addCellClickHandler ListGrid.cellClick()} handler (even if that method cancels
     * the event as a whole by returning <code>false</code>).
     * @param record record object returned from getCellRecord()
     * @param recordNum index of the row where the click occurred
     * @param fieldNum index of the col where the click occurred
     * @param keyboardGenerated indicates whether this was a synthesized record                                              click in response to a
     * keyboard event
     * @see com.smartgwt.client.widgets.grid.ListGrid#recordClick
     */
    public native void rowClick(ListGridRecord record, int recordNum, int fieldNum, boolean keyboardGenerated) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowClick", "ListGridRecord,int,int,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.rowClick(record.@com.smartgwt.client.core.DataClass::getJsObj()(), recordNum, fieldNum, keyboardGenerated);
    }-*/;
	
    /**
     * Add a rowContextClick handler.
     * <p>
     * Called when a row receives a contextclick event.
     *
     * @param handler the rowContextClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowContextClickHandler(com.smartgwt.client.widgets.grid.events.RowContextClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowContextClickEvent.getType()) == 0) setupRowContextClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowContextClickEvent.getType());
    }

    private native void setupRowContextClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowContextClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowContextClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowContextClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowContextClick"));
            obj.addProperties({rowContextClick: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowContextClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowContextClick"));
            obj.rowContextClick = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowContextClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowContextClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowContextClickEvent.getType()) == 0) tearDownRowContextClickEvent();
    }

    private native void tearDownRowContextClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowContextClick")) delete obj.rowContextClick;
    }-*/;

	/**
     * Event handler for when a body record is double-clicked. <P> Default implementation fires 'editCell' if appropriate, and
     * handles firing 'recordDoubleClick' stringMethod if defined at the field or LG level (That method has a different
     * signature from this one)
     * @param record record object returned from getCellRecord()
     * @param recordNum index of the row where the click occurred
     * @param fieldNum index of the col where the click occurred
     * @see com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent
     */
    public native void rowDoubleClick(ListGridRecord record, int recordNum, int fieldNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowDoubleClick", "ListGridRecord,int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.rowDoubleClick(record.@com.smartgwt.client.core.DataClass::getJsObj()(), recordNum, fieldNum);
    }-*/;

	/**
     * Event handler for when a body record is double-clicked. <P> Default implementation fires 'editCell' if appropriate, and
     * handles firing 'recordDoubleClick' stringMethod if defined at the field or LG level (That method has a different
     * signature from this one)
     * @param record record object returned from getCellRecord()
     * @param recordNum index of the row where the click occurred
     * @param fieldNum index of the col where the click occurred
     * @param keyboardGenerated indicates whether this was a synthesized record                                              doubleclick in response to
     * a keyboard event
     * @see com.smartgwt.client.widgets.grid.events.RecordDoubleClickEvent
     */
    public native void rowDoubleClick(ListGridRecord record, int recordNum, int fieldNum, boolean keyboardGenerated) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowDoubleClick", "ListGridRecord,int,int,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.rowDoubleClick(record.@com.smartgwt.client.core.DataClass::getJsObj()(), recordNum, fieldNum, keyboardGenerated);
    }-*/;
	
    /**
     * Add a rowEditorEnter handler.
     * <p>
     * Callback fired when the user starts editing a new row.
     *
     * @param handler the rowEditorEnter handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowEditorEnterHandler(com.smartgwt.client.widgets.grid.events.RowEditorEnterHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowEditorEnterEvent.getType()) == 0) setupRowEditorEnterEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowEditorEnterEvent.getType());
    }

    private native void setupRowEditorEnterEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowEditorEnter = $entry(function(){
            var param = {"_this": this, "record" : arguments[0], "editValues" : arguments[1], "rowNum" : arguments[2]};
            var event = @com.smartgwt.client.widgets.grid.events.RowEditorEnterEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowEditorEnterEvent()();
            if (hasDefaultHandler) this.Super("rowEditorEnter", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowEditorEnter"));
            obj.addProperties({rowEditorEnter:  rowEditorEnter              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowEditorEnter"));
            obj.rowEditorEnter =  rowEditorEnter             ;
        }
    }-*/;

    private void handleTearDownRowEditorEnterEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowEditorEnterEvent.getType()) == 0) tearDownRowEditorEnterEvent();
    }

    private native void tearDownRowEditorEnterEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowEditorEnter")) delete obj.rowEditorEnter;
    }-*/;

    /**
     * Add a rowEditorExit handler.
     * <p>
     * Callback fired when the user attempts to navigate away from the current edit row, or complete the current edit. <P> Call
     * {@link com.smartgwt.client.widgets.grid.events.RowEditorExitEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.RowEditorExitHandler#onRowEditorExit} from this method to cancel the default
     * behavior (Saving / cancelling the current edit / moving to the next edit cell).
     *
     * @param handler the rowEditorExit handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowEditorExitHandler(com.smartgwt.client.widgets.grid.events.RowEditorExitHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowEditorExitEvent.getType()) == 0) setupRowEditorExitEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowEditorExitEvent.getType());
    }

    private native void setupRowEditorExitEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowEditorExit = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowEditorExitEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowEditorExitEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowEditorExit"));
            obj.addProperties({rowEditorExit: 
                function () {
                    var param = {"_this": this, "editCompletionEvent" : arguments[0], "record" : arguments[1], "newValues" : arguments[2], "rowNum" : arguments[3]};
                    var ret = rowEditorExit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowEditorExit", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowEditorExit"));
            obj.rowEditorExit = 
                function () {
                    var param = {"_this": this, "editCompletionEvent" : arguments[0], "record" : arguments[1], "newValues" : arguments[2], "rowNum" : arguments[3]};
                    var ret = rowEditorExit(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowEditorExit", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowEditorExitEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowEditorExitEvent.getType()) == 0) tearDownRowEditorExitEvent();
    }

    private native void tearDownRowEditorExitEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowEditorExit")) delete obj.rowEditorExit;
    }-*/;

	/**
     * If this listGrid can be edited, this method will return true if the row passed in has been edited, but the edits have
     * not yet been saved to the ListGrid's data object. <P> Note this method will not return true if a record has been marked
     * as {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved removed}, but has no other changes. Developers can
     * use {@link com.smartgwt.client.widgets.grid.ListGrid#recordMarkedAsRemoved recordMarkedAsRemoved()} to check for this
     * case.
     * @param rowNum index of row to check for changes
     *
     * @return true if the row has changes.
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean rowHasChanges(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowHasChanges", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.rowHasChanges(rowNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Does the specified row have unresolved errors?
     * @param rowNum rowNum to check for errors
     *
     * @return true if there are unresolved errors, false otherwise
     * @see com.smartgwt.client.widgets.grid.ListGrid#hasErrors
     * @see com.smartgwt.client.widgets.grid.ListGrid#cellHasErrors
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Boolean rowHasErrors(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "rowHasErrors", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.rowHasErrors(rowNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * Add a rowHover handler.
     * <p>
     * Called when the mouse hovers over a row if this.canHover is true.   Returning false will suppress the hover text from
     * being shown if this.showHover is true.
     *
     * @param handler the rowHover handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowHoverHandler(com.smartgwt.client.widgets.grid.events.RowHoverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowHoverEvent.getType()) == 0) setupRowHoverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowHoverEvent.getType());
    }

    private native void setupRowHoverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowHover = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowHoverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowHoverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowHover"));
            obj.addProperties({rowHover: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowHover", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowHover"));
            obj.rowHover = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowHover(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowHover", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowHoverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowHoverEvent.getType()) == 0) tearDownRowHoverEvent();
    }

    private native void tearDownRowHoverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowHover")) delete obj.rowHover;
    }-*/;

    /**
     * Add a rowMouseDown handler.
     * <p>
     * Called when a row receives a mousedown event.
     *
     * @param handler the rowMouseDown handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowMouseDownHandler(com.smartgwt.client.widgets.grid.events.RowMouseDownHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowMouseDownEvent.getType()) == 0) setupRowMouseDownEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowMouseDownEvent.getType());
    }

    private native void setupRowMouseDownEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowMouseDown = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowMouseDownEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowMouseDownEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowMouseDown"));
            obj.addProperties({rowMouseDown: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowMouseDown(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowMouseDown", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowMouseDown"));
            obj.rowMouseDown = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowMouseDown(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowMouseDown", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowMouseDownEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowMouseDownEvent.getType()) == 0) tearDownRowMouseDownEvent();
    }

    private native void tearDownRowMouseDownEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowMouseDown")) delete obj.rowMouseDown;
    }-*/;

    /**
     * Add a rowMouseUp handler.
     * <p>
     * Called when a row receives a mouseup event.
     *
     * @param handler the rowMouseUp handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowMouseUpHandler(com.smartgwt.client.widgets.grid.events.RowMouseUpHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowMouseUpEvent.getType()) == 0) setupRowMouseUpEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowMouseUpEvent.getType());
    }

    private native void setupRowMouseUpEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowMouseUp = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowMouseUpEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowMouseUpEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowMouseUp"));
            obj.addProperties({rowMouseUp: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowMouseUp(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowMouseUp", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowMouseUp"));
            obj.rowMouseUp = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowMouseUp(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowMouseUp", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowMouseUpEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowMouseUpEvent.getType()) == 0) tearDownRowMouseUpEvent();
    }

    private native void tearDownRowMouseUpEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowMouseUp")) delete obj.rowMouseUp;
    }-*/;

    /**
     * Add a rowOut handler.
     * <p>
     * Called when the mouse pointer leaves a row
     *
     * @param handler the rowOut handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowOutHandler(com.smartgwt.client.widgets.grid.events.RowOutHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowOutEvent.getType()) == 0) setupRowOutEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowOutEvent.getType());
    }

    private native void setupRowOutEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowOut = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowOutEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowOutEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowOut"));
            obj.addProperties({rowOut: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowOut", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowOut"));
            obj.rowOut = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowOut(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowOut", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowOutEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowOutEvent.getType()) == 0) tearDownRowOutEvent();
    }

    private native void tearDownRowOutEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowOut")) delete obj.rowOut;
    }-*/;

    /**
     * Add a rowOver handler.
     * <p>
     * Called when the mouse pointer enters a row
     *
     * @param handler the rowOver handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addRowOverHandler(com.smartgwt.client.widgets.grid.events.RowOverHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.RowOverEvent.getType()) == 0) setupRowOverEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.RowOverEvent.getType());
    }

    private native void setupRowOverEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var rowOver = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.RowOverEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownRowOverEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("rowOver"));
            obj.addProperties({rowOver: 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowOver", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("rowOver"));
            obj.rowOver = 
                function () {
                    var param = {"_this": this, "record" : arguments[0], "rowNum" : arguments[1], "colNum" : arguments[2]};
                    var ret = rowOver(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("rowOver", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownRowOverEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.RowOverEvent.getType()) == 0) tearDownRowOverEvent();
    }

    private native void tearDownRowOverEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("rowOver")) delete obj.rowOver;
    }-*/;

	/**
     * Validates and saves edits within the row currently being edited (or another row with unsaved edits, if indicated). <P>
     * This method can be called to manually trigger saves if the default mechanisms of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell cell by cell} or row by row saving are not suitable. <P> The
     * 'callback' parameter provides a notification when the save attempt completes, which is likely to be asynchronous for
     * databound grids.  Cases under which the callback will fire are: <ul><li>Save completed successfully</li> <li>No changes
     * to the edited row, so save not required</li> <li>Validation failure occurred on the client or on the server</li></ul>
     * Note that if this method was unable to determine the row to be saved, the callback will NOT fire - in this case, the
     * method is a no-op. <P> Other, standard callbacks such as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEditCompleteHandler ListGrid.editComplete()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEditFailedHandler ListGrid.editFailed()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addCellSavedHandler ListGrid.cellSaved()} will fire normally. <P> Note this
     * method does not hide the inline editors if they are showing - to explicitly save and end editing, use the method
     * 'endEditing()' <P> If this method is called for a row which has been marked for deletion (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}) it will cause the record to be removed
     * from the data-set.
     * @see com.smartgwt.client.widgets.grid.ListGrid#endEditing
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void saveEdits() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "saveEdits", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.saveEdits();
    }-*/;

    /**
     * @see ListGrid#saveEdits
     */
    public void saveEdits(EditCompletionEvent editCompletionEvent){
        saveEdits(editCompletionEvent, null, (Integer) null);
    }

    /**
     * @see ListGrid#saveEdits
     */
    public void saveEdits(EditCompletionEvent editCompletionEvent, String callback){
        saveEdits(editCompletionEvent, callback, (Integer) null);
    }

	/**
     * Validates and saves edits within the row currently being edited (or another row with unsaved edits, if indicated). <P>
     * This method can be called to manually trigger saves if the default mechanisms of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSaveByCell cell by cell} or row by row saving are not suitable. <P> The
     * 'callback' parameter provides a notification when the save attempt completes, which is likely to be asynchronous for
     * databound grids.  Cases under which the callback will fire are: <ul><li>Save completed successfully</li> <li>No changes
     * to the edited row, so save not required</li> <li>Validation failure occurred on the client or on the server</li></ul>
     * Note that if this method was unable to determine the row to be saved, the callback will NOT fire - in this case, the
     * method is a no-op. <P> Other, standard callbacks such as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEditCompleteHandler ListGrid.editComplete()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addEditFailedHandler ListGrid.editFailed()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addCellSavedHandler ListGrid.cellSaved()} will fire normally. <P> Note this
     * method does not hide the inline editors if they are showing - to explicitly save and end editing, use the method
     * 'endEditing()' <P> If this method is called for a row which has been marked for deletion (see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}) it will cause the record to be removed
     * from the data-set.
     * @param editCompletionEvent Event used to complete cell editing.          Optional, and defaults to <code>"programmatic"</code>.  Can be used by the
     *          <code>callback</code> method to perform custom actions such as navigation when the          save completes.
     * @param callback Callback to fire on completion of the saving process.                                    If no edits were made or
     * client-side validation fails                                    the callback will be fired synchronously at the end of
     * this                                    method.<br>                                    Takes the following parameters:  
     * <br>- rowNum <i>(Number) edited row number</i>                                    <br>- colNum <i>(Number) edited column
     * number</i>                                    <br>- editCompletionEvent <i>(EditCompletionEvent) event                  
     * passed in (defaults to <code>"programmatic"</code>)</i>                                    <br>- success <i>(boolean)
     * false if the save was unable to                                      complete due to a validation failure or server-side
     *                                      error.</i>.
     * See {@link com.smartgwt.client.docs.Callback Callback}
     * @param rowNum Which row should be saved. If unspecified the current edit row                            is saved by default. Note that
     * if there is no current edit row                            this method will no op.
     * @see com.smartgwt.client.widgets.grid.ListGrid#endEditing
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void saveEdits(EditCompletionEvent editCompletionEvent, String callback, int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "saveEdits", "EditCompletionEvent,String,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.saveEdits(editCompletionEvent == null ? null : editCompletionEvent.@com.smartgwt.client.types.EditCompletionEvent::getValue()(), callback, rowNum);
    }-*/;
	
	/**
     * Will scroll the listGrid body such that the specified cell is visible close to the center of the viewport. <P> This
     * method has no effect if the cell is already visible in the viewport. <P> When scrolling vertically, this will cause data
     * to be automatically loaded if {@link com.smartgwt.client.widgets.grid.ListGrid#getDataFetchMode paging is active} and
     * you scroll into an area of the data that isn't loaded.  Only rows around the target row will be loaded, not all
     * intervening rows.  See also {@link com.smartgwt.client.data.ResultSet}. <P> Scrolling into an undrawn area will cause
     * the body area of the grid to redraw, but this won't happen synchronously unless you explicitly call redraw().  Scrolling
     * into an area of the data that is not yet loaded will never synchronously draw new rows, even if you call redraw() - wait
     * for {@link com.smartgwt.client.widgets.grid.ListGrid#addDataArrivedHandler ListGrid.dataArrived()} to be notified when
     * new rows have been loaded. <P> Calling this method with a row index larger than the current dataset will clamp to the
     * end of the dataset (similarly horizontal scrolling will clamp to the last column). <P> If a call to this method is made
     * while data is still loading, such that the last row of the dataset is not yet known the grid will attempt to compensate
     * by scrolling the record into view when data arrives, if it is valid. For better control over scrolling, developers
     * should consider calling <code>scrollToRow()</code> or <code>scrollToCell</code> from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addDataArrivedHandler ListGrid.dataArrived()} if data is still loading. <P>
     * With mixed-height rows it will only reliably work if virtualScrolling is enabled.
     * @param rowNum Row index of the cell to scroll into view
     * @param colNum Column index of the cell to scroll into view
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToCell(int rowNum, int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToCell", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToCell(rowNum, colNum);
    }-*/;

    /**
     * @see ListGrid#scrollToCell
     */
    public void scrollToCell(int rowNum, int colNum, Alignment xPosition){
        scrollToCell(rowNum, colNum, xPosition, null);
    }

	/**
     * Will scroll the listGrid body such that the specified cell is visible close to the center of the viewport. <P> This
     * method has no effect if the cell is already visible in the viewport. <P> When scrolling vertically, this will cause data
     * to be automatically loaded if {@link com.smartgwt.client.widgets.grid.ListGrid#getDataFetchMode paging is active} and
     * you scroll into an area of the data that isn't loaded.  Only rows around the target row will be loaded, not all
     * intervening rows.  See also {@link com.smartgwt.client.data.ResultSet}. <P> Scrolling into an undrawn area will cause
     * the body area of the grid to redraw, but this won't happen synchronously unless you explicitly call redraw().  Scrolling
     * into an area of the data that is not yet loaded will never synchronously draw new rows, even if you call redraw() - wait
     * for {@link com.smartgwt.client.widgets.grid.ListGrid#addDataArrivedHandler ListGrid.dataArrived()} to be notified when
     * new rows have been loaded. <P> Calling this method with a row index larger than the current dataset will clamp to the
     * end of the dataset (similarly horizontal scrolling will clamp to the last column). <P> If a call to this method is made
     * while data is still loading, such that the last row of the dataset is not yet known the grid will attempt to compensate
     * by scrolling the record into view when data arrives, if it is valid. For better control over scrolling, developers
     * should consider calling <code>scrollToRow()</code> or <code>scrollToCell</code> from {@link
     * com.smartgwt.client.widgets.grid.ListGrid#addDataArrivedHandler ListGrid.dataArrived()} if data is still loading. <P>
     * With mixed-height rows it will only reliably work if virtualScrolling is enabled.
     * @param rowNum Row index of the cell to scroll into view
     * @param colNum Column index of the cell to scroll into view
     * @param xPosition Horizontal position of scrolled cell (optional)
     * @param yPosition Vertical position of scrolled cell (optional)
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToCell(int rowNum, int colNum, Alignment xPosition, VerticalAlignment yPosition) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToCell", "int,int,Alignment,VerticalAlignment");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToCell(rowNum, colNum, xPosition == null ? null : xPosition.@com.smartgwt.client.types.Alignment::getValue()(), yPosition == null ? null : yPosition.@com.smartgwt.client.types.VerticalAlignment::getValue()());
    }-*/;
	
	/**
     * Scroll the grid to specified column such that the row appears near the center of the viewport. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#scrollToCell scrollToCell()} for a full description of how this method
     * interacts with incremental loading and rendering of data.
     * @param colNum Index of the column to scroll into view
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToColumn(int colNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToColumn", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToColumn(colNum);
    }-*/;

	/**
     * Scroll the grid to specified column such that the row appears near the center of the viewport. <P> See {@link
     * com.smartgwt.client.widgets.grid.ListGrid#scrollToCell scrollToCell()} for a full description of how this method
     * interacts with incremental loading and rendering of data.
     * @param colNum Index of the column to scroll into view
     * @param xPosition Horizontal position of scrolled column (optional)
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToColumn(int colNum, Alignment xPosition) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToColumn", "int,Alignment");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToColumn(colNum, xPosition == null ? null : xPosition.@com.smartgwt.client.types.Alignment::getValue()());
    }-*/;
	
	/**
     * Scroll the grid to specified row such that the row appears near the center of the viewport, loading data if necessary.
     * <P> See {@link com.smartgwt.client.widgets.grid.ListGrid#scrollToCell scrollToCell()} for a full description of how this
     * method interacts with incremental loading and rendering of data.
     * @param rowNum Row index of the cell to scroll into view
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToRow(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToRow", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToRow(rowNum);
    }-*/;

	/**
     * Scroll the grid to specified row such that the row appears near the center of the viewport, loading data if necessary.
     * <P> See {@link com.smartgwt.client.widgets.grid.ListGrid#scrollToCell scrollToCell()} for a full description of how this
     * method interacts with incremental loading and rendering of data.
     * @param rowNum Row index of the cell to scroll into view
     * @param yPosition Vertical position of scrolled row (optional)
     * @see com.smartgwt.client.docs.Scrolling Scrolling overview and related methods
     */
    public native void scrollToRow(int rowNum, VerticalAlignment yPosition) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "scrollToRow", "int,VerticalAlignment");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.scrollToRow(rowNum, yPosition == null ? null : yPosition.@com.smartgwt.client.types.VerticalAlignment::getValue()());
    }-*/;
	
    /**
     * Add a selectionChanged handler.
     * <p>
     * Called when (row-based) selection changes within this grid. Note this method fires for each record for which selection
     * is modified - so when a user clicks inside a grid this method will typically fire twice (once for the old record being
     * deselected, and once for the new record being selected). <P> NOTE: For updating other components based on selections or
     * triggering selection-oriented events within an application, see the {@link
     * com.smartgwt.client.widgets.DataBoundComponent#selectionUpdated selectionUpdated()} event which is likely more suitable.
     * Calls to {@link com.smartgwt.client.widgets.grid.ListGrid#getSelection getSelection()} from within this event may not
     * return a valid set of selected records if the event has been triggered by a call to {@link
     * com.smartgwt.client.widgets.DataBoundComponent#selectAllRecords selectAllRecords()} or {@link
     * com.smartgwt.client.widgets.DataBoundComponent#deselectAllRecords deselectAllRecords()} - in this case use the {@link
     * com.smartgwt.client.widgets.DataBoundComponent#selectionUpdated selectionUpdated()} event instead.
     *
     * @param handler the selectionChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSelectionChangedHandler(com.smartgwt.client.widgets.grid.events.SelectionChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SelectionEvent.getType()) == 0) setupSelectionChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SelectionEvent.getType());
    }

    private native void setupSelectionChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var selectionChanged = $entry(function(){
            var param = {"_this": this, "record" : arguments[0], "state" : arguments[1]};
            var event = @com.smartgwt.client.widgets.grid.events.SelectionEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSelectionChangedEvent()();
            if (hasDefaultHandler) this.Super("selectionChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("selectionChanged"));
            obj.addProperties({selectionChanged:  selectionChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("selectionChanged"));
            obj.selectionChanged =  selectionChanged             ;
        }
    }-*/;

    private void handleTearDownSelectionChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SelectionEvent.getType()) == 0) tearDownSelectionChangedEvent();
    }

    private native void tearDownSelectionChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("selectionChanged")) delete obj.selectionChanged;
    }-*/;

    /**
     * Add a selectionUpdated handler.
     * <p>
     * Called when the selection changes. Note that this method fires exactly once for any given change to the selection unlike
     * the {@link com.smartgwt.client.widgets.grid.ListGrid#addSelectionChangedHandler selectionChanged} event. <P> This event
     * is fired once after selection/deselection has completed. The result is one event per mouse-down event. For a drag
     * selection there will be two events fired: one when the first record is selected and one when the range is completed. <P>
     * This event is also fired when selection is updated by a direct call to one of the <code>DataBoundComponent</code>
     * select/deselect methods. Calls on the Selection object <b>do not</b> trigger this event.
     *
     * @param handler the selectionUpdated handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSelectionUpdatedHandler(com.smartgwt.client.widgets.grid.events.SelectionUpdatedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SelectionUpdatedEvent.getType()) == 0) setupSelectionUpdatedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SelectionUpdatedEvent.getType());
    }

    private native void setupSelectionUpdatedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var selectionUpdated = $entry(function(){
            var param = {"_this": this, "record" : arguments[0], "recordList" : arguments[1]};
            var event = @com.smartgwt.client.widgets.grid.events.SelectionUpdatedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSelectionUpdatedEvent()();
            if (hasDefaultHandler) this.Super("selectionUpdated", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("selectionUpdated"));
            obj.addProperties({selectionUpdated:  selectionUpdated              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("selectionUpdated"));
            obj.selectionUpdated =  selectionUpdated             ;
        }
    }-*/;

    private void handleTearDownSelectionUpdatedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SelectionUpdatedEvent.getType()) == 0) tearDownSelectionUpdatedEvent();
    }

    private native void tearDownSelectionUpdatedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("selectionUpdated")) delete obj.selectionUpdated;
    }-*/;

	/**
     * Select a contiguous range of records by index
     * @param startRow start of selection range
     * @param endRow end of selection range (non-inclusive)
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native void selectRange(int startRow, int endRow) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "selectRange", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectRange(startRow, endRow);
    }-*/;

	/**
     * Select a contiguous range of records by index
     * @param startRow start of selection range
     * @param endRow end of selection range (non-inclusive)
     * @param newState new selection state (if null, defaults to true)
     * @see com.smartgwt.client.docs.Selection Selection overview and related methods
     */
    public native void selectRange(int startRow, int endRow, boolean newState) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "selectRange", "int,int,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectRange(startRow, endRow, newState);
    }-*/;
	
	/**
     * Setter for {@link com.smartgwt.client.widgets.grid.ListGridField#getAutoFitWidth ListGridField.autoFitWidth}. Enables or
     * disables dynamic autoFitWidth behavior on the specified field. Note if the field is currently autoFitWidth:true, and
     * this method is disabling autoFit, the field will not be resized by default - if you wish to resize to an explicit width,
     * use {@link com.smartgwt.client.widgets.grid.ListGrid#resizeField resizeField()}.
     * @param fieldName field to auto-fit
     * @param autoFit Should autoFitWidth be enabled or disabled?
     */
    public native void setAutoFitWidth(String fieldName, boolean autoFit) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setAutoFitWidth", "String,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setAutoFitWidth(fieldName, autoFit);
    }-*/;

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, by default
     * any created record components are destroyed once they are no longer in use (for example, if the ListGrid as a whole is
     * destroyed).  This method may be used to suppress this behavior for some component. Typical usage might call this method
     * as part of {@link com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent createRecordComponent()} to suppress
     * this behavior.
     * @param component component in question.
     * @param dontAutoDestroy If true, the component will not be destroyed automatically when   the grid is destroyed
     */
    public native void setDontAutoDestroyComponent(Canvas component, boolean dontAutoDestroy) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setDontAutoDestroyComponent", "Canvas,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setDontAutoDestroyComponent(component == null ? null : component.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), dontAutoDestroy);
    }-*/;

	/**
     * This method sets up a set of editValues for some row / cell.  It differs from 'setEditValue()' in that:<br> &nbsp;- it
     * takes values for multiple fields<br> &nbsp;- it clears out any previous edit values for the record<br>
     * @param rowNum Row number for the record being edited
     * @param values New values for the row
     */
    public native void setEditValues(int rowNum, Map values) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setEditValues", "int,Map");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValues(rowNum, values == null ? null : @com.smartgwt.client.util.JSOHelper::convertMapToJavascriptObject(Ljava/util/Map;)(values));
    }-*/;

	/**
     * Method to update properties on a field's header button at runtime. This property allows customization of any settable
     * properties on the ListGridField's header button after it has been generated.  Note that the provided Canvas should only
     * have the minimal needed properties set on it, and should not be a Canvas that's already been drawn or added as the child
     * of another widget.
     * @param name Field to update
     * @param properties new properties to apply to the header button
     */
    public native void setFieldButtonProperties(String name, Canvas properties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldButtonProperties", "String,Canvas");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if (properties != null) {
            if (properties.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
                @com.smartgwt.client.util.ConfigUtil::warnOfPreConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldButtonProperties", "Canvas");
            }
            properties.@com.smartgwt.client.widgets.BaseWidget::setConfigOnly(Z)(true);
        }
        self.setFieldButtonProperties(name,
			properties == null ? null : @com.smartgwt.client.util.JSOHelper::cleanProperties(Lcom/google/gwt/core/client/JavaScriptObject;Z)(properties.@com.smartgwt.client.widgets.BaseWidget::getConfig()(),true));
    }-*/;

	/**
     * Change the {@link com.smartgwt.client.widgets.grid.ListGridField#getCellIcon ListGridField.cellIcon} for a field after
     * the grid is created
     * @param fieldName field to update
     * @param cellIcon new cellIcon for the field.
     * See {@link com.smartgwt.client.docs.SCImgURL SCImgURL}
     */
    public native void setFieldCellIcon(String fieldName, String cellIcon) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldCellIcon", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldCellIcon(fieldName, cellIcon);
    }-*/;

	/**
     * Set a validation error for some cell.
     * @param rowNum row index of cell to add validation error for
     * @param fieldName col index or field name of cell to add validation error for
     * @param errorMessage validation error/errors for the cell.
     * @see com.smartgwt.client.widgets.grid.ListGrid#getCellErrors
     * @see com.smartgwt.client.widgets.grid.ListGrid#setRowErrors
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native void setFieldError(int rowNum, String fieldName, String errorMessage) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldError", "int,String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldError(rowNum, fieldName, errorMessage);
    }-*/;

	/**
     * Update the {@link com.smartgwt.client.widgets.grid.ListGridField#getHeaderBaseStyle ListGridField.headerBaseStyle} for a
     * field within the grid at runtime.
     * @param name name of the field.
     * @param newStyle new baseStyle for the field header.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     */
    public native void setFieldHeaderBaseStyle(String name, String newStyle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldHeaderBaseStyle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldHeaderBaseStyle(name, newStyle);
    }-*/;

	/**
     * Update the {@link com.smartgwt.client.widgets.grid.ListGridField#getHeaderTitleStyle ListGridField.headerTitleStyle} for
     * a field within the grid at runtime.
     * @param name name of the field.
     * @param newStyle new titleTyle for the field header.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     */
    public native void setFieldHeaderTitleStyle(String name, String newStyle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldHeaderTitleStyle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldHeaderTitleStyle(name, newStyle);
    }-*/;

	/**
     * Change the {@link com.smartgwt.client.widgets.grid.ListGridField#getIcon ListGridField.icon} for a field after the grid
     * is created
     * @param fieldName field to update
     * @param icon icon for the field.
     * See {@link com.smartgwt.client.docs.SCImgURL SCImgURL}
     */
    public native void setFieldIcon(String fieldName, String icon) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldIcon", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldIcon(fieldName, icon);
    }-*/;

	/**
     * Updates {@link com.smartgwt.client.widgets.grid.ListGridField#getMaxWidth ListGridField.maxWidth} for the specified
     * field and redraws the associated column if required.
     * @param fieldNum name of the field, or index.
     * @param width 
     * @see com.smartgwt.client.widgets.grid.ListGridField#getMaxWidth
     */
    public native void setFieldMaxWidth(int fieldNum, int width) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldMaxWidth", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldMaxWidth(fieldNum, width);
    }-*/;

	/**
     * Updates {@link com.smartgwt.client.widgets.grid.ListGridField#getMinWidth ListGridField.minWidth} for the specified
     * field and redraws the associated column if required.
     * @param fieldNum name of the field, or index.
     * @param width 
     * @see com.smartgwt.client.widgets.grid.ListGridField#getMinWidth
     */
    public native void setFieldMinWidth(int fieldNum, int width) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldMinWidth", "int,int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldMinWidth(fieldNum, width);
    }-*/;

	/**
     * Dynamically set properties for a particular field. This method will update the fields header-button without having to
     * explicitly reset the fields in the grid.   The passed-in {@link com.smartgwt.client.widgets.grid.ListGridField} should
     * contain just the minimal properties you want to change; do not take the original ListGridField, modify it, and just pass
     * that to this function. <P>  NOTE: Where explicit setters exist for field properties (such as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#resizeField resizeField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFieldTitle setFieldTitle()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFieldIcon setFieldIcon()}, etc.) these should be used instead.
     * @param fieldNum name of the field, or index.
     * @param properties properties to apply to the header
     */
    public native void setFieldProperties(int fieldNum, ListGridField properties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldProperties", "int,ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldProperties(fieldNum,
			$wnd.isc.addProperties({},properties.@com.smartgwt.client.core.DataClass::getJsObj()()));
    }-*/;

	/**
     * Dynamically set properties for a particular field. This method will update the fields header-button without having to
     * explicitly reset the fields in the grid.   The passed-in {@link com.smartgwt.client.widgets.grid.ListGridField} should
     * contain just the minimal properties you want to change; do not take the original ListGridField, modify it, and just pass
     * that to this function. <P>  NOTE: Where explicit setters exist for field properties (such as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#resizeField resizeField()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFieldTitle setFieldTitle()}, {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setFieldIcon setFieldIcon()}, etc.) these should be used instead.
     * @param fieldNum name of the field, or index.
     * @param properties properties to apply to the header
     */
    public native void setFieldProperties(String fieldNum, ListGridField properties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldProperties", "String,ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldProperties(fieldNum,
			$wnd.isc.addProperties({},properties.@com.smartgwt.client.core.DataClass::getJsObj()()));
    }-*/;

	/**
     * Change the title of a field after the grid is created.
     * @param fieldNum name of the field, or index.
     * @param title new title
     */
    public native void setFieldTitle(int fieldNum, String title) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldTitle", "int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldTitle(fieldNum, title);
    }-*/;

	/**
     * Change the title of a field after the grid is created.
     * @param fieldNum name of the field, or index.
     * @param title new title
     */
    public native void setFieldTitle(String fieldNum, String title) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFieldTitle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setFieldTitle(fieldNum, title);
    }-*/;

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, this method will
     * update the criteria shown in the <code>filterEditor</code> without performing a filter.
     * @param criteria New criteria to show
     */
    public native void setFilterEditorCriteria(Criteria criteria) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setFilterEditorCriteria", "Criteria");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
	    if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteria.@com.smartgwt.client.data.Criterion::getJsObj()(),"_constructor","AdvancedCriteria");
	    }
        self.setFilterEditorCriteria(criteria == null ? null : criteria.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Update the {@link com.smartgwt.client.widgets.grid.HeaderSpan#getHeaderBaseStyle HeaderSpan.headerBaseStyle} for a span
     * within the grid at runtime.
     * @param name name of the headerSpan, as specified via {@link com.smartgwt.client.widgets.grid.HeaderSpan#getName HeaderSpan.name}.
     * @param newStyle new baseStyle for the headerSpan.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     */
    public native void setHeaderSpanBaseStyle(String name, String newStyle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanBaseStyle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setHeaderSpanBaseStyle(name, newStyle);
    }-*/;

	/**
     * Method to update properties on a headerSpan's header button at runtime. This property allows customization of any
     * settable properties on the HeaderSpan's header button after it has been generated.
     * @param name {@link com.smartgwt.client.widgets.grid.HeaderSpan#getName name} of span to update
     * @param properties new properties to apply to the header button
     */
    public native void setHeaderSpanButtonProperties(String name, Canvas properties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanButtonProperties", "String,Canvas");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if (properties != null) {
            if (properties.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
                @com.smartgwt.client.util.ConfigUtil::warnOfPreConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanButtonProperties", "Canvas");
            }
            properties.@com.smartgwt.client.widgets.BaseWidget::setConfigOnly(Z)(true);
        }
        self.setHeaderSpanButtonProperties(name,
			properties == null ? null : @com.smartgwt.client.util.JSOHelper::cleanProperties(Lcom/google/gwt/core/client/JavaScriptObject;Z)(properties.@com.smartgwt.client.widgets.BaseWidget::getConfig()(),true));
    }-*/;

	/**
     * Update the headerTitle of a {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpan} dynamically.
     * @param name name of the headerSpan, as specified via {@link com.smartgwt.client.widgets.grid.HeaderSpan#getName HeaderSpan.name}.
     * @param newTitle new headerTitle for the headerSpan
     */
    public native void setHeaderSpanHeaderTitle(String name, String newTitle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanHeaderTitle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setHeaderSpanHeaderTitle(name, newTitle);
    }-*/;

	/**
     * Update the title of a {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderSpans headerSpan} dynamically.
     * @param name name of the headerSpan, as specified via {@link com.smartgwt.client.widgets.grid.HeaderSpan#getName HeaderSpan.name}.
     * @param newTitle new title for the headerSpan
     */
    public native void setHeaderSpanTitle(String name, String newTitle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanTitle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setHeaderSpanTitle(name, newTitle);
    }-*/;

	/**
     * Update the {@link com.smartgwt.client.widgets.grid.HeaderSpan#getHeaderTitleStyle HeaderSpan.headerTitleStyle} for a
     * span within the grid at runtime.
     * @param name name of the headerSpan, as specified via {@link com.smartgwt.client.widgets.grid.HeaderSpan#getName HeaderSpan.name}.
     * @param newTitle new titleStyle for the headerSpan.
     * See {@link com.smartgwt.client.docs.CSSStyleName CSSStyleName}
     */
    public native void setHeaderSpanTitleStyle(String name, String newTitle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setHeaderSpanTitleStyle", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setHeaderSpanTitleStyle(name, newTitle);
    }-*/;

	/**
     * Set the validation errors for some row (replacing any pre-existent validation errors) <P> Note that in the case of a
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped listGrid}, or a  {@link
     * com.smartgwt.client.widgets.tree.TreeGrid}, some records may be hidden form view (part of a collapsed group or parent
     * folder). In this case there is no meaningful row number associated with a record. This method cannot be called on such
     * rows - developers should make the row visible first. This is by design - users should always be able to see errors.
     * @param rowNum row to add validation error for
     * @param errors validation errors for the row in the format                          <code>{fieldName:errorMessage, ...}</code> <br>or
     * <br>                          <code>{fieldName:[errorMessage1, errorMessage2], ...}</code>
     * @see com.smartgwt.client.widgets.grid.ListGrid#getRowErrors
     * @see com.smartgwt.client.widgets.grid.ListGrid#setFieldError
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native void setRowErrors(int rowNum, Object errors) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setRowErrors", "int,Object");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setRowErrors(rowNum, errors);
    }-*/;

    /**
     * Add a setSort handler.
     * <p>
     * Optional notification fired when either user or framework code calls 
     * {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()}.  This notification fires before the default
     * behavior; 
     *  
     *  use <code>event.cancel()</code> to cancel the default behavior.  Note,
     *  the notification is fired before the default functionality, but <em>after</em> prechecks 
     *  have completed; your method will only be called if the default behavior would have been
     *  called.  For example, if there are pending edits and the user does not confirm that these 
     *  should be saved, normal sorting would not have gone ahead, so equally your handler will 
     *  not be called.
     *  <P>
     *  The default <code>setSort()</code> method does two things to reflect the set of 
     *  {@link com.smartgwt.client.data.SortSpecifier sortSpecifier}s passed to it:<ul>
     *  <li>Change the grid UI (show directional arrows, numerals to indicate sort priority, etc)</li>
     *  <li>Actually sort the grid data</li>
     *  </ul>
     *  If your reason for implementing a custom <code>setSortHandler()</code> is to inhibit or 
     *  replace one of those behaviors, you should cancel the default behavior and directly invoke
     *  just that part of it you require.  The following implementation will replicate the default
     *  behavior:
     *  <pre>
     *    grid.addSetSortHandler(new SetSortHandler() {
     *        public void onSetSort(SetSortEvent event) {
     *            displaySort(event.getSortSpecifiers());
     *            applySortToData(event.getSortSpecifiers());
     *            event.cancel();  // Prevent the framework from running its own default impl
     *        }
     *    });</pre>
     * 
     * 
     *
     * @param handler the setSort handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSetSortHandler(com.smartgwt.client.widgets.grid.events.SetSortHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SetSortEvent.getType()) == 0) setupSetSortEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SetSortEvent.getType());
    }

    private native void setupSetSortEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var setSortHandler = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.SetSortEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSetSortEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("setSortHandler"));
            obj.addProperties({setSortHandler: 
                function () {
                    var param = {"_this": this, "sortSpecifiers" : arguments[0]};
                    var ret = setSortHandler(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("setSortHandler", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("setSortHandler"));
            obj.setSortHandler = 
                function () {
                    var param = {"_this": this, "sortSpecifiers" : arguments[0]};
                    var ret = setSortHandler(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("setSortHandler", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownSetSortEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SetSortEvent.getType()) == 0) tearDownSetSortEvent();
    }

    private native void tearDownSetSortEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("setSortHandler")) delete obj.setSortHandler;
    }-*/;

	/**
     * Updates the user formula of the supplied field.  This method is preferred over setting the the field property directly
     * since it allows any component dependencies to be updated.  If the formula is not passed or undefined, it is assumed it
     * has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field <li>the common formula variable =&gt; field name map
     * maintained by the component for calls to the FormulaBuilder</ul>
     * @param field field owning the userFormula
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormula(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormula", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormula(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Updates the user formula of the supplied field.  This method is preferred over setting the the field property directly
     * since it allows any component dependencies to be updated.  If the formula is not passed or undefined, it is assumed it
     * has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field <li>the common formula variable =&gt; field name map
     * maintained by the component for calls to the FormulaBuilder</ul>
     * @param field field owning the userFormula
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormula(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormula", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormula(field);
    }-*/;

	/**
     * Updates the user formula of the supplied field.  This method is preferred over setting the the field property directly
     * since it allows any component dependencies to be updated.  If the formula is not passed or undefined, it is assumed it
     * has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field <li>the common formula variable =&gt; field name map
     * maintained by the component for calls to the FormulaBuilder</ul>
     * @param field field owning the userFormula
     * @param userFormula optional formula to install
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormula(ListGridField field, UserFormula userFormula) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormula", "ListGridField,UserFormula");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormula(field.@com.smartgwt.client.core.DataClass::getJsObj()(), userFormula == null ? null : userFormula.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Updates the user formula text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the formula text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field</ul>
     * @param field field owning the userFormula
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormulaText(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormulaText", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormulaText(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Updates the user formula text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the formula text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field</ul>
     * @param field field owning the userFormula
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormulaText(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormulaText", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormulaText(field);
    }-*/;

	/**
     * Updates the user formula text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the formula text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the formula for this field</ul>
     * @param field field owning the userFormula
     * @param text optional formula text to install
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserFormula
     */
    public native void setUserFormulaText(ListGridField field, String text) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserFormulaText", "ListGridField,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserFormulaText(field.@com.smartgwt.client.core.DataClass::getJsObj()(), text);
    }-*/;
	
	/**
     * Updates the user summary of the supplied field.  This method is preferred over setting the field property directly since
     * it allows any component dependencies to be updated.  If the summary is not passed or undefined, it is assumed it has
     * already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummary(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummary", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummary(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Updates the user summary of the supplied field.  This method is preferred over setting the field property directly since
     * it allows any component dependencies to be updated.  If the summary is not passed or undefined, it is assumed it has
     * already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummary(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummary", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummary(field);
    }-*/;

	/**
     * Updates the user summary of the supplied field.  This method is preferred over setting the field property directly since
     * it allows any component dependencies to be updated.  If the summary is not passed or undefined, it is assumed it has
     * already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @param userSummary optional summary to install
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummary(ListGridField field, UserSummary userSummary) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummary", "ListGridField,UserSummary");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummary(field.@com.smartgwt.client.core.DataClass::getJsObj()(), userSummary == null ? null : userSummary.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * Updates the user summary text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the summary text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummaryText(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummaryText", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummaryText(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Updates the user summary text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the summary text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummaryText(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummaryText", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummaryText(field);
    }-*/;

	/**
     * Updates the user summary text of the supplied field.  This method is preferred over setting the text property directly
     * since it allows any component dependencies to be updated.  If the summary text is not passed or undefined, it is assumed
     * it has already been updated and only the dependency propagation logic will run.<P> Known component dependencies are:<ul>
     * <li>the cached record values of the summary for this field</ul>
     * @param field field owning the userSummary
     * @param text optional summary text to install
     * @see com.smartgwt.client.widgets.grid.ListGridField#getUserSummary
     */
    public native void setUserSummaryText(ListGridField field, String text) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setUserSummaryText", "ListGridField,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setUserSummaryText(field.@com.smartgwt.client.core.DataClass::getJsObj()(), text);
    }-*/;
	
	/**
     * When assembling a value for a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddSummaryFields summary field}, if
     * a referenced field is hilited, should the hilite HTML be included in the summary field value? <P> Example use case:
     * Consider a grid containing a numeric field, and a summary field which contains some string value, plus the contents of
     * the numeric field. If a hilite is defined for the grid which turns the numeric field text red when the value is
     * negative, this property will govern whether the number will also be rendered in red within the summary field cells. Any
     * other text in the summary field cells would not be effected by this hilite. <P> Default implementation returns {@link
     * com.smartgwt.client.widgets.DataBoundComponent#getIncludeHilitesInSummaryFields includeHilitesInSummaryFields}. <P> To
     * control hilites showing in group summaries, see {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHilitesInGroupSummary showHilitesInGroupSummary}.
     * @param summaryFieldName name of the summary field
     * @param usedFieldName name of the field referenced by this summary
     *
     * @return Return true to include hilites from the used field in the generated   summary field value.
     */
    public native boolean shouldIncludeHiliteInSummaryField(String summaryFieldName, String usedFieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "shouldIncludeHiliteInSummaryField", "String,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.shouldIncludeHiliteInSummaryField(summaryFieldName, usedFieldName);
        return ret == null ? false : ret;
    }-*/;

	/**
     * Shows an additional field near the beginning of the field list (after any {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRowNumbers row number} field) that can be dragged to drag the current
     * selection.  This feature is useful in {@link com.smartgwt.client.util.Browser#isTouch touch environments} where both
     * touch scrolling and dragging are needed on the same grid, and allows scrolling to be triggered on the other fields so
     * that both operations are available.  Targeted touch environments include both mobile devices, and Windows hardware that
     * supports {@link com.smartgwt.client.util.Browser#supportsDualInput Dual Input Mode} such as Microsoft Surface. <P> Note
     * that the {@link com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField drag handle field} will never be shown
     * unless  {@link com.smartgwt.client.widgets.grid.ListGrid#getCanReorderRecords canReorderRecords} or {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanDragRecordsOut canDragRecordsOut} are true. <P> In IE11 or Microsoft
     * Edge, dragging a record in a grid may not be possible using a touch device without enabling drag handles, or disabling
     * native touch scrolling by setting &nbsp;<code>window.isc_useNativeTouchScrolling = false</code>&nbsp; before Smart GWT
     * is loaded. <P> <h4>Background</h4> <P> One alternative to adding a drag handle field would be to use long touch to start
     * a drag (with normal touch triggering scrolling).  However, this is unsupportable in IE11 or Edge on Microsoft Surface
     * (with native scrolling) because native scrolling cannot be canceled on the fly using Event.preventDefault(), but instead
     * must be disabled by applying the appropriate CSS at rendering time.  (Such limitations are not present elsewhere, such
     * as on Android or IPhone browsers.) <P> For more details, some links are provided below.  Note that while IE10 is
     * mentioned in some of the links, the reasoning is still relevant now for IE11 and Edge as the limitations remain: <ul>
     * <li><a href='https://quirksmode.org/mobile/default.html' target='_blank'>Cross-browser support of touchMove</a> <li><a
     * href='https://stackoverflow.com/questions/26218146/pointer-events-ie11-surface' target='_blank'>preventDefault() doesn't
     * work in IE11 on MS Surface</a> <li><a
     * href='https://stackoverflow.com/questions/49299496/html5-pointermove-touchmove-not-working-in-microsoft-edge'
     * target='_blank'>preventDefault() doesn't work in Edge on MS Surface</a> <li><a
     * href='https://web.archive.org/web/20160309214328/https://connect.microsoft.com/IE/feedback/details/767646/ms-touch-action-does-not-allow-a-way-to-programmatically-prevent-default-touch-behavior'
     * target='_blank'>preventDefault() failure reported to Microsoft against IE10</a> </ul>
     * @see com.smartgwt.client.widgets.grid.ListGrid#hideDragHandles
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragHandleField
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragHandleIcon
     * @see com.smartgwt.client.widgets.grid.ListGrid#getDragHandleIconSize
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_interaction_touch_drag" target="examples">Touch Drag Example</a>
     */
    public native void showDragHandles() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showDragHandles", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showDragHandles();
    }-*/;

	/**
     * Force a field to be shown. This method does not add new fields to the grid, it simply changes field visibility. If a
     * field.showIf expression exists, it will be destroyed. <P> Note: for showing multiple fields it is more efficient to call
     * {@link com.smartgwt.client.widgets.grid.ListGrid#showFields showFields()} than to call this method repeatedly.
     * @param field field to show
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showField(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showField(field);
    }-*/;

	/**
     * Force a field to be shown. This method does not add new fields to the grid, it simply changes field visibility. If a
     * field.showIf expression exists, it will be destroyed. <P> Note: for showing multiple fields it is more efficient to call
     * {@link com.smartgwt.client.widgets.grid.ListGrid#showFields showFields()} than to call this method repeatedly.
     * @param field field to show
     * @param suppressRelayout If passed, don't resize non-explicitly sized columns                                       to fill the available space.
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showField(String field, boolean suppressRelayout) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showField", "String,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showField(field, suppressRelayout);
    }-*/;
	
	/**
     * Force an array of fields to be shown. This method does not add new fields to the grid, it simply changes field
     * visibility. If a field.showIf expression exists, it will be destroyed. <P> Note: for showing multiple fields it is more
     * efficient to call this method than to call {@link com.smartgwt.client.widgets.grid.ListGrid#showField showField()}
     * repeatedly.
     * @param field Fields to show.
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showFields(String... field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showFields", "String...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(field));
    }-*/;

	/**
     * Force an array of fields to be shown. This method does not add new fields to the grid, it simply changes field
     * visibility. If a field.showIf expression exists, it will be destroyed. <P> Note: for showing multiple fields it is more
     * efficient to call this method than to call {@link com.smartgwt.client.widgets.grid.ListGrid#showField showField()}
     * repeatedly.
     * @param field Fields to show.
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showFields(ListGridField... field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showFields", "ListGridField...");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(field));
    }-*/;

	/**
     * Force an array of fields to be shown. This method does not add new fields to the grid, it simply changes field
     * visibility. If a field.showIf expression exists, it will be destroyed. <P> Note: for showing multiple fields it is more
     * efficient to call this method than to call {@link com.smartgwt.client.widgets.grid.ListGrid#showField showField()}
     * repeatedly.
     * @param field Fields to show.
     * @param suppressRelayout If passed, don't resize non-explicitly sized columns                                       to fill the available space.
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showFields(String[] field, boolean suppressRelayout) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "showFields", "String[],boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.showFields(@com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(field), suppressRelayout);
    }-*/;
	
	/**
     * Sort this grid's data, with the option to explicitly specify a single field to sort by and sort direction. <P> If
     * sortField is not provided and listGrid.sortField is undefined, the data will be sorted by the first sortable column
     * according to {@link com.smartgwt.client.widgets.grid.ListGridField#getSortDirection ListGridField.sortDirection} if
     * specified, or {@link com.smartgwt.client.widgets.grid.ListGrid#getSortDirection sortDirection}. <P> ListGrids also
     * support multiple-field sorting. See {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} for details. <P>
     * Note that for editable grids, sorting is performed by underlying data values, not for unsaved {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditValues pending edit values}.
     *
     * @return sorting worked
     * @see com.smartgwt.client.types.SortDirection
     */
    public native Boolean sort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "sort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.sort();
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * @see ListGrid#sort
     */
    public Boolean sort(String sortField){
        return sort(sortField, null);
    }

	/**
     * Sort this grid's data, with the option to explicitly specify a single field to sort by and sort direction. <P> If
     * sortField is not provided and listGrid.sortField is undefined, the data will be sorted by the first sortable column
     * according to {@link com.smartgwt.client.widgets.grid.ListGridField#getSortDirection ListGridField.sortDirection} if
     * specified, or {@link com.smartgwt.client.widgets.grid.ListGrid#getSortDirection sortDirection}. <P> ListGrids also
     * support multiple-field sorting. See {@link com.smartgwt.client.widgets.grid.ListGrid#setSort setSort()} for details. <P>
     * Note that for editable grids, sorting is performed by underlying data values, not for unsaved {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getEditValues pending edit values}.
     * @param sortField the field name or column number to sort by
     * @param sortDirection the direction to sort in
     *
     * @return sorting worked
     * @see com.smartgwt.client.types.SortDirection
     */
    public native Boolean sort(String sortField, SortDirection sortDirection) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "sort", "String,SortDirection");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.sort(sortField, sortDirection == null ? null : sortDirection.@com.smartgwt.client.types.SortDirection::getValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;
	
    /**
     * Add a sortChanged handler.
     * <p>
     * Notification method executed when the {@link com.smartgwt.client.widgets.grid.ListGrid#setSort sort specifiers} change
     * for this grid.
     *
     * @param handler the sortChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSortChangedHandler(com.smartgwt.client.widgets.grid.events.SortChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SortEvent.getType()) == 0) setupSortChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SortEvent.getType());
    }

    private native void setupSortChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var sortChanged = $entry(function(){
            var param = {"_this": this, "sortSpecifiers" : arguments[0]};
            var event = @com.smartgwt.client.widgets.grid.events.SortEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSortChangedEvent()();
            if (hasDefaultHandler) this.Super("sortChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("sortChanged"));
            obj.addProperties({sortChanged:  sortChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("sortChanged"));
            obj.sortChanged =  sortChanged             ;
        }
    }-*/;

    private void handleTearDownSortChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SortEvent.getType()) == 0) tearDownSortChangedEvent();
    }

    private native void tearDownSortChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("sortChanged")) delete obj.sortChanged;
    }-*/;

    /**
     * Add a sorterClick handler.
     * <p>
     * Notification method fired when the user clicks on the corner {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSorterConstructor sort button}.  Call {@link
     * com.smartgwt.client.widgets.grid.events.SorterClickEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.SorterClickHandler#onSorterClick} to suppress the sort.
     *
     * @param handler the sorterClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSorterClickHandler(com.smartgwt.client.widgets.grid.events.SorterClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SorterClickEvent.getType()) == 0) setupSorterClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SorterClickEvent.getType());
    }

    private native void setupSorterClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var sorterClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.SorterClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSorterClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("sorterClick"));
            obj.addProperties({sorterClick: 
                function () {
                    var param = {"_this": this};
                    var ret = sorterClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("sorterClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("sorterClick"));
            obj.sorterClick = 
                function () {
                    var param = {"_this": this};
                    var ret = sorterClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("sorterClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownSorterClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SorterClickEvent.getType()) == 0) tearDownSorterClickEvent();
    }

    private native void tearDownSorterClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("sorterClick")) delete obj.sorterClick;
    }-*/;

    /**
     * Add a sorterContextClick handler.
     * <p>
     * Notification method fired when the user right-clicks on the corner {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getSorterConstructor sort button}.  Call {@link
     * com.smartgwt.client.widgets.grid.events.SorterContextClickEvent#cancel()} from within {@link
     * com.smartgwt.client.widgets.grid.events.SorterContextClickHandler#onSorterContextClick} to suppress the default behavior
     * of showing the sorter's context menu.
     *
     * @param handler the sorterContextClick handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addSorterContextClickHandler(com.smartgwt.client.widgets.grid.events.SorterContextClickHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.SorterContextClickEvent.getType()) == 0) setupSorterContextClickEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.SorterContextClickEvent.getType());
    }

    private native void setupSorterContextClickEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var sorterContextClick = $debox($entry(function(param){
            var event = @com.smartgwt.client.widgets.grid.events.SorterContextClickEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownSorterContextClickEvent()();
            var ret = event.@com.smartgwt.client.event.Cancellable::isCancelled()();
            return !ret;
        }));
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("sorterContextClick"));
            obj.addProperties({sorterContextClick: 
                function () {
                    var param = {"_this": this};
                    var ret = sorterContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("sorterContextClick", arguments);
                    }
                    return ret;
                }
             });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("sorterContextClick"));
            obj.sorterContextClick = 
                function () {
                    var param = {"_this": this};
                    var ret = sorterContextClick(param) == true;
                    if (ret && hasDefaultHandler) {
                        ret = this.Super("sorterContextClick", arguments);
                    }
                    return ret;
                }
            ;
        }
    }-*/;

    private void handleTearDownSorterContextClickEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.SorterContextClickEvent.getType()) == 0) tearDownSorterContextClickEvent();
    }

    private native void tearDownSorterContextClickEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("sorterContextClick")) delete obj.sorterContextClick;
    }-*/;

	/**
     * Start inline editing at the provided coordinates. <p> Invoked when a cell is editable and the <code>editEvent</code>
     * occurs on that cell.  Can also be invoked explicitly. <P> If this method is called while editing is already in progress,
     * the value from the current editCell will either be stored locally as a temporary edit value, or saved via 'saveEdits()'
     * depending on <code>this.saveByCell</code>, and the position of the new edit cell.<br> Will update the UI to show the
     * editor for the new cell, and put focus in it unless explicitly suppressed by the optional <code>suppressFocus</code>
     * parameter.
     *
     * @return true if we are editing the cell, false if not editing for some reason
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditEvent
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean startEditing() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "startEditing", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.startEditing();
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * @see ListGrid#startEditing
     */
    public Boolean startEditing(Integer rowNum){
        return startEditing(rowNum, (Integer) null, null);
    }

    /**
     * @see ListGrid#startEditing
     */
    public Boolean startEditing(Integer rowNum, Integer colNum){
        return startEditing(rowNum, colNum, null);
    }

	/**
     * Start inline editing at the provided coordinates. <p> Invoked when a cell is editable and the <code>editEvent</code>
     * occurs on that cell.  Can also be invoked explicitly. <P> If this method is called while editing is already in progress,
     * the value from the current editCell will either be stored locally as a temporary edit value, or saved via 'saveEdits()'
     * depending on <code>this.saveByCell</code>, and the position of the new edit cell.<br> Will update the UI to show the
     * editor for the new cell, and put focus in it unless explicitly suppressed by the optional <code>suppressFocus</code>
     * parameter.
     * @param rowNum Row number of the cell to edit.  Defaults to first                                  editable row
     * @param colNum Column number of the cell to edit.  Defaults to first                                  editable column
     * @param suppressFocus If passed this parameter suppresses the default                                  behavior of focusing in the edit form
     * item when                                  the editor is shown.
     *
     * @return true if we are editing the cell, false if not editing for some reason
     * @see com.smartgwt.client.widgets.grid.ListGrid#canEditCell
     * @see com.smartgwt.client.widgets.grid.ListGrid#getEditEvent
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native Boolean startEditing(Integer rowNum, Integer colNum, Boolean suppressFocus) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "startEditing", "Integer,Integer,Boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.startEditing(rowNum == null ? null : rowNum.@java.lang.Integer::intValue()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()(), suppressFocus == null ? null : suppressFocus.@java.lang.Boolean::booleanValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;
	
	/**
     * Start editing a new row, after the last pre-existing record in the current set of data. <P> This new row will be saved
     * via the "add" {@link com.smartgwt.client.docs.DataSourceOperations DataSource\n operation}. <P> See the {@link
     * com.smartgwt.client.docs.Editing Grid Editing overview} and also the {@link com.smartgwt.client.docs.UnsavedRecords
     * Editing Unsaved Records overview} for context about how unsaved records behave. <P> You can optionally pass
     * <code>newValues</code> which are the initial values for the newly added record.  See also {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDefaultValue ListGridField.defaultValue} as a means of setting default
     * values every time the user begins editing a new record, for instance, by pressing downArrow on the last normal record in
     * the grid when {@link com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} is "next". <P> If
     * editing is already underway elsewhere in the grid, startEditingNew() behaves just like {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()}.
     * @see com.smartgwt.client.widgets.grid.ListGrid#startEditing
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void startEditingNew() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "startEditingNew", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.startEditingNew();
    }-*/;

    /**
     * @see ListGrid#startEditingNew
     */
    public void startEditingNew(Map newValues){
        startEditingNew(newValues, null);
    }

	/**
     * Start editing a new row, after the last pre-existing record in the current set of data. <P> This new row will be saved
     * via the "add" {@link com.smartgwt.client.docs.DataSourceOperations DataSource\n operation}. <P> See the {@link
     * com.smartgwt.client.docs.Editing Grid Editing overview} and also the {@link com.smartgwt.client.docs.UnsavedRecords
     * Editing Unsaved Records overview} for context about how unsaved records behave. <P> You can optionally pass
     * <code>newValues</code> which are the initial values for the newly added record.  See also {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getDefaultValue ListGridField.defaultValue} as a means of setting default
     * values every time the user begins editing a new record, for instance, by pressing downArrow on the last normal record in
     * the grid when {@link com.smartgwt.client.widgets.grid.ListGrid#getListEndEditAction listEndEditAction} is "next". <P> If
     * editing is already underway elsewhere in the grid, startEditingNew() behaves just like {@link
     * com.smartgwt.client.widgets.grid.ListGrid#startEditing startEditing()}.
     * @param newValues Optional initial set of properties for the new record
     * @param suppressFocus Whether to suppress the default behavior of moving focus                                   to the newly shown editor.
     * @see com.smartgwt.client.widgets.grid.ListGrid#startEditing
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void startEditingNew(Map newValues, Boolean suppressFocus) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "startEditingNew", "Map,Boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.startEditingNew(newValues == null ? null : @com.smartgwt.client.util.JSOHelper::convertMapToJavascriptObject(Ljava/util/Map;)(newValues), suppressFocus == null ? null : suppressFocus.@java.lang.Boolean::booleanValue()());
    }-*/;
	
	/**
     * Notification that the user is no longer hovering over some cell. Hides the current hover canvas if one is showing.
     */
    public native void stopHover() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "stopHover", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.stopHover();
    }-*/;

	/**
     * Notification fired when a user either creates a new summary field or edits an existing summary field.
     * @param field the summary field
     * @param summary the new or updated summary definition
     */
    public native void summaryUpdated(ListGridField field, UserSummary summary) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "summaryUpdated", "ListGridField,UserSummary");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.summaryUpdated(field.@com.smartgwt.client.core.DataClass::getJsObj()(), summary.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Toggles the sort-direction of the field with the passed name and resorts the grid.
     * @param fieldName The name of a field, visible, hidden or existing only in the   dataSource
     */
    public native void toggleSort(String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "toggleSort", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.toggleSort(fieldName);
    }-*/;

	/**
     * Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal scrolling occurs.
     * @param field field or fields to unfreeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void unfreezeField(ListGridField field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unfreezeField", "ListGridField");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(field.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

	/**
     * Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal scrolling occurs.
     * @param field field or fields to unfreeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void unfreezeField(Integer field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unfreezeField", "Integer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(field == null ? null : field.@java.lang.Integer::intValue()());
    }-*/;

	/**
     * Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal scrolling occurs.
     * @param field field or fields to unfreeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void unfreezeField(String field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unfreezeField", "String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(field);
    }-*/;

	/**
     * Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal scrolling occurs.
     * @param field field or fields to unfreeze.  fields may be specified as ListGridField objects, field names or colNum.
     * @see com.smartgwt.client.docs.FrozenFields FrozenFields overview and related methods
     */
    public native void unfreezeField(String[] field) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unfreezeField", "String[]");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(field);
    }-*/;

	/**
     * Removes the grouping from the listGrid, restoring its original data
     */
    public native void ungroup() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "ungroup", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.ungroup();
    }-*/;

	/**
     * Reverses a previous call to {@link com.smartgwt.client.widgets.grid.ListGrid#markRecordRemoved markRecordRemoved()}. <P>
     * Note that a record that is marked for removal and then un-marked retains any uncommitted edits from before it was marked
     * for removal.  These can be discarded with {@link com.smartgwt.client.widgets.grid.ListGrid#discardEdits discardEdits()}.
     * @param rowNum index of record to clear the 'removed'
     * @see com.smartgwt.client.docs.Editing Editing overview and related methods
     */
    public native void unmarkRecordRemoved(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unmarkRecordRemoved", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unmarkRecordRemoved(rowNum);
    }-*/;

	/**
     * Turn sorting off, typically because data has changed and is no longer sorted. <p> Calling <code>unsort()</code> disables
     * visual indication of which columns are sorted, and calls <code>unsort()</code> on the underlying dataset. <P> Note that
     * a grid viewing a paged dataset may not be able to support <code>unsort()</code> because the sort order is what
     * establishes the row numbering that allows data to be fetched in batches. <P> <code>unsort()</code> is automatically
     * called when records are dropped or the {@link com.smartgwt.client.widgets.grid.ListGrid#setSort sort-configuration} is
     * altered.
     */
    public native void unsort() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "unsort", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unsort();
    }-*/;

	/**
     * Perform a DataSource "update" operation to update existing records in this component's DataSource.
     * @param updatedRecord updated record
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_update" target="examples">Databound update Example</a>
     */
    public native void updateData(Record updatedRecord) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "updateData", "Record");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.updateData(updatedRecord.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

    /**
     * @see ListGrid#updateData
     */
    public void updateData(Record updatedRecord, DSCallback callback){
        updateData(updatedRecord, callback, null);
    }

	/**
     * Perform a DataSource "update" operation to update existing records in this component's DataSource.
     * @param updatedRecord updated record
     * @param callback method to call on operation completion
     * @param requestProperties additional properties to set on the DSRequest                                          that will be issued
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_dataoperations_update" target="examples">Databound update Example</a>
     */
    public native void updateData(Record updatedRecord, DSCallback callback, DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "updateData", "Record,DSCallback,DSRequest");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.updateData(updatedRecord.@com.smartgwt.client.core.DataClass::getJsObj()(), 
			$entry( function(dsResponse, data, dsRequest) { 
				if(callback!=null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(
					@com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse), 
					data, 
					@com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest)
				);
			}), requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
	
	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, this method
     * is called to update components created by {@link com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent
     * createRecordComponent()} when they are to be applied to a different record in the grid. See the {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents record components overview} for more information on
     * recordComponents. <P> The colNum parameter is applicable only when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell} is true. Note that
     * if {@link com.smartgwt.client.widgets.grid.ListGrid#getPoolComponentsPerColumn poolComponentsPerColumn} is set to false,
     * the component may have been generated by a {@link com.smartgwt.client.widgets.grid.ListGrid#createRecordComponent
     * createRecordComponent()} call applied to a different field. <P> Return null to avoid re-adding the component to the row
     * or cell.
     * @param record record to which the passed component applies
     * @param colNum cell to which the passed component applies
     * @param component the component to update
     * @param recordChanged was the passed component previously embedded in a     different record?
     *
     * @return return the component to embed in the passed record
     */
    public native Canvas updateRecordComponent(ListGridRecord record, Integer colNum, Canvas component, boolean recordChanged) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "updateRecordComponent", "ListGridRecord,Integer,Canvas,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__updateRecordComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()(), component == null ? null : component.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), recordChanged);
        return @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

	/**
     * Selects every user-selectable record in the grid. Unlike {@link
     * com.smartgwt.client.widgets.grid.ListGrid#selectAllRecords selectAllRecords()}, if a record is {@link
     * com.smartgwt.client.widgets.grid.ListGrid#canSelectRecord unselectable}, this method will not attempt to select it.
     */
    public native void userSelectAllRecords() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "userSelectAllRecords", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.userSelectAllRecords();
    }-*/;

	/**
     * Validate the current edit value for the cell in question.  Called when the user moves to a new edit cell if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getValidateByCell validateByCell} is true.<br> This method may also be called
     * directly to perform cell level validation at any time.
     * @param rowNum index of row to be validated.
     * @param fieldName field name (or column index) of field to be validated
     *
     * @return returns true if validation was successful (no errors encountered), false                    otherwise.
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Boolean validateCell(int rowNum, String fieldName) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "validateCell", "int,String");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.validateCell(rowNum, fieldName);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Validate the current set of edit values for the row in question. <P> Called when the user moves to a new edit row, or
     * when an edited record is to be saved if client side validation is enabled for this grid. <P> This method may also be
     * called directly to perform row level validation at any time.
     * @param rowNum index of row to be validated.
     *
     * @return returns true if validation was successful (no errors encountered), false                    otherwise.
     * @see com.smartgwt.client.docs.GridValidation GridValidation overview and related methods
     */
    public native Boolean validateRow(int rowNum) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "validateRow", "int");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.validateRow(rowNum);
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

    /**
     * Add a viewStateChanged handler.
     * <p>
     * Notification method executed whenever the viewState of this grid changes. View state is accessible via {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getViewState ListGrid.getViewState()}, and contains field state information,
     * sort information, selection information, hiliting information and grouping information.
     *
     * @param handler the viewStateChanged handler
     * @return {@link HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addViewStateChangedHandler(com.smartgwt.client.widgets.grid.events.ViewStateChangedHandler handler) {
        if(getHandlerCount(com.smartgwt.client.widgets.grid.events.ViewStateChangedEvent.getType()) == 0) setupViewStateChangedEvent();
        return doAddHandler(handler, com.smartgwt.client.widgets.grid.events.ViewStateChangedEvent.getType());
    }

    private native void setupViewStateChangedEvent() /*-{
        var obj;
        var selfJ = this;
        var hasDefaultHandler;
        var viewStateChanged = $entry(function(){
            var param = {"_this": this};
            var event = @com.smartgwt.client.widgets.grid.events.ViewStateChangedEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
            selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            selfJ.@com.smartgwt.client.widgets.grid.ListGrid::handleTearDownViewStateChangedEvent()();
            if (hasDefaultHandler) this.Super("viewStateChanged", arguments);
        });
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            hasDefaultHandler = $wnd.isc.isA.Function(obj.getProperty("viewStateChanged"));
            obj.addProperties({viewStateChanged:  viewStateChanged              });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            hasDefaultHandler = $wnd.isc.isA.Function($wnd.isc[scClassName].getInstanceProperty("viewStateChanged"));
            obj.viewStateChanged =  viewStateChanged             ;
        }
    }-*/;

    private void handleTearDownViewStateChangedEvent() {
        if (getHandlerCount(com.smartgwt.client.widgets.grid.events.ViewStateChangedEvent.getType()) == 0) tearDownViewStateChangedEvent();
    }

    private native void tearDownViewStateChangedEvent() /*-{
        var obj;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        if (obj && obj.hasOwnProperty("viewStateChanged")) delete obj.viewStateChanged;
    }-*/;

	/**
     * Compares the specified criteria with the current criteria applied to this component's data object and determines whether
     * the new criteria could be satisfied from the currently cached set of data, or if a new filter/fetch operation will be
     * required. <P> This is equivalent to calling <code>this.data.willFetchData(...)</code>. Always returns true if this
     * component is not showing a set of data from the dataSource. <p> Note that to predict correctly the decision that will be
     * made by filter/fetch, you'll need to pass the same {@link com.smartgwt.client.types.TextMatchStyle} that will be used by
     * the future filter/fetch.  Fetching manually (e.g. {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()}) will by default use "exact" while filtering (e.g. {@link
     * com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()}) will by default use "substring".  If the component
     * is configured for autofetch (i.e. {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchData autoFetchData}:
     * true), that will use {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle
     * autoFetchTextMatchStyle}, which defaults to "substring".  If nothing/null is passed for the style, this method assumes
     * you want the style from the last filter/fetch. <p> To determine what {@link com.smartgwt.client.types.TextMatchStyle} is
     * being used, check the RPC Tab of the {@link com.smartgwt.client.docs.Debugging Smart GWT Developer Console} and check
     * the relevant {@link com.smartgwt.client.data.DSRequest}.
     * @param newCriteria new criteria to test.
     *
     * @return true if server fetch would be required to satisfy new criteria.
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native Boolean willFetchData(Criteria newCriteria) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "willFetchData", "Criteria");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
	    if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(newCriteria)){
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(newCriteria.@com.smartgwt.client.data.Criterion::getJsObj()(),"_constructor","AdvancedCriteria");
	    }
        var ret = self.willFetchData(newCriteria == null ? null : newCriteria.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;

	/**
     * Compares the specified criteria with the current criteria applied to this component's data object and determines whether
     * the new criteria could be satisfied from the currently cached set of data, or if a new filter/fetch operation will be
     * required. <P> This is equivalent to calling <code>this.data.willFetchData(...)</code>. Always returns true if this
     * component is not showing a set of data from the dataSource. <p> Note that to predict correctly the decision that will be
     * made by filter/fetch, you'll need to pass the same {@link com.smartgwt.client.types.TextMatchStyle} that will be used by
     * the future filter/fetch.  Fetching manually (e.g. {@link com.smartgwt.client.widgets.grid.ListGrid#fetchData
     * fetchData()}) will by default use "exact" while filtering (e.g. {@link
     * com.smartgwt.client.widgets.grid.ListGrid#filterData filterData()}) will by default use "substring".  If the component
     * is configured for autofetch (i.e. {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchData autoFetchData}:
     * true), that will use {@link com.smartgwt.client.widgets.grid.ListGrid#getAutoFetchTextMatchStyle
     * autoFetchTextMatchStyle}, which defaults to "substring".  If nothing/null is passed for the style, this method assumes
     * you want the style from the last filter/fetch. <p> To determine what {@link com.smartgwt.client.types.TextMatchStyle} is
     * being used, check the RPC Tab of the {@link com.smartgwt.client.docs.Debugging Smart GWT Developer Console} and check
     * the relevant {@link com.smartgwt.client.data.DSRequest}.
     * @param newCriteria new criteria to test.
     * @param textMatchStyle New text match style. If not passed assumes       textMatchStyle will not be modified.
     *
     * @return true if server fetch would be required to satisfy new criteria.
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native Boolean willFetchData(Criteria newCriteria, TextMatchStyle textMatchStyle) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "willFetchData", "Criteria,TextMatchStyle");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
	    if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(newCriteria)){
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(newCriteria.@com.smartgwt.client.data.Criterion::getJsObj()(),"_constructor","AdvancedCriteria");
	    }
        var ret = self.willFetchData(newCriteria == null ? null : newCriteria.@com.smartgwt.client.core.DataClass::getJsObj()(), textMatchStyle == null ? null : textMatchStyle.@com.smartgwt.client.types.TextMatchStyle::getValue()());
        if(ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(ret);
    }-*/;
	

    // ********************* Static Methods ***********************

    /** 
     * Class level method to set the default properties of this class.  If set, then all
     * existing and subsequently created instances of this class will automatically have
     * default properties corresponding to
     * the properties set on the SmartGWT class instance passed to this function before its
     * underlying SmartClient JS object was created.
     * This is a powerful feature that eliminates the need for users to create a separate
     * hierarchy of subclasses that only alter the default properties of this class. Can also
     * be used for skinning / styling purposes.  <P> <b>Note:</b> This method is intended for
     * setting default attributes only and will affect all instances of the underlying class
     * (including those automatically generated in JavaScript).  This method should not be used
     * to apply standard EventHandlers or override methods for a class - use a custom subclass
     * instead.  Calling this method after instances have been created can result in undefined
     * behavior, since it bypasses any setters and a class instance may have already examined 
     * a particular property and not be expecting any changes through this route.
     *
     * @param listGridProperties properties that should be used as new defaults when instances of this class are created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public static native void setDefaultProperties(ListGrid listGridProperties) /*-{
        if (listGridProperties.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPreConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)(ListGrid.@java.lang.Object::getClass()(), "setDefaultProperties", listGridProperties.@java.lang.Object::getClass()());
        }
        listGridProperties.@com.smartgwt.client.widgets.BaseWidget::setConfigOnly(Z)(true);
    	var properties = listGridProperties.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        properties = @com.smartgwt.client.util.JSOHelper::cleanProperties(Lcom/google/gwt/core/client/JavaScriptObject;Z)(properties,true);
        $wnd.isc.ListGrid.addProperties(properties);
    }-*/;

    // ***********************************************************



	protected void onInit () {
		super.onInit();
		onInit_ListGrid();
	}

    // The testInstance is used to figure out which override points have actually been overridden.
    // For a particular overridable method, if the testInstance's version of the method is different
    // than this ListGrid instance's version, then the method was overridden and we need to install
    // the SGWT entry.
    //
    // In hosted mode, GWT uses "tearOff" functions to do the virtual dispatch, so we can't check
    // for different method implementations by seeing if the function objects are different (the
    // tearOff functions are always the same). Thus, in hosted mode, we always install the SGWT
    // entry functions.
    protected native void onInit_ListGrid() /*-{
        var isHosted = !@com.google.gwt.core.client.GWT::isScript()();
        var testInstance = this.@com.smartgwt.client.widgets.grid.ListGrid::getTestInstance()();
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();

        self.__getCellCSSText = self.getCellCSSText;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getCellCSSText(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getCellCSSText(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)))
        {
            self.getCellCSSText = $debox($entry(function(record, rowNum, colNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::getCellCSSText(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(recordJ, rowNum, colNum);
            }));
        }

        self.__getRowHeight = self.getRowHeight;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getRowHeight(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getRowHeight(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I)))
        {
            self.getRowHeight = $debox($entry(function(record, rowNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::getRowHeight(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I)(recordJ, rowNum);
            }));
        }

        self.__displayHeaderContextMenu = self.displayHeaderContextMenu;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::displayHeaderContextMenu(Lcom/smartgwt/client/widgets/Canvas;[I) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::displayHeaderContextMenu(Lcom/smartgwt/client/widgets/Canvas;[I)))
        {
            self.displayHeaderContextMenu = $entry(function(canvas, position) {
                var jObj = this.__ref;
                var canvasJ   = @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(canvas);
                var positionJ = position == null ? null : @com.smartgwt.client.util.ConvertTo::arrayOfint(Lcom/google/gwt/core/client/JavaScriptObject;)(position);
                var jResult = jObj.@com.smartgwt.client.widgets.grid.ListGrid::displayHeaderContextMenu(Lcom/smartgwt/client/widgets/Canvas;[I)(canvasJ, positionJ);
                return jResult == null ? null : jResult.@java.lang.Boolean::booleanValue()();
            });
        }

        self.__getCellStyle = self.getCellStyle;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getCellStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getCellStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)))
        {
            self.getCellStyle = $debox($entry(function(record, rowNum, colNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::getCellStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(recordJ, rowNum, colNum);
            }));
        }

        self.__getBaseStyle = self.getBaseStyle;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getBaseStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getBaseStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)))
        {
            self.getBaseStyle = $debox($entry(function(record, rowNum, colNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::getBaseStyle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(recordJ, rowNum, colNum);
            }));
        }

        self.__getHeaderContextMenuItems = self.getHeaderContextMenuItems;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderContextMenuItems(Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderContextMenuItems(Ljava/lang/Integer;)))
        {
            self.getHeaderContextMenuItems = $entry(function(fieldNum) {
                var jObj = this.__ref;
                var fieldNumJ = fieldNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(fieldNum);
                var menuItemsJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderContextMenuItems(Ljava/lang/Integer;)(fieldNumJ);
                var menuItemsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(menuItemsJ);
                return menuItemsJS;
            });
        }

        self.__getHeaderSpanContextMenuItems  = self.getHeaderSpanContextMenuItems;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderSpanContextMenuItems(Lcom/smartgwt/client/widgets/grid/HeaderSpan;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderSpanContextMenuItems(Lcom/smartgwt/client/widgets/grid/HeaderSpan;)))
        {
            self.getHeaderSpanContextMenuItems = $entry(function(headerSpan) {
                var jObj = this.__ref;
                var headerSpanJ = @com.smartgwt.client.widgets.grid.HeaderSpan::new(Lcom/google/gwt/core/client/JavaScriptObject;)(headerSpan);
                var menuItemsJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getHeaderSpanContextMenuItems(Lcom/smartgwt/client/widgets/grid/HeaderSpan;)(headerSpanJ);
                var menuItemsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(menuItemsJ);
                return menuItemsJS;
            });
        }

        self.__canEditCell = self.canEditCell;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::canEditCell(II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::canEditCell(II)))
        {
            self.canEditCell = $debox($entry(function(rowNum, colNum) {
                var jObj = this.__ref;
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::canEditCell(II)(rowNum, colNum);
            }));
        }

        self.__canSelectCell = self.canSelectCell;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::canSelectCell(II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::canSelectCell(II)))
        {
            self.canSelectCell = $debox($entry(function(rowNum, colNum) {
                var jObj = this.__ref;
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::canSelectCell(II)(rowNum, colNum);
            }));
        }

        self.__canSelectRecord = self.canSelectRecord;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::canSelectRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::canSelectRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)))
        {
            self.canSelectRecord = $debox($entry(function (record) {
                var jObj = this.__ref;
                var recordJ =  @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return jObj.@com.smartgwt.client.widgets.grid.ListGrid::canSelectRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)(recordJ);
            }));
        }

        self.__getRollOverCanvas = self.getRollOverCanvas;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)))
        {
            self.getRollOverCanvas = $entry(function(rowNum, colNum) {
                var jObj = this.__ref;

                var rowNumJ = rowNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(rowNum),
                    colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)(rowNumJ, colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getRollUnderCanvas = self.getRollUnderCanvas;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)))
        {
            self.getRollUnderCanvas = $entry(function(rowNum, colNum) {
                var jObj = this.__ref;
                var rowNumJ = rowNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(rowNum),
                    colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)(rowNumJ, colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getFrozenRollOverCanvas = self.getFrozenRollOverCanvas;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)))
        {
            self.getFrozenRollOverCanvas = $entry(function(rowNum, colNum) {
                var jObj = this.__ref;

                var rowNumJ = rowNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(rowNum),
                    colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollOverCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)(rowNumJ, colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getFrozenRollUnderCanvas = self.getFrozenRollUnderCanvas;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)))
        {
            self.getFrozenRollUnderCanvas = $entry(function(rowNum, colNum) {
                var jObj = this.__ref;
                var rowNumJ = rowNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(rowNum),
                    colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getFrozenRollUnderCanvas(Ljava/lang/Integer;Ljava/lang/Integer;)(rowNumJ, colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        
        self.__createRecordComponent = self.createRecordComponent;
        if (self.__createRecordComponent == null) {
            self.__createRecordComponent = function (record, colNum) { return null; };
        }
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::createRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::createRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;)))
        {
            self.createRecordComponent = $entry(function (record, colNum) {
                var jObj = this.__ref;
                var recordJ =  @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::createRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;)(recordJ, colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__showRecordComponent = self.showRecordComponent;
        if (self.__showRecordComponent == null) {
            self.__showRecordComponent = function (record, colNum) { return true; };
        }
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::showRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::showRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;)))
        {
            self.showRecordComponent = $entry(function (record, colNum) {
                var jObj = this.__ref;
                var recordJ =  @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var ret = jObj.@com.smartgwt.client.widgets.grid.ListGrid::showRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;)(recordJ, colNumJ);
                return ret;
            });
        }

        self.__updateRecordComponent = self.updateRecordComponent;
        if (self.__updateRecordComponent == null) {
            self.__updateRecordComponent = function (record, colNum, component, recordChanged) {
                return component;
            };
        }
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::updateRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;Lcom/smartgwt/client/widgets/Canvas;Z) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::updateRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;Lcom/smartgwt/client/widgets/Canvas;Z)))
        {
            self.updateRecordComponent = $entry(function (record, colNum, component, recordChanged) {
                var jObj = this.__ref;
                var recordJ =  @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);
                var componentJ = component == null ? null :
                   @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(component);
                componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::updateRecordComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/Integer;Lcom/smartgwt/client/widgets/Canvas;Z)(recordJ, colNumJ, componentJ, recordChanged);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getExpansionComponent = self.getExpansionComponent;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getExpansionComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getExpansionComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)))
        {
            self.getExpansionComponent = $entry(function(record) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getExpansionComponent(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)(recordJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getGridSummary = self.getGridSummary;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getGridSummary(Lcom/smartgwt/client/widgets/grid/ListGridField;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getGridSummary(Lcom/smartgwt/client/widgets/grid/ListGridField;)))
        {
            self.getGridSummary = $debox($entry(function(field) {
                var jObj = this.__ref;
                var fieldJ = @com.smartgwt.client.widgets.grid.ListGridField::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(field);
                var val = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getGridSummary(Lcom/smartgwt/client/widgets/grid/ListGridField;)(fieldJ);
                return $wnd.SmartGWT.convertToPrimitiveType(val);
            }));
        }

        self.__canExpandRecord = self.canExpandRecord;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::canExpandRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::canExpandRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I)))
        {
            self.canExpandRecord = $debox($entry(function(record, rowNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var retVal = jObj.@com.smartgwt.client.widgets.grid.ListGrid::canExpandRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I)(recordJ, rowNum);
                return retVal;
            }));
        }

        self.__getRelatedDataSource = self.getRelatedDataSource;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getRelatedDataSource(Lcom/smartgwt/client/widgets/grid/ListGridRecord;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getRelatedDataSource(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)))
        {
            self.getRelatedDataSource = $entry(function(record) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var dataSourceJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getRelatedDataSource(Lcom/smartgwt/client/widgets/grid/ListGridRecord;)(recordJ);
                return dataSourceJ == null ? null : dataSourceJ.@com.smartgwt.client.core.BaseClass::getOrCreateJsObj()();
            });
        }

        self.__getTotalRows = self.getTotalRows;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getTotalRows() !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getTotalRows()))
        {
            self.getTotalRows = $debox($entry(function() {
                var jObj = this.__ref;
                if(jObj == null) return this.__getTotalRows();
                self._jsOverrideCall.getTotalRows = true;
                var rows = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getTotalRows()();
                if (self._fireDefaultMethod.getTotalRows) {
                    rows = this.__getTotalRows();
                }
                self._jsOverrideCall.getTotalRows = null;
                self._fireDefaultMethod.getTotalRows = null;
                return rows;
            }));
        }

        self.__getValueIcon = self.getValueIcon;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getValueIcon(Lcom/smartgwt/client/widgets/grid/ListGridField;Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getValueIcon(Lcom/smartgwt/client/widgets/grid/ListGridField;Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;)))
        {
            //the rowNum parameter is a non public parameter used for checking whether a cell is editable. Not exposed in the SGWT override method but
            //preserving the rownNum passthrough parameter
            self.getValueIcon = $entry(function(field, value, record, rowNum) {
                var jObj = this.__ref;
                if(jObj == null) return this.__getValueIcon(field, value, record, rowNum);
                self._jsOverrideCall.getValueIcon = true;
                var fieldJ = @com.smartgwt.client.widgets.grid.ListGridField::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(field);
                var valueJ = $wnd.SmartGWT.convertToJavaType(value);
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var icon = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getValueIcon(Lcom/smartgwt/client/widgets/grid/ListGridField;Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;)(fieldJ, valueJ, recordJ);
                if (self._fireDefaultMethod.getValueIcon) {
                    icon = this.__getValueIcon(field, value, record, rowNum);
                }
                self._jsOverrideCall.getValueIcon = null;
                self._fireDefaultMethod.getValueIcon = null;
                return icon;
            });
        }

        self.__getRowSpan = self.getRowSpan;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getRowSpan(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getRowSpan(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)))
        {
            self.getRowSpan = $entry(function(record, rowNum, colNum) {
                var jObj = this.__ref;
                if(jObj == null) {
                    // Support smartclient class level getRowSpan being defined or unset.
                    if (this.__getRowSpan == null) return 1;
                    return this.__getRowSpan(record, rowNum, colNum);
                }
                self._jsOverrideCall.getRowSpan = true;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var rowSpan = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getRowSpan(Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(recordJ,rowNum,colNum);

                if (self._fireDefaultMethod.getRowSpan) {
                    if (this.__getRowSpan == null) rowSpan = 1;
                    else rowSpan = this.__getRowSpan(record, rowNum, colNum);
                }
                self._jsOverrideCall.getRowSpan = null;
                self._fireDefaultMethod.getRowSpan = null;
                return rowSpan;
            });
        }

        self.__getCellHoverComponent = self.getCellHoverComponent;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getCellHoverComponent(Lcom/smartgwt/client/data/Record;Ljava/lang/Integer;Ljava/lang/Integer;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getCellHoverComponent(Lcom/smartgwt/client/data/Record;Ljava/lang/Integer;Ljava/lang/Integer;)))
        {
            self.getCellHoverComponent = $entry(function(record, rowNum, colNum) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var rowNumJ = rowNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(rowNum),
                    colNumJ = colNum == null ? null : @com.smartgwt.client.util.JSOHelper::toInteger(I)(colNum);

                var componentJ = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getCellHoverComponent(Lcom/smartgwt/client/data/Record;Ljava/lang/Integer;Ljava/lang/Integer;)(recordJ,rowNumJ,colNumJ);
                return componentJ == null ? null : componentJ.@com.smartgwt.client.widgets.Canvas::getOrCreateJsObj()();
            });
        }

        self.__getExportRowBGColor = self.getExportRowBGColor;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getExportRowBGColor(ILcom/smartgwt/client/data/Record;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getExportRowBGColor(ILcom/smartgwt/client/data/Record;)))
        {
            self.getExportRowBGColor = $entry(function(rowNum, record) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var retVal = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getExportRowBGColor(ILcom/smartgwt/client/data/Record;)(rowNum, recordJ);
                return retVal;
            });
        }

        self.__getExportColumnBGColor = self.getExportColumnBGColor;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getExportColumnBGColor(I) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getExportColumnBGColor(I)))
        {
            self.getExportColumnBGColor = $entry(function(colNum) {
                var jObj = this.__ref;
                var retVal = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getExportColumnBGColor(I)(colNum);
                return retVal;
            });
        }

        self.__getExportBGColor = self.getExportBGColor;
        if (isHosted ||
            (testInstance.@com.smartgwt.client.widgets.grid.ListGrid::getExportBGColor(IILcom/smartgwt/client/data/Record;) !==
             this.@com.smartgwt.client.widgets.grid.ListGrid::getExportBGColor(IILcom/smartgwt/client/data/Record;)))
        {
            self.getExportBGColor = $entry(function(rowNum, colNum, record) {
                var jObj = this.__ref;
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                var retVal = jObj.@com.smartgwt.client.widgets.grid.ListGrid::getExportBGColor(IILcom/smartgwt/client/data/Record;)(rowNum, colNum, recordJ);
                return retVal;
            });
        }

    }-*/;

    /**
     * Sets the properties for creating a <code>ListGridField</code> AutoChild named
     * <code>autoChildName</code>.
     *
     * <p><b>NOTE:</b> Overrides at override points are not applied to AutoChildren created from
     * <code>properties</code>; that is, if the Java {@link java.lang.Class} of <code>properties</code>
     * overrides a Smart&nbsp;GWT override point, the custom method implementation will not be called.
     *
     * @see com.smartgwt.client.docs.AutoChildUsage
     */
    public void setAutoChildProperties(String autoChildName, ListGridField properties) {
        setAttribute(autoChildName + "Properties", JSOHelper.cleanProperties(
                         properties == null ? null : properties.getJsObj(), true), true);
    }

	/**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu showHeaderContextMenu} is <code>true</code>
     * this method is fired when the user right-clicks on the header for this grid.<br> Default implementation will display a
     * menu with entries derived from {@link com.smartgwt.client.widgets.grid.ListGrid#getHeaderContextMenuItems
     * ListGrid.getHeaderContextMenuItems} for the appropriate column.
     * @param target which button in the header received the right-click event (may be the sorter button)
     * @param position Optional 2-element array specifying position at which the menu should be shown. 
     * If this is not passed in the menu will be shown at the mouseEvent position (default context menu behavior).
     * @return whether to bubble the event (false suppresses bubbling)
     * @see com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderContextMenu
     * @see com.smartgwt.client.docs.GridHeader GridHeader overview and related methods
     */
    protected native Boolean displayHeaderContextMenu(Canvas target, int[] position) /*-{
	    var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
	    var positionJS = (position == null) ? null : @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(position);
	    var result = self.__displayHeaderContextMenu(target.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), positionJS);
        return result == null ? null : @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(result);
	}-*/;
  	
	/**
     * Return the total number of rows in the grid. <P> Note that, when creating new rows via inline editing, this can be more
     * than the total number of rows in the dataset (that is, grid.data.getLength())
     * <P>
     * <b> Note :</b> this is an override point.
     *
     * @return total number of rows in the grid
     */
    public native int getTotalRows() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret  = null;
        if (self._jsOverrideCall==undefined || self._jsOverrideCall.getTotalRows==undefined){
        	ret = self.getTotalRows();
        } else {
	        if (self._jsOverrideCall.getTotalRows) {
		        self._fireDefaultMethod.getTotalRows = true;
		        return 0;
		    }
	        ret = self.__getTotalRows();
        }
        if (!$wnd.isc.isA.Number(ret)) ret = 0;
        return ret;
    }-*/;

    /**
     * Returns the appropriate valueIcon for a cell based on the field and the data value for the  cell. Default implementation
     * returns null if {@link com.smartgwt.client.widgets.grid.ListGridField#getSuppressValueIcon suppressValueIcon} is true
     * otherwise looks at {@link com.smartgwt.client.widgets.grid.ListGridField#getValueIcons valueIcons}.
     * @param field field associated with the cell
     * @param value data value for the cell's record in this field.
     * @param record record associated with this cell
     *
     * <b> Note :</b> This is an override point
     *
     * @return the value icon
     */
    public native String getValueIcon(ListGridField field, Object value, ListGridRecord record) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if (self._jsOverrideCall.getValueIcon) {
            self._fireDefaultMethod.getValueIcon = true;
            return;
        }
        var valueJS = $wnd.SmartGWT.convertToPrimitiveType(value);
        return self.__getValueIcon(field.@com.smartgwt.client.core.DataClass::getJsObj()(), valueJS, record.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
    	    
    /**
     * Return how many rows this cell should span.  Default is 1.  <P> When using row spanning, consider setting {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getUseRowSpanStyling useRowSpanStyling} to enable row-span-sensitive styling
     * behaviors. <P> When using row spanning: <ul> <li> APIs that allow modifying the contents of cells (such as {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCellStyle ListGrid.getCellStyle} or {@link
     * com.smartgwt.client.widgets.grid.CellFormatter#format}) will be called only once
     * per row-spanning cell <li> when using {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells cell-based
     * selection}, only the spanning cell is considered selected, and not any of the cells spanned through.  For example, if
     * the cell at row 2 column 0 spans 2 cells, {@link com.smartgwt.client.widgets.grid.CellSelection#getIsSelected
     * isSelected} will be true for 2,0 but false for 3,0. <li> if using incremental rendering (either horizontal or vertical),
     * <code>getRowSpan()</code> may be called for a rowNum <b>in the middle of a spanning cell</b>, and should return the
     * remaining span from that rowNum onward. </ul> <P> More generally, the ListGrid has a data model of one {@link
     * com.smartgwt.client.data.Record} per row, and spanning cells doesn't fit well with this model, meaning that many
     * ListGrid features are incompatible with rowSpanning.
     *
     * <b> Note :</b> This is an override point
     *
     * @param record cell record as returned by getCellRecord
     * @param rowNum row number for the cell
     * @param colNum column number of the cell
     *
     * @return number of cells to span
     */
    public native int getRowSpan(ListGridRecord record, int rowNum, int colNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if (self._jsOverrideCall.getRowSpan) {
            self._fireDefaultMethod.getRowSpan = true;
            // This return value will not actually be used - the calling code will
            // call the default sc-class level implementation
            return 1;
        }
        var recordJS = record.@com.smartgwt.client.core.DataClass::getJsObj()();
        if (self.__getRowSpan == null) return 1;
        return self.__getRowSpan(recordJS, rowNum, colNum);

    }-*/;

    /**
     * Returns a JavaScriptObject containing default {@link com.smartgwt.client.widgets.grid.ListGridField}
     * attributes of remove fields.
     */
    public native JavaScriptObject getRemoveFieldDefaults() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        return self.removeFieldDefaults;
    }-*/;
    
    /**
     * Removes an embedded component from a grid. The record in which the component is embedded is
     * automatically derived from the Component passed in. If
     * <code>destroyOnUnEmbed</code> is <code>true</code> for the component, it will also be destroyed.
     * @param component the embedded component
     */
    public native void removeEmbeddedComponent(Canvas component) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.removeEmbeddedComponent(component.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()());
    }-*/;

	/**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponents showRecordComponents} is true, return
     * false from this method  to prevent showRecordComponent behavior for the passed record. <P> The second parameter is only
     * applicable if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowRecordComponentsByCell showRecordComponentsByCell}
     * is true.
     * @param record record being processed
     * @param colNum column index of the cell in which the record component   may be shown. Will be null unless showRecordComponentsByCell is
     * true.
     *
     * @return return false to cancel showRecordComponent behavior
     */
    protected native boolean showRecordComponent(ListGridRecord record, Integer colNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.__showRecordComponent(record.@com.smartgwt.client.core.DataClass::getJsObj()(), colNum == null ? null : colNum.@java.lang.Integer::intValue()());
        if(ret == null) { return false; }
        return ret;
    }-*/;

    /** 
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType} is not set to <code>"none"</code>, 
     * this method will be called for each record the user attempts to select. If it returns false, the
     * record will not be selected.
     * <P>
     * Note this method will not be called at all if {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is true.
     *
     * @param record the record being selected
     *
     * <b> Note :</b> this is an override point.
     *
     * @return return false to disallow selection
     */
    protected native boolean canSelectRecord(ListGridRecord record) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(),
            recordJS = (record == null ? null : record.@com.smartgwt.client.core.DataClass::getJsObj()()),
            retVal = self.__canSelectRecord(recordJS);

        if (retVal == null) {
            return false;
        } else {
            return retVal;
        }
    }-*/;

    /**
     * Provide a custom implementation of {@link #headerHoverHTML(int,java.lang.String)}.
     * <p>
     * The <code>HeaderHoverFormatter</code> should return the HTML to display in the hover canvas
     * that is displayed by default if a registered {@link com.smartgwt.client.widgets.grid.events.HeaderHoverHandler}
     * does not cancel a {@link com.smartgwt.client.widgets.grid.events.HeaderHoverEvent}.
     * The formatter can return null or an empty string to cancel the hover.
     * 
     * @param formatter the header hover formatter
     */
    public native void setHeaderHoverFormatter(HeaderHoverFormatter formatter) /*-{
        var self;
        if (this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }

        var newHeaderHoverHTMLFun;
        if (formatter == null) {
            newHeaderHoverHTMLFun = $wnd.isc[this.@com.smartgwt.client.widgets.BaseWidget::scClassName].getInstanceProperty("headerHoverHTML");
        } else {
            newHeaderHoverHTMLFun = $entry(function (fieldNum, defaultHTML) {
                return formatter.@com.smartgwt.client.widgets.grid.HeaderHoverFormatter::getHoverHTML(ILjava/lang/String;)(fieldNum, defaultHTML);
            });
        }
        self.headerHoverHTML = newHeaderHoverHTMLFun;
    }-*/;

    /**
     * Set the properties generated field that displays the current row number when {@link #setShowRowNumbers(Boolean) showRowNumbers} is true.
     * For example you can change the default width of the row number column if you have data that exceeds 4 digits to accommodate the width of, say, 10000.
     *
     * @param rowNumberFieldProperties the row number field properties
     */
    public void setRowNumberFieldProperties(ListGridField rowNumberFieldProperties) {
        JavaScriptObject config = JSOHelper.createObject();
        if (rowNumberFieldProperties != null) {
            JSOHelper.addProperties(config, rowNumberFieldProperties.getJsObj());
        }
        setAttribute("rowNumberFieldProperties", rowNumberFieldProperties == null ? null : 
                     config, true);
    }

    /**
     * For databound ListGrids, this attribute can be used to customize the
     * {@link com.smartgwt.client.data.ResultSet} object created for this grid when data is
     * fetched.
     * <p><b>Note : </b>This is an advanced setting</p>
     * Class overrides for {@link com.smartgwt.client.data.ResultSet} cannot be applied to the
     * grid using this API.  Instead, consider setting the
     * {@link com.smartgwt.client.data.DataSource#setResultSetClass resultSetClass} property in
     * the file defining your {@link com.smartgwt.client.data.DataSource}.  Your class must be
     * {@link com.smartgwt.client.docs.Reflection registered for reflection}.
     *
     * @param dataProperties  Default value is null
     * @see com.smartgwt.client.docs.Databinding Databinding overview and related methods
     */
    public void setDataProperties(ResultSet resultSetProperties) {
        if (resultSetProperties.isCreated()) {
            ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), "setDataProperties", "ResultSet");
        }
        resultSetProperties.setConfigOnly(true);

        JavaScriptObject configJS = resultSetProperties.getConfig();
        configJS = JSOHelper.cleanProperties(configJS, true);        
        setAttribute("dataProperties", configJS, true);
    }

    /**
     * @see #setData(ListGridRecord...)
     */
    public void setData(Record[] data) {
        setAttribute("data", data, true);
    }

    /**
     * @see #setData(ListGridRecord...)
     */
    public void setData(RecordList data) {
        setAttribute("data", data == null ? null : data.getOrCreateJsObj(), true);
    }

    /**
     * Return the grid data as a {@link com.smartgwt.client.data.RecordList}. If the component is bound to a DataSource,
     * the actual type of the RecordList instance will be a {@link com.smartgwt.client.data.ResultSet}.
     *
     * @return the data
     */
    public RecordList getDataAsRecordList() {
        return getRecordList();
    }

    /**
     * Synonym for {@link #setData(ListGridRecord[])}
     *
     * @param records the records
     */
    public void setRecords(ListGridRecord[] records) {
        setAttribute("data", records, true);
    }

    /**
     * Returns the current set of records displayed in this grid as an array of ListGridRecord objects.
     * Note that if the ListGrid is grouped, you can call {@link #getGroupTree()}
     * to get the underlying Tree data representation. You can call {@link #isGrouped()} to test whether the ListGrid is
     * grouped on a field.
     * <p>
     * If this is a DataBound grid this method will return an empty array unless
     * the entire set of data for the current criteria has been loaded into the
     * client, in which case all matching rows will be returned.
     * For DataBound grids, you can call {@link #getResultSet()} to retrieve
     * the current data set as a ResultSet object.
     *
     * @return an array or records.
     */
    public ListGridRecord[] getRecords() {
        if(isGrouped()) {
            return com.smartgwt.client.util.ConvertTo.arrayOfListGridRecord(getAttributeAsJavaScriptObject("originalData"));
        } else {
            return com.smartgwt.client.util.ConvertTo.arrayOfListGridRecord(getAttributeAsJavaScriptObject("data"));
        }
    }

    /**
     * Return true if the ListGrid is grouped on a field.
     *
     * @return true if grouped
     */
    public boolean isGrouped() {
        return getGroupTree() != null;
    }

    /**
     * Specifies the field by which this grid should be initially sorted. Note that if sortField is initially specified
     * as a number, it will be converted to a string (field name) after list grid initialization.
     *
     * @param fieldIndex the field index
     */
    public void setSortField(int fieldIndex) {
        setAttribute("sortField", fieldIndex, true);
    }

    /**
     * Get the current grouping of this listGrid as an array of fieldNames.
     * <P>
     * This method returns an array containing the names of the field(s) by which this
     * grid is grouped (either from {@link #setGroupByField(String... field)} or
     * or from a call to {@link #groupBy(String...)}).
     * If this grid is not currently grouped, this method will return null.
     * @return Current group by field names.
     */
    public String[] getGroupByFields()  {
        JavaScriptObject fields = getGroupByFieldsJS();
        return fields == null ? null : JSOHelper.convertToJavaStringArray(fields);
    }
    private native JavaScriptObject getGroupByFieldsJS() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            var self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            return self.getGroupByFields();
        } else {
            var config = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            var field = config.groupByField;
            if (field == null) return null;
            if (!$wnd.isc.isAn.Array(field)) {
                field = $wnd.Array.createFromItemArgs(field);
            }
            return field;
        }
    }-*/;

    /**
     * Describes the default state of ListGrid groups when groupBy is called. Possible values are: <ul> <li>"all": open
     * all groups </li><li>"first": open the first group </li><li>"none": start with all groups closed </li><li>Array of
     * values that should be opened </li> </ul>
     *
     * @param group the group
     */
    public void setGroupStartOpen(GroupStartOpen group) {
        setAttribute("groupStartOpen", group, true);
    }

    /**
     * @param groupValues Array of values that should be opened
     */
    public void setGroupStartOpen(Object... groupValues) {
        setAttribute("groupStartOpen", groupValues, true);
    }

    /**
     * Properties to apply to the auto-generated <code>selectionCanvas</code> AutoChild when
     * its use is enabled.
     *
     * @param selectionCanvasProperties the <code>selectionCanvas</code> properties
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see #setShowSelectionCanvas(Boolean)
     */
    public void setSelectionCanvasProperties(Canvas selectionCanvasProperties) 
        throws IllegalStateException 
    {
        if (selectionCanvasProperties.isCreated()) {
            ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), "setSelectionCanvasProperties",
                                                    "Canvas");
        }                                                                       
        selectionCanvasProperties.setConfigOnly(true);

        JavaScriptObject configJS = selectionCanvasProperties.getConfig();
        setAttribute("selectionCanvasProperties", JSOHelper.cleanProperties(configJS, true), false);
    }

    /**
     * Properties to apply to the auto-generated <code>selectionUnderCanvas</code> AutoChild when
     * its use is enabled.
     *
     * @param selectionUnderCanvasProperties the <code>selectionUnderCanvas</code> properties
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see #setShowSelectionUnderCanvas(Boolean)
     */
    public void setSelectionUnderCanvasProperties(Canvas selectionUnderCanvasProperties) 
        throws IllegalStateException 
    {
        if (selectionUnderCanvasProperties.isCreated()) {
            ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), 
                     "setSelectionUnderCanvasProperties", "Canvas");
        }                                                                       
        selectionUnderCanvasProperties.setConfigOnly(true);

        JavaScriptObject configJS = selectionUnderCanvasProperties.getConfig();
        setAttribute("selectionUnderCanvasProperties", JSOHelper.cleanProperties(configJS, true), false);
    }

    /**
     * Properties to apply to the auto-generated {@link #getRollOverCanvas(Integer, Integer) rollOverCanvas}
     * AutoChild when its use is enabled.
     *
     * @param rollOverCanvasProperties the <code>rollOverCanvas</code> properties
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see #setShowRollOverCanvas(Boolean)
     */
    public void setRollOverCanvasProperties(Canvas rollOverCanvasProperties) 
        throws IllegalStateException 
    {
        if (rollOverCanvasProperties.isCreated()) {
            ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), "setRollOverCanvasProperties",
                                                    "Canvas");
        }                                                                       
        rollOverCanvasProperties.setConfigOnly(true);

        JavaScriptObject configJS = rollOverCanvasProperties.getConfig();
        setAttribute("rollOverCanvasProperties", JSOHelper.cleanProperties(configJS, true), false);
    }

    /**
     * Properties to apply to the auto-generated {@link #getRollUnderCanvas(Integer, Integer) rollUnderCanvas}
     * AutoChild when its use is enabled.
     *
     * @param rollUnderCanvasProperties the <code>rollUnderCanvas</code> properties
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see #setShowRollUnderCanvas(Boolean)
     */
    public void setRollUnderCanvasProperties(Canvas rollUnderCanvasProperties) 
        throws IllegalStateException 
    {
        if (rollUnderCanvasProperties.isCreated()) {
            ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), "setRollUnderCanvasProperties",
                                                    "Canvas");
        }                                                                       
        rollUnderCanvasProperties.setConfigOnly(true);

        JavaScriptObject configJS = rollUnderCanvasProperties.getConfig();
        setAttribute("rollUnderCanvasProperties", JSOHelper.cleanProperties(configJS, true), false);
    }

    /**
     * Bind to a DataSource.
     * <P>
     * Binding to a DataSource means that the component will use the DataSource to provide default data for
     * its fields.
     * <P>
     * When binding to a new DataSource, if the component has any existing "fields" or has a dataset,
     * these will be discarded by default, since it is assumed the new DataSource may represent a completely
     * unrelated set of objects. If the old "fields" are still relevant, pass them to setDataSource().
     * @param dataSource
     * @param fields
     */
    public void setDataSource(DataSource dataSource, ListGridField... fields) {
        if (!isCreated()) {
            setFields(fields);
            setDataSource(dataSource);
        } else {
            JavaScriptObject jsFields = null;
            if (fields != null) {
                jsFields = JSOHelper.createJavaScriptArray();
                for (int i = 0; i < fields.length; i++) {
                    JSOHelper.setArrayValue(jsFields, i, fields[i].getJsObj());
                }
            }
            setDataSourceJS(dataSource.getOrCreateJsObj(), jsFields);
        }
    }
    private native void setDataSourceJS(JavaScriptObject dataSource, JavaScriptObject fields) /*-{
        var self = this.@com.smartgwt.client.widgets.grid.ListGrid::getJsObj()();
        self.setDataSource(dataSource, fields);
    }-*/;

    /**
     * If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanExpandRecords canExpandRecords} is true and {@link
     * com.smartgwt.client.types.ExpansionMode listGrid.expansionMode} is <code>"related"</code>, this property specifies the
     * dataSource for the  related records grid to be shown embedded in expanded records. <P> This property may also be
     * specified on a per-record basis - see  {@link com.smartgwt.client.widgets.grid.ListGrid#getRecordDetailDSProperty
     * recordDetailDSProperty}
     *
     *
     * @param detailDS detail datasource
     */
    public void setDetailDS(DataSource detailDS) {
        setAttribute("detailDS", detailDS == null ? null : detailDS.getOrCreateJsObj(), true);
    }

    /**
     * Standard properties to apply to the automatically generated checkbox field, shown when
     * {@link #setSelectionAppearance() selectionAppearance} is set to "checkbox".
     * <P>
     * Any properties applied to the ListGridField passed in will be overlaid onto the automatically
     * generated checkbox field, allowing the developer to customize this field - for example
     * modifying the appearance for skinning purposes, or setting <code>shouldPrint</code> to
     * include the field in the print-view of the grid.
     * @param checkboxField properties to apply to the checkbox field
     */
    public void setCheckboxFieldProperties (ListGridField checkboxField) {
        JavaScriptObject config = JSOHelper.createObject();
        JSOHelper.addProperties(config, checkboxField.getJsObj());
        setAttribute("checkboxFieldProperties", config, true);
    }

    /**
     * Scroll the body of the grid to the specified coordinates.
     *
     * @param left the left position
     * @param top the top position
     */
    public native void scrollBodyTo(Integer left, Integer top)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var body = self.body;
        if (body == null) return;
        var leftJS = left == null ? null : left.@java.lang.Integer::intValue()();
        var topJS = top == null ? null : top.@java.lang.Integer::intValue()();
        body.scrollTo(leftJS, topJS);
     }-*/;

    /**
     * Get the current scrollLeft for the body of this ListGrid
     * @return left scroll coordinate. May be null if this component has not been drawn.
     */
    public native Integer getBodyScrollLeft() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var body = self.body;
        if (body == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(body.getScrollLeft());
    }-*/;

    /**
     * Get the current scrollTop for the body of this ListGrid
     * @return top scroll coordinate. May be null if this component has not been drawn.
     */
    public native Integer getBodyScrollTop() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var body = self.body;
        if (body == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(body.getScrollTop());
    }-*/;

    /**
     * Start editing a new row, after the last pre-existing record in the current set of data. This new row will be
     * saved via the "add" DataSource operation. If editing is already underway elsewhere in the grid, startEditingNew()
     * behaves just like {@link com.smartgwt.client.widgets.grid.ListGrid#startEditing()}.
     *
     * @param defaultRecordValue the default field values for the new record
     */
    public native void startEditingNew(Record defaultRecordValue) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var defaultValuesJS = defaultRecordValue.@com.smartgwt.client.data.Record::getJsObj()();
        delete defaultValuesJS['__ref'];
        self.startEditingNew(defaultValuesJS);
    }-*/;

    /**
     * The selection associated with the listGrid.
     *
     * @return the selection
     * @deprecated use {@link #getSelectedRecords()} instead
     */
    public native ListGridRecord[] getSelection() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var selectionJS =  self.getSelection();
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(selectionJS);
    }-*/;

    /**
     * The selection associated with the listGrid.
     *
     * @param excludePartialSelections when true, partially selected records will not be returned. Otherwise, both fully and partially selected records are returned.
     * @return the selection
     * @deprecated use {@link #getSelectedRecords(boolean)} instead
     */
    public native ListGridRecord[] getSelection(boolean excludePartialSelections) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var selectionJS =  self.getSelection(excludePartialSelections);
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(selectionJS);
    }-*/;

    private native JavaScriptObject getEditFormItemJS(String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var fieldJS = self.getEditFormItem(fieldName);
        return fieldJS;
    }-*/;
    
    private native JavaScriptObject getEditFormItemJS(Integer fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
	    var fieldJS = self.getEditFormItem(fieldName);
	    return fieldJS;
	}-*/;

    /**
     * Method to retrieve a live edit form item for an {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit editable}
     * ListGrid. This is the automatically generated editor displayed in a cell while editing the grid. <P> Note that this is
     * an advanced method and developers should be aware of the following issues: <ul><li>Edit form items are only present
     * while a user is actually editing a cell. This method will return null if the user is not editing the grid or the field
     * in question is not editable or not visible. Note that due to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowAllColumns incremental rendering} columns which are not currently
     * scrolled into view may be unrendered, in which case they may have no associated edit item until the user scrolls them
     * into view.</li> <li>The items' values are managed by the ListGrid through the edit-values subsystem. If you want to
     * change an edit value for a field, call {@link com.smartgwt.client.widgets.grid.ListGrid#setEditValue
     * ListGrid.setEditValue} and the grid will handle updating the value in the live item if necessary. You should not need to
     * call <code>setValue();</code> directly on the item and doing so will not always update the edit value for the grid.
     * </li></ul> In general - bear in mind that this is an advanced usage and if there is an equivalent API available on the
     * ListGrid it is always preferable to use that.
     * @param field fieldName or colNum to get the edit item for.
     *
     * @return the live edit item for the current edit row and specified field, or null if the grid is not currently showing any
     * editors.
     */
    public FormItem getEditFormItem(Integer field) {
    	JavaScriptObject fieldJS = getEditFormItemJS(field);
        return fieldJS != null ? FormItemFactory.getFormItem(fieldJS) : null;
    }

    /**
     * Method to retrieve a live edit form item for an {@link com.smartgwt.client.widgets.grid.ListGrid#getCanEdit editable}
     * ListGrid. This is the automatically generated editor displayed in a cell while editing the grid. <P> Note that this is
     * an advanced method and developers should be aware of the following issues: <ul><li>Edit form items are only present
     * while a user is actually editing a cell. This method will return null if the user is not editing the grid or the field
     * in question is not editable or not visible. Note that due to {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowAllColumns incremental rendering} columns which are not currently
     * scrolled into view may be unrendered, in which case they may have no associated edit item until the user scrolls them
     * into view.</li> <li>The items' values are managed by the ListGrid through the edit-values subsystem. If you want to
     * change an edit value for a field, call {@link com.smartgwt.client.widgets.grid.ListGrid#setEditValue
     * ListGrid.setEditValue} and the grid will handle updating the value in the live item if necessary. You should not need to
     * call <code>setValue();</code> directly on the item and doing so will not always update the edit value for the grid.
     * </li></ul> In general - bear in mind that this is an advanced usage and if there is an equivalent API available on the
     * ListGrid it is always preferable to use that.
     * @param field fieldName or colNum to get the edit item for.
     *
     * @return the live edit item for the current edit row and specified field, or null if the grid is not currently showing any
     * editors.
     */
    public FormItem getEditFormItem(String field) {
    	JavaScriptObject fieldJS = getEditFormItemJS(field);
        return fieldJS != null ? FormItemFactory.getFormItem(fieldJS) : null;
    }

    /**
     * Open the current record detail grid inline,
     *
     * @param record the record
     * @param detailDataSource the detail data source
     * @deprecated use {@link #setCanExpandRecords(Boolean)} with {@link #setExpansionMode(com.smartgwt.client.types.ExpansionMode)}, or override {@link #getExpansionComponent(ListGridRecord)}
     */
    public native void openRecordDetailGrid(ListGridRecord record, DataSource detailDataSource)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.widgets.grid.ListGridRecord::getJsObj()();
        var datasourceJS = detailDataSource.@com.smartgwt.client.data.DataSource::getOrCreateJsObj()();
        self.openRecordDetailGrid(recordJS, datasourceJS);
     }-*/;

    /**
     * Close the inline detail grid associated with the record.
     *
     * @param record the record
     * @deprecated use {@link #setCanExpandRecords(Boolean)} with {@link #setExpansionMode(com.smartgwt.client.types.ExpansionMode)}, or override {@link #getExpansionComponent(ListGridRecord)}
     */
    public native void closeRecord(ListGridRecord record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.widgets.grid.ListGridRecord::getJsObj()();
        self.closeRecord(recordJS);
     }-*/;

    /**
     * Open the record editor associated with the record.
     *
     * @param record the record
     * @deprecated use {@link #setCanExpandRecords(Boolean)} with {@link #setExpansionMode(com.smartgwt.client.types.ExpansionMode)}, or override {@link #getExpansionComponent(ListGridRecord)}
     */
    public native void openRecordEditor(ListGridRecord record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.widgets.grid.ListGridRecord::getJsObj()();
        self.openRecordEditor(recordJS);
     }-*/;

    /**
     * Display the current set of records grouped by their values for the given field or fields. With no arguments,
     * disables all grouping. <P> Grouping transforms the current dataset into a Tree on the fly, then provides a
     * familiar tree interface for exploring the grouped data. <P> Grouping works automatically with any dataset,
     * providing simple default grouping based on each field's declared type.  However, you can use the {@link
     * com.smartgwt.client.widgets.grid.ListGridField#getGroupValue} API to control how records are grouped, and the
     * {@link com.smartgwt.client.widgets.grid.ListGridField#getGroupTitle} API to control how groups are titled. <P>
     * Grouping can be performed programmatically via this API, or you can set {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanGroupBy canGroupBy} to enable menus that allow the user to
     * performing grouping. To group a grid automatically, instantiate the grid with a  {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getGroupByField groupByField} setting. <P> While grouped, the
     * automatically created Tree is available as {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTree
     * groupTree} and the original dataset is available as {@link com.smartgwt.client.widgets.grid.ListGrid#getOriginalData
     * originalData}.
     */
    public native void groupBy(String... fields) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        fieldsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields);
        self.groupBy(fieldsJS);
    }-*/;


    /**
     * @see #sort()
     * @param sortCol the column number to sort by
     * @param sortDirection the direction to sort in
     * @return sorting worked
     */
    public native Boolean sort(int sortCol, SortDirection sortDirection) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var retVal =self.sort(sortCol, sortDirection.@com.smartgwt.client.types.SortDirection::getValue()());
        if(retVal == null) {
            return null;
        } else {
            return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(retVal);
        }
    }-*/;

    /**
     * Save a number of outstanding edits for this ListGrid. If no rows are specified, all
     * outstanding edits will be saved.
     *
     * @return true if a save has been initiated (at least one row had changes, passed client-side validation,
     *  and a save has been attempted).  false otherwise
     */
    public native boolean saveAllEdits() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        return self.saveAllEdits();
    }-*/;

    /**
     * Save a number of outstanding edits for this ListGrid. If no rows are specified, all
     * outstanding edits will be saved.
     *
     *
     * @param callback this callback will be fired on a successful save. Note that if there are no pending edits to be saved this
     * callback will not fire - you can check for this condition using {@link #hasChanges()} or {@link #rowHasChanges()}.
     * Use {@link #addEditFailedHandler(EditFailedHandler)} to find out about failures encountered during saving (on a per-row basis).
     * @return true if a save has been initiated (at least one row had changes, passed client-side validation, and a save has been attempted).  false otherwise
     */
    public native boolean saveAllEdits(Function callback) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        return self.saveAllEdits(null, callback == null ? null : $entry(function() {
            callback.@com.smartgwt.client.core.Function::execute()();
        }));
    }-*/;

    /**
     * Save a number of outstanding edits for this ListGrid. If no rows are specified, all
     * outstanding edits will be saved.
     *
     * @param callback this callback will be fired on a successful save of the specified rows. Note that if there are no pending edits to be saved this
     * callback will not fire - you can check for this condition using {@link #hasChanges()} or {@link #rowHasChanges()}.
     * Use {@link #addEditFailedHandler(EditFailedHandler)} to find out about failures encountered during saving (on a per-row basis).
     * @param rows specify which rows to save
     * @return true if a save has been initiated (at least one row had changes, passed client-side validation, and a save has been attempted).  false otherwise
     */
    public native boolean saveAllEdits(Function callback, int[] rows) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var rowsJS = rows == null ? null : @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(rows);
        return self.saveAllEdits(rowsJS, callback == null ? null : $entry(function() {
            callback.@com.smartgwt.client.core.Function::execute()();
        }));
    }-*/;

    /**
     * @see #freezeField(int)
     */
    public native void freezeFields(int[] colNums) /*-{
        if (colNums == null) return;
        var jsColNums = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(colNums);
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(jsColNums);
    }-*/;

    /**
     * @see #freezeField(String)
     */
    public native void freezeFields(String[] fieldNames) /*-{
        if (fieldNames == null) return;
        var jsFieldNames = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fieldNames);
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.freezeField(jsFieldNames);
    }-*/;
    
    /**
     * @see #unfreezeField(int)
     */
    public native void unfreezeFields(int[] colNums) /*-{
        if (colNums == null) return;
        var jsColNums = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(colNums);
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(jsColNums);
    }-*/;

    /**
     * @see #unfreezeField(String)
     */
    public native void unfreezeFields(String[] fieldNames) /*-{
        if (fieldNames == null) return;
        var jsFieldNames = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fieldNames);
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.unfreezeField(jsFieldNames);
    }-*/;


    /**
     * Refresh an individual cell without redrawing the grid. <P> The cell's value, CSS class, and CSS text will be
     * refreshed, to the current values returned by getCellValue(), getCellStyle() and getCellCSSText() respectively.
     *
     * @param rowNum row number of cell to refresh
     * @param colNum column number of cell to refresh
         */
    public native void refreshCell(int rowNum, int colNum, boolean refreshingRow, boolean allowEditCellRefresh) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.refreshCell(rowNum, colNum, refreshingRow, allowEditCellRefresh);
    }-*/;

    /**
     * Get the rows that are currently visible in the viewport, as an array of  [firstRowNum, lastRowNum]. If the grid contains no records, will return [-1,-1];
     *
     * @return the visible rows
     */
    public native Integer[] getVisibleRows() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getVisibleRows();
        return @com.smartgwt.client.util.JSOHelper::convertToJavaIntegerArray(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
     * Get the rows that are currently drawn (exist in the DOM), as an array of [firstRowNum, lastRowNum].   <P> The drawn rows differ from the {@link com.smartgwt.client.widgets.grid.ListGrid#getVisibleRows} because of {@link com.smartgwt.client.widgets.grid.ListGrid#getDrawAheadRatio drawAheadRatio}.  The drawn rows are the apppropriate range to consider if you need to, eg, using {@link com.smartgwt.client.widgets.grid.ListGrid#refreshCell} to update all the cells in a column. <P> If the grid is undrawn or the {@link com.smartgwt.client.widgets.grid.ListGrid#getEmptyMessage emptyMessage} is currently shown, returns [null,null];
     *
     * @return the drawn rows
     */
    public native Integer[] getDrawnRows() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getDrawnRows();
        return @com.smartgwt.client.util.JSOHelper::convertToJavaIntegerArray(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
	 * @see #fetchRelatedData(ListGridRecord,Canvas)
     * @param record     the DataSource record
     * @param dataSource the schema of the DataSource record
     */
    public native void fetchRelatedData(Record record, DataSource dataSource) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        var datasourceJS = dataSource.@com.smartgwt.client.data.DataSource::getOrCreateJsObj()();
        self.fetchRelatedData(recordJS, datasourceJS);
    }-*/;

    /**
	 * @see #fetchRelatedData(ListGridRecord,Canvas)
     * @param record            the DataSource record
     * @param dataSource        the schema of the DataSource record
     * @param callback          callback to invoke on completion
     * @param requestProperties additional properties to set on the DSRequest that will be issued
     */
    public native void fetchRelatedData(Record record, DataSource dataSource, DSCallback callback, DSRequest requestProperties) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        var datasourceJS = dataSource.@com.smartgwt.client.data.DataSource::getOrCreateJsObj()();
        var requestPropertiesJS = requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()();

        self.fetchRelatedData(recordJS, datasourceJS, $entry(function (dsResponse, data, dsRequest) {
            var responseJ = @com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse);
            var requestJ = @com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest);
            if(callback != null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(responseJ, data, requestJ);
        }), requestPropertiesJS);

    }-*/;

    /**
     * Returns the primary body, which, when there are frozen fields, is the {@link com.smartgwt.client.grid.GridRenderer}
     * used to render the non-frozen portion of the dataset; otherwise, the primary body (the
     * only body) is the GridRenderer used to render the entire dataset.
     *
     * @return the primary body or null if this ListGrid has not been drawn yet.
     */
    public native GridRenderer getBody() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isDrawn()()) {
            var self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            if (self != null) {
                return @com.smartgwt.client.widgets.grid.GridRenderer::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(self.body);
            }
        }
        return null;
    }-*/;

    /**
     * Synonym of {@link #getBody()}.
     */
    public GridRenderer getGridRenderer() {
        return getBody();
    }
    
    /**
     * @see #getEditedCell(int, int)
     */
    public native Object getEditedCell(int rowNum, String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var value = self.getEditedCell(rowNum, fieldName);
        var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, self, fieldName);
        return valueJ;
    }-*/;

    /**
     * @see #getEditedCell(int, int)
     */
    public native Object getEditedCell(Record record, String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        var value = self.getEditedCell(recordJS, fieldName);
        var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, self, fieldName);
        return valueJ;
    }-*/;

    /**
     * @see #getEditedCell(int, int)
     */
    public native Object getEditedCell(Record record, int colNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        var value = self.getEditedCell(recordJS, colNum);
        var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, self, colNum);
        return valueJ;
    }-*/;

    /**
     * Returns the combination of unsaved edits (if any) and original values (if any) for a given row being edited.
     * <p>
     *
     * The returned value is never null, and can be freely modified.
     *
     * @param rowNum the row num
     * @return A copy of the record with unsaved edits included
     */
    public native Record getEditedRecord(int rowNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var record = self.getEditedRecord(rowNum);
        if (record == null) return null;
        var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
        return recordJ;
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Object value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var jsValue = null;
        if (value != null) jsValue = $wnd.SmartGWT.convertToPrimitiveType(value);
        self.setEditValue(rowNum, colNum, jsValue);
    }-*/;
    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, String value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Date value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptDate(Ljava/util/Date;)(value);
        self.setEditValue(rowNum, colNum, valueJS);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, double value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, boolean value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Boolean value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value == null ? null : value.@java.lang.Boolean::booleanValue()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, float value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, int value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Integer value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value == null ? null : value.@java.lang.Integer::intValue()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Record value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value == null ? null : value.@com.smartgwt.client.data.Record::getJsObj()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param colNum column number of cell
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, Record[] value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value == null ? null : @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(value));
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName  the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, int colNum, JavaScriptObject value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, colNum, value);
    }-*/;


    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, String value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Date value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptDate(Ljava/util/Date;)(value);
        self.setEditValue(rowNum, fieldName, valueJS);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, double value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, boolean value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Boolean value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value == null ? null : value.@java.lang.Boolean::booleanValue()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, float value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, int value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Integer value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value == null ? null : value.@java.lang.Integer::intValue()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName  the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Record value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value == null ? null : value.@com.smartgwt.client.data.Record::getJsObj()());
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName  the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Record[] value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value == null ? null : @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(value));
    }-*/;

    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName  the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, JavaScriptObject value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditValue(rowNum, fieldName, value);
    }-*/;
    
    /**
     * Modifies a field value being tracked as an unsaved user edit.
     *
     * @param rowNum row number
     * @param fieldName  the field name
     * @param value new value for the appropriate field
     */
    public native void setEditValue(int rowNum, String fieldName, Object value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var jsValue = null;
        if (value != null) jsValue = $wnd.SmartGWT.convertToPrimitiveType(value);
        self.setEditValue(rowNum, fieldName, jsValue);
    }-*/;
    
    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public native Object getEditValue(int rowNum, String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var value = self.getEditValue(rowNum, fieldName);
        var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, self, fieldName);
        return valueJ;
    }-*/;

    private native JavaScriptObject getEditValueAsJSObj(int rowNum, String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var value = self.getEditValue(rowNum, fieldName);
        return value;
    }-*/;

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public String getEditValueAsString(int rowNum, String fieldName) {
        return (String) getEditValue(rowNum, fieldName);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Integer getEditValueAsInt(int rowNum, String fieldName) {
        return (Integer)getEditValue(rowNum, fieldName);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Float getEditValueAsFloat(int rowNum, String fieldName) {
        return (Float) getEditValue(rowNum, fieldName);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Date getEditValueAsDate(int rowNum, String fieldName) {
        return (Date) getEditValue(rowNum, fieldName);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Boolean getEditValueAsBoolean(int rowNum, String fieldName) {
        return (Boolean) getEditValue(rowNum, fieldName);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Record getEditValueAsRecord(int rowNum, String fieldName) {
        JavaScriptObject val = getEditValueAsJSObj(rowNum, fieldName);
        if (val == null) return null;
        return Record.getOrCreateRef(val);
    }

    /**
     * Returns the current temporary locally stored edit value for some field within a record being edited.
     *
     * @param rowNum index of the row for which the editValue should be returned
     * @param fieldName field name for which value should be returned
     *
     * @return   edit value for the field in question
     */
    public Record[] getEditValueAsRecordArray(int rowNum, String fieldName) {
        JavaScriptObject val = getEditValueAsJSObj(rowNum, fieldName);
        if (val == null) return null;
        return Record.convertToRecordArray(val);
    }

    /**
     * Returns the current set of unsaved edits for a given row being edited.
     *
     * @param rowNum rowNum of the record being edited
     * @return current editValues object for the row. This contains the current edit values in {fieldName1:value1, fieldName2:value2} format
     */
    public native Map getEditValues(int rowNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var value = self.getEditValues(rowNum);
        var valueJ = @com.smartgwt.client.util.JSOHelper::convertToMap(Lcom/google/gwt/core/client/JavaScriptObject;)(value);
        return valueJ;
    }-*/;

    /**
     * Returns the current set of unsaved edits for a given row being edited.
     *
     * @param record an Object containing values for all the record's primary keys
     * @return current editValues object for the row. This contains the current edit values in {fieldName1:value1, fieldName2:value2} format
     */
    public native Map getEditValues(Record record) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        var value = self.getEditValues(recordJS);
        var valueJ = @com.smartgwt.client.util.JSOHelper::convertToMap(Lcom/google/gwt/core/client/JavaScriptObject;)(value);
        return valueJ;
    }-*/;


	/**
     * Sort the grid on one or more fields. <P> Pass in an array of {@link
     * com.smartgwt.client.data.SortSpecifier}s to have the grid's data sorted by the fields in
     * each {@link com.smartgwt.client.data.SortSpecifier#getProperty specifier.property} and
     * in the directions specified.  The grid can be sorted by any combination of fields,
     * including fields specified in the fields array, whether visible or hidden, and {@link
     * com.smartgwt.client.data.DataSource#getFields unused fields from the underlying
     * dataSource}, if there is one.
     * <P> 
     * If multiple fields are sorted, those that are visible show a directional icon and a
     * small {@link com.smartgwt.client.widgets.grid.ListGrid#getSortNumeralStyle sort-numeral}
     * indicating that field's index in the sort configuration.
     * <P>
     * If setSort() is called on a ListGrid which doesn't yet have a SmartClient widget, the
     * widget will not be created; instead, the initial sort for the ListGrid will be set as
     * if by {@link com.smartgwt.client.widgets.grid.ListGrid#setInitialSort}.
     * <P>
     * See {@link com.smartgwt.client.widgets.grid.ListGrid#addSort addSort()} and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#toggleSort toggleSort()} APIs for information
     * on making changes to the current sort configuration.
     * @param sortSpecifiers Array of {@link com.smartgwt.client.data.SortSpecifier} objects
     */
    public native void setSort(SortSpecifier... sortSpecifiers) /*-{
        var sortSpecifiersJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(sortSpecifiers);
        if (this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            var self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            self.setSort(sortSpecifiersJS);
        } else {
            var config = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            config.initialSort = sortSpecifiersJS;
        }
    }-*/;

    /**
     * Set the validation errors for some row (replacing any pre-existent validation errors)
     *
     *
     * @param rowNum row to add validation error for
     * @param errors validation errors for the row. The key of the map must be the field name, and the value can either be a String error message
     * or an array of Strings for multiple errors
     */
    public native void setRowErrors(int rowNum, Map errors) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var errorsJS = @com.smartgwt.client.util.JSOHelper::convertMapToJavascriptObject(Ljava/util/Map;)(errors);
        self.setRowErrors(rowNum, errorsJS);
    }-*/;

    /**
     * @see #setFieldError(int, int, String)
     * @param rowNum row index of cell to add validation error for
     * @param fieldName field name of cell to add validation error for
     * @param errorMessages validation error messages
     */
    public native void setFieldError(int rowNum, String fieldName, String[] errorMessages) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var errorsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(errorMessages);
        self.setFieldError(rowNum, fieldName, errorsJS);
    }-*/;

    /**
     * Select a single {@link com.smartgwt.client.data.Record} passed in explicitly, or by index, and deselect everything else. When programmatic selection of records is a requirement and {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType}  is "single", use this method rather than {@link com.smartgwt.client.widgets.grid.ListGrid#selectRecord} to  enforce mutually-exclusive record-selection.
     * @param record record to select
     */
    public native void selectSingleRecord(Record record) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectSingleRecord(record.@com.smartgwt.client.data.Record::getJsObj()());
    }-*/;

    /**
     * Select a single {@link com.smartgwt.client.data.Record} passed in explicitly, or by index, and deselect everything else. When programmatic selection of records is a requirement and {@link com.smartgwt.client.widgets.grid.ListGrid#getSelectionType selectionType}  is "single", use this method rather than {@link com.smartgwt.client.widgets.grid.ListGrid#selectRecord} to  enforce mutually-exclusive record-selection.
     * @param rowNum rowNum (or row number) to select
     */
    public native void selectSingleRecord(int rowNum) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectSingleRecord(rowNum);
    }-*/;

    /**
     * Get the computed value of a {@link com.smartgwt.client.widgets.grid.ListGrid#getCanAddFormulaFields canAddFormulaFields}.
     * Returns null for a bad formula or where the result is not a valid number.
     *
     * @param field  field that has a formula
     * @param record record to use to compute formula value
     * @return formula result
     */
    public native Double getFormulaFieldValue(ListGridField field, Record record) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(),
            value = self.getFormulaFieldValue(field.@com.smartgwt.client.widgets.grid.ListGridField::getJsObj()(),
                                              record.@com.smartgwt.client.data.Record::getJsObj()());
        return $wnd.isc.isA.Number(value)? @java.lang.Double::valueOf(D)(value) : null;
    }-*/;

    /**
     * Sets this component's filter criteria. Default implementation calls this.data.setCriteria()
     * @param  criteria new criteria to show
     */
    public native void setCriteria(Criteria criteria) /*-{
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
                self.setCriteria(criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()());
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            obj.initialCriteria = (criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()());
        }
    }-*/;

    /**
     * Validate the current edit value for the cell in question.  Called when the user moves to a&#010 new edit cell if {@link com.smartgwt.client.widgets.grid.ListGrid#getValidateByCell validateByCell} is true.<br>&#010 This method may also be called directly to perform cell level validation at any time.&#010
     *
     * @param rowNum    index of row to be validated.
     * @param colIndex column index of field to be validated
     * @return returns true if validation was successful (no errors encountered), false otherwise.
     */
    public native Boolean validateCell(int rowNum, int colIndex) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var retVal =self.validateCell(rowNum, colIndex);
        if(retVal == null) {
            return null;
        } else {
            return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(retVal);
        }
    }-*/;

    /**
     * Given a rowNum and a colNum or fieldName, determine whether we currently have stored &#010 validation errors for the record/field in question.&#010
     *
     * @param rowNum  index of row to check for validation errors
     * @param colIndex index of column to check for validation                                       errors
     * @return true if we have validation errors for the row/col in question
     */
    public native Boolean cellHasErrors(int rowNum, int colIndex) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var retVal =self.cellHasErrors(rowNum, colIndex);
        if(retVal == null) {
            return null;
        } else {
            return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(retVal);
        }
    }-*/;


    /**
     * @see #clearFieldError(int, int)
     * @param rowNum    row index of cell to add validation error for
     * @param fieldName field name of cell to add validation error for
     */
    public native void clearFieldError(int rowNum, String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.clearFieldError(rowNum, fieldName);
    }-*/;

    /**
     * Set the value map for a field.&#010 See also the {@link com.smartgwt.client.widgets.grid.ListGrid#setEditorValueMap}&#010 and {@link com.smartgwt.client.widgets.grid.ListGrid#getEditorValueMap} methods which allow further &#010 customization of the valueMap displayed while the field is in edit mode.&#010&#010
     *
     * @param fieldName Name  of field to update
     * @param valueMap ValueMap for the field
     */
    public native void setValueMap(String fieldName, java.util.LinkedHashMap valueMap) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setValueMap(fieldName, @com.smartgwt.client.util.JSOHelper::convertMapToJavascriptObject(Ljava/util/Map;)(valueMap));
    }-*/;

    /**
     * Set the value map for a field.&#010 See also the {@link com.smartgwt.client.widgets.grid.ListGrid#setEditorValueMap}&#010 and {@link com.smartgwt.client.widgets.grid.ListGrid#getEditorValueMap} methods which allow further &#010 customization of the valueMap displayed while the field is in edit mode.&#010&#010
     *
     * @param fieldName Name  of field to update
     * @param valueMap ValueMap for the field
     */
    public native void setValueMap(String fieldName, String... valueMap) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setValueMap(fieldName, @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(valueMap));
    }-*/;


    /**
     * Set a valueMap to display for this field while editing.<br>
     * This method sets the +link{ListGridField.editorValueMap, field.editorValueMap} property and may be called
     * at runtime while editing the grid.
     *
     * @param fieldName Name  of field to update
     * @param valueMap ValueMap for the field
     */
    public native void setEditorValueMap(String fieldName, java.util.LinkedHashMap valueMap) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditorValueMap(fieldName, @com.smartgwt.client.util.JSOHelper::convertMapToJavascriptObject(Ljava/util/Map;)(valueMap));
    }-*/;

    /**
     * Set a valueMap to display for this field while editing.<br>
     * This method sets the +link{ListGridField.editorValueMap, field.editorValueMap} property and may be called
     * at runtime while editing the grid.
     *
     * @param fieldName Name  of field to update
     * @param valueMap ValueMap for the field
     */
    public native void setEditorValueMap(String fieldName, String... valueMap) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.setEditorValueMap(fieldName, @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(valueMap));
    }-*/;


    /**
     * Given a field with a specified {@link com.smargwt.client.widgets.grid.ListGridField#setValueMap() valueMap}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#setDisplayField() displayField},
     * this method will return the display value for any underlying data value.
     * @param fieldName Name of the field for which the displayValue is required
     * @param value data value for the field
     */
    public native Object getDisplayValue(String fieldName, int value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = self.getDisplayValue(fieldName, value);
        var valueJ = $wnd.SmartGWT.convertToJavaType(valueJS);
        return valueJ;
    }-*/;

    /**
     * Given a field with a specified {@link com.smargwt.client.widgets.grid.ListGridField#setValueMap() valueMap}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#setDisplayField() displayField},
     * this method will return the display value for any underlying data value.
     * @param fieldName Name of the field for which the displayValue is required
     * @param value data value for the field
     */
    public native Object getDisplayValue(String fieldName, float value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = self.getDisplayValue(fieldName, value);
        var valueJ = $wnd.SmartGWT.convertToJavaType(valueJS);
        return valueJ;
    }-*/;

    /**
     * Given a field with a specified {@link com.smargwt.client.widgets.grid.ListGridField#setValueMap() valueMap}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#setDisplayField() displayField},
     * this method will return the display value for any underlying data value.
     * @param fieldName Name of the field for which the displayValue is required
     * @param value data value for the field
     */
    public native Object getDisplayValue(String fieldName, String value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = self.getDisplayValue(fieldName, value);
        var valueJ = $wnd.SmartGWT.convertToJavaType(valueJS);
        return valueJ;
    }-*/;

    /**
     * Given a field with a specified {@link com.smargwt.client.widgets.grid.ListGridField#setValueMap() valueMap}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#setDisplayField() displayField},
     * this method will return the display value for any underlying data value.
     * @param fieldName Name of the field for which the displayValue is required
     * @param value data value for the field
     */
    public native Object getDisplayValue(String fieldName, boolean value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var valueJS = self.getDisplayValue(fieldName, value);
        var valueJ = $wnd.SmartGWT.convertToJavaType(valueJS);
        return valueJ;
    }-*/;

    /**
     * Given a field with a specified {@link com.smargwt.client.widgets.grid.ListGridField#setValueMap() valueMap}
     * or {@link com.smartgwt.client.widgets.grid.ListGridField#setDisplayField() displayField},
     * this method will return the display value for any underlying data value.
     * @param fieldName Name of the field for which the displayValue is required
     * @param value data value for the field
     */
    public native Object getDisplayValue(String fieldName, Date value) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var dateJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptDate(Ljava/util/Date;)(value);
        var valueJS = self.getDisplayValue(fieldName, dateJS);
        var valueJ = $wnd.SmartGWT.convertToJavaType(valueJS);
        return valueJ;
    }-*/;

	/**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this method will  return the 
     * group summary data displayed  at the end of the group. <P> This method may  return multiple records if more than one
     * summary row per group is desired.
     * @param records the records in the group, for which the summary values                                  are being calculated
     * @param groupNode object with specified groupValue and groupName for                                        this group
     *
     * @return summary record(s)
     */
    public ListGridRecord[] getGroupSummaryData(Record[] records, GroupNode groupNode) {
        return this.getGroupSummaryData(records, new Record(groupNode.getJsObj()));
    }


	/**
     * If this grid is {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped}, and {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowGroupSummary showGroupSummary} is true, this method will  return the 
     * group summary data displayed  at the end of the group. <P> This method may  return multiple records if more than one
     * summary row per group is desired.
     * @param records the records in the group, for which the summary values                                  are being calculated
     * @param groupNode object with specified groupValue and groupName for                                        this group
     * @param recalculate if set to false and the node has existing summary data,                                 returns the stored summary data,
     * rather than recalculating
     *
     * @return summary record(s)
     */
    public ListGridRecord[] getGroupSummaryData(Record[] records, GroupNode groupNode, Boolean recalculate) {
        return this.getGroupSummaryData(records, new Record(groupNode.getJsObj()), recalculate);
    }

    /**
     * &#010  Clear a field value being tracked as an unsaved user edit.<P>&#010  The saved record value will be displayed in the the appropriate cell instead.&#010  Will also discard any validation errors for the specified field / row.&#010&#010
     *
     * @param rowNum   the row number
     * @param fieldName name of field for which the value is to be cleared
     */
    public native void clearEditValue(int rowNum, String fieldName) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.clearEditValue(rowNum, fieldName);
     }-*/;

    /**
     * This method overrides {@link com.smartgwt.client.widgets.Canvas#willAcceptDrop} and works as follows:<br> <ul> <li>If
     * {@link com.smartgwt.client.widgets.Canvas#willAcceptDrop} (the superclass definition) returns false, this      method
     * always returns false.  This allows {@link com.smartgwt.client.widgets.Canvas#getDragType dragType} and     {@link
     * com.smartgwt.client.widgets.Canvas#getDropTypes dropTypes} to be used to configure eligibility for drop.  By default,
     * a ListGrid has no dropTypes configured and so this check will not prevent a drop.</li> <li>If this is a self-drop, that
     * is, the user is dragging a record within this list, this is     an attempted drag-reorder.  If {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanReorderRecords canReorderRecords} is      false, this method returns
     * false.</li> <li>If the {@link com.smartgwt.client.util.EventHandler#getDragTarget} is another widget, if     {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getCanAcceptDroppedRecords canAcceptDroppedRecords} is false this method
     * returns false.</li> <li>If a call to {@link com.smartgwt.client.widgets.grid.ListGrid#getDragData} on the
     * <code>dragTarget</code> fails to return     an record object or an array of records, this method returns false.</li>
     * <li>If a the drop target record is disabled or has {@link
     * com.smartgwt.client.widgets.grid.ListGridRecord#getCanAcceptDrop canAcceptDrop}      set to false, return false.</li>
     * </ul> Note that this method may be called repeatedly during a drag-drop interaction to update the UI and notify the user
     * as to when they may validly drop data.
     *
     * <b> Note :</b> This is an override point
     *
     * @return true if this component will accept a drop of the dragData
     */
    public Boolean willAcceptDrop() {
    	return super.willAcceptDrop();
    }

    /**
     * Preload primary ListGrid skin images.
     */
    public static native void preloadImages() /*-{
        var skinImgDir = $wnd.isc.ListGrid.getInstanceProperty('skinImgDir');
        var canvasSkinImgDir = $wnd.isc.Canvas.getInstanceProperty('skinImgDir');
        var sortAscImg = $wnd.isc.ListGrid.getInstanceProperty('sortAscendingImage').src;
        var sortDescImg = $wnd.isc.ListGrid.getInstanceProperty('sortDescendingImage').src;
        var headerMenuButtonSrc = $wnd.isc.ListGrid.getInstanceProperty('headerMenuButtonSrc');

        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(skinImgDir, sortAscImg);
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(skinImgDir, sortDescImg);
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, headerMenuButtonSrc);

        var headerButtonImg = $wnd.isc.ListGrid.getInstanceProperty('headerButtonDefaults').src;
        @com.smartgwt.client.util.FileLoader::cacheImgStates(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, headerButtonImg, "Selected,Over,Selected_Over");

        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/column_preferences.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/freezeLeft.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/unfreeze.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/groupby.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/ungroup.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/sort_ascending.png');
        @com.smartgwt.client.util.FileLoader::cacheImg(Ljava/lang/String;Ljava/lang/String;)(canvasSkinImgDir, '[SKIN]/actions/sort_descending.png');
    }-*/;

    /**
     * Returns a numeric value for the width of some field within this <code>ListGrid</code>.
     * @param fieldName Name of the field for which the width is to be determined.
     *
     * @return width of the field in px, or <code>null</code> if the width can't be determined.
     */
    public native Integer getFieldWidth(String fieldName) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getFieldWidth(fieldName == null ? null : String(fieldName));
        if (ret == null) return null;
        return @com.smartgwt.client.util.JSOHelper::toInteger(I)(ret);
    }-*/;

    /**
     * Return the underlying, ungrouped data of this ListGrid as a {@link com.smartgwt.client.data.ResultSet}.
     * Use this method to access the data when the grid is grouped.
     * <p>
     * Note that this method should only be called after initial data has been fetched by this DataBoundComponent.
     *
     * @return ResultSet, or null if the underlying ungrouped data is not a ResultSet
     * @see #fetchData()
     */
    public ResultSet getOriginalResultSet() {
        JavaScriptObject dataJS = getAttributeAsJavaScriptObject("originalData");
        if(dataJS == null) return null;
        if(!ResultSet.isResultSet(dataJS)) {
            SC.logWarn("getOriginalResultSet(): data is not a ResultSet; returning null " +
                "(if ungrouped, use getOriginalResultSet(); if unbound, use getOriginalRecordList(); " +
                "can only be called on DataBoundComponents after initial data has been fetched)");
            return null;
        }
        return ResultSet.getOrCreateRef(dataJS);
    }

    /**
     * Return the underlying, ungrouped data of this DataBoundComponent as a {@link com.smartgwt.client.data.RecordList}.
     * <p>
     * If this grid {@link #isGrouped is grouped},
     * {@link com.smartgwt.client.widgets.DataBoundComponent#getRecordList} will return the
     * grouped data as a Tree.
     * Use this method to return the underlying Array of Records or
     * {@link com.smartgwt.client.data.ResultSet}, as if
     * the grid was ungrouped:
     * <pre>isGrouped() ? getOriginalRecordList() : getRecordList()</pre>
     * @return the RecordList
     */
    public RecordList getOriginalRecordList() {
        JavaScriptObject dataJS = getAttributeAsJavaScriptObject("originalData");
        if(dataJS == null) return null;

        if(ResultSet.isResultSet(dataJS)) {
            return getOriginalResultSet();
        }
        return new RecordList(dataJS);
    }

    /**
     * Sets a formatter that returns the HTML to display in each cell of the grid, 
     * given the raw cell value.  Can be overridden by defining 
     * {@link com.smartgwt.client.widgets.grid.ListGridField#setCellFormatter}.
     * @see com.smartgwt.client.widgets.grid.CellFormatter
     * @param formatter formatter to apply to the cell values
     */
    public native void setCellFormatter(CellFormatter formatter) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self =  this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.formatCellValue = $debox($entry(function(value, record, rowNum, colNum) {
            var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, this, colNum);
            return formatter.@com.smartgwt.client.widgets.grid.CellFormatter::format(Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(valueJ, recordJ, rowNum, colNum);
        }));
    }-*/;
    
	/**
     * Formatter for inactive content. <P> If present, this method will be invoked instead of {@link
     * com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter setCellFormatter()} in cases  where the grid is rendering
     * non-interactive content outside. Examples of cases where this can happen include:<ul> <li>dragTracker HTML for a row
     * when {@link com.smartgwt.client.widgets.grid.ListGrid#getDragTrackerMode dragTrackerMode} is set to "record"</li>
     * <li>measurement HTML used for sizing columns during autoFit</li> <li>measurement HTML used for sizing rows when {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getFixedRecordHeights fixedRecordHeights}     is false and the grid has both
     * frozen and unfrozen fields</li> </ul> May also be overridden at the field level (see {@link
     * com.smartgwt.client.widgets.grid.ListGridField#setInactiveCellFormatterfield}). <P> This is useful for cases where
     * it would not be appropriate to render the  standard formatted cell value outside of the body of the grid. An example
     * might be if the formatted value contains a DOM element with a specified ID - an approach sometimes used for integrating
     * third party components into Smart GWT listGrid cells. In this case developers will wish to avoid having the framework
     * render an element with the same ID outside of the grid, and should instead return HTML that would render at the same
     * size, with an appropriate appearance.
     * @param formatter formatter for inactive cells
     * @see com.smartgwt.client.widgets.grid.ListGrid#setCellFormatter
     * @see com.smartgwt.client.widgets.grid.ListGridField#setInactiveCellFormatter
     */
    public native void setInactiveCellFormatter(CellFormatter formatter) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self =  this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.formatInactiveCellValue = $debox($entry(function(value, record, rowNum, colNum) {
            var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            var valueJ = $wnd.SmartGWT.convertToDBCFieldJavaType(value, this, colNum);
            return formatter.@com.smartgwt.client.widgets.grid.CellFormatter::format(Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(valueJ, recordJ, rowNum, colNum);
        }));
    }-*/;

    /**
     * Provide a custom implementation of {@link #cellValueHoverHTML(ListGridRecord, int, int, String)}.
     * <p>
     * The <code>CellValueHoverFormatter</code> should return the HTML to display in the hover canvas
     * that is displayed by default if a registered {@link com.smartgwt.client.widgets.grid.events.CellValueHoverHandler}
     * does not cancel a {@link com.smartgwt.client.widgets.grid.events.CellValueHoverEvent}.
     * The formatter can return null or an empty string to cancel the hover.
     *
     * @param formatter the cell value hover formatter
     */
    public native void setCellValueHoverFormatter(CellValueHoverFormatter formatter) /*-{
        var self;
        if (this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }

        var newCellValueHoverHTMLFun;
        if (formatter == null) {
            newCellValueHoverHTMLFun = $wnd.isc[this.@com.smartgwt.client.widgets.BaseWidget::scClassName].getInstanceProperty("cellValueHoverHTML");
        } else {
            newCellValueHoverHTMLFun = $entry(function (record, rowNum, colNum, defaultHTML) {
                var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
                return formatter.@com.smartgwt.client.widgets.grid.CellValueHoverFormatter::getHoverHTML(Lcom/smartgwt/client/widgets/grid/ListGridRecord;IILjava/lang/String;)(recordJ, rowNum, colNum, defaultHTML);
            });
        }
        self.cellValueHoverHTML = newCellValueHoverHTMLFun;
    }-*/;

    /**
     * HTML to be shown in hovers over cells in the column described by this field. Note that the "value" passed to the HoverCustomizer
     * callback will be null when the HoverCustomizer is applied to the ListGrid. However when applied to a ListGridField, the appropriate field
     * value will be passed.
     *
     * @param dragTrackerIconCustomizer the dragTrackerIcon customizer
     */
    public native void setDragTrackerIconCustomizer(DragTrackerIconCustomizer dragTrackerIconCustomizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.getDragTrackerIcon = $debox($entry(function(records) {
            var recordArray = @com.smartgwt.client.util.ConvertTo::arrayOfRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(records);
            var gridJ = @com.smartgwt.client.widgets.BaseWidget::getRef(Lcom/google/gwt/core/client/JavaScriptObject;)(this);

            dragTrackerIconCustomizer.@com.smartgwt.client.widgets.grid.DragTrackerIconCustomizer::setGrid(Lcom/smartgwt/client/widgets/grid/ListGrid;)(gridJ);
            return dragTrackerIconCustomizer.@com.smartgwt.client.widgets.grid.DragTrackerIconCustomizer::getDragTrackerIcon([Lcom/smartgwt/client/data/Record;)(recordArray);
        }));
    }-*/;

    /**
     * This customizer is called to generate the HTML for the sortNumeral displayed next to a 
     * field's title when it is included in the current sort specification.
     *
     * @param customizer the sortNumeralHTML customizer
     */
    public native void setSortNumeralHTMLCustomizer(SortNumeralHTMLCustomizer customizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.getSortNumeralHTML = $debox($entry(function(fieldName, sortIndex) {
            var result = customizer.@com.smartgwt.client.widgets.grid.SortNumeralHTMLCustomizer::getSortNumeralHTML(Ljava/lang/String;I)(fieldName, sortIndex);
            if (result == null) return null;
            return result;
        }));
    }-*/;

    /**
     * This customizer is called to determine whether a given record can be selected in this grid.
     *
     * @param customizer the CanSelectRecordCustomizer customizer
     */
    public native void setCanSelectRecordCustomizer(CanSelectRecordCustomizer customizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            self.$_canSelectRecord = self.canSelectRecord;
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            // store the default implementation from the Class
            var scClassName = this.@com.smartgwt.client.widgets.BaseWidget::scClassName;
            self.$_canSelectRecord = $wnd.isc[scClassName].getInstanceProperty("canSelectRecord");
        }
        self.canSelectRecord = $debox($entry(function(record) {
            var recordJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            var gridJ  = @com.smartgwt.client.widgets.BaseWidget::getRef(Lcom/google/gwt/core/client/JavaScriptObject;)(this);
            var result = customizer.@com.smartgwt.client.widgets.grid.CanSelectRecordCustomizer::canSelectRecord(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Lcom/smartgwt/client/widgets/grid/ListGrid;)(recordJ, gridJ);
            if (result == null) {
                if (this.$_canSelectRecord) {
                    result = this.$_canSelectRecord(record);
                    if (result == null) return null;
                    return result;
                }
                return null;
            }
            return result.@java.lang.Boolean::booleanValue()();
        }));
    }-*/;

    /**
     * Return "title" HTML to display as a drag tracker when the user drags some record.<br>
     * Default implementation will display the cell value for the title field (see 
     * +link{listGrid.getTitleField()}) for the record(s) being dragged (including any
     * icons / custom formatting / styling, etc).
     * <p>
     * Note: Only called if +link{listGrid.dragTrackerMode} is set to <code>"title"</code>.
     *
     * @param dragTrackerIconCustomizer the dragTrackerIcon customizer
     */
    public native void setDragTrackerTitleCustomizer(DragTrackerTitleCustomizer dragTrackerTitleCustomizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.getDragTrackerTitle = $debox($entry(function(listGridRecord,number) {
            var record = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(listGridRecord);
            var gridJ  = @com.smartgwt.client.widgets.BaseWidget::getRef(Lcom/google/gwt/core/client/JavaScriptObject;)(this);
            
            dragTrackerTitleCustomizer.@com.smartgwt.client.widgets.grid.DragTrackerTitleCustomizer::setGrid(Lcom/smartgwt/client/widgets/grid/ListGrid;)(gridJ);
            
            return dragTrackerTitleCustomizer.@com.smartgwt.client.widgets.grid.DragTrackerTitleCustomizer::getDragTrackerTitle(Lcom/smartgwt/client/widgets/grid/ListGridRecord;I)(record,number);
        }));
    }-*/;

    /**
     * HTML to be shown in hovers over cells in the column described by this field. 
     *
     * @param hoverCustomizer the hover customizer
     * @see com.smartgwt.client.widgets.grid.ListGridField#setHoverCustomizer(HoverCustomizer)
     */
    public native void setHoverCustomizer(HoverCustomizer hoverCustomizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self =  this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.cellHoverHTML = $debox($entry(function(record, rowNum, colNum) {
            var recordJ   = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            var gridJ     = @com.smartgwt.client.widgets.BaseWidget::getRef(Lcom/google/gwt/core/client/JavaScriptObject;)(this);
            var fieldName = this.getFieldName(colNum);
            var valueJ    = null;
            
            if(fieldName!=null){
            	valueJ = $wnd.SmartGWT.convertToJavaType(this.getRawValue(record,fieldName));
            }

            hoverCustomizer.@com.smartgwt.client.widgets.grid.HoverCustomizer::setGrid(Lcom/smartgwt/client/widgets/grid/ListGrid;)(gridJ);
            return hoverCustomizer.@com.smartgwt.client.widgets.grid.HoverCustomizer::hoverHTML(Ljava/lang/Object;Lcom/smartgwt/client/widgets/grid/ListGridRecord;II)(valueJ, recordJ, rowNum, colNum);
        }));
    }-*/;

    /**
     * This method allows developers to dynamically customize the form item displayed in an editable grid, based
     * on the cell being edited.
     * Note that {@link ListGridField#setEditorType()} allows a simpler static customization of FormItem properties
     * for a specific field.
     * @param customizer
     */
    public native void setEditorCustomizer(ListGridEditorCustomizer customizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self =  this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
             self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        self.editorCustomizer = customizer;

        if (self.customEditorPropertiesFunction) return;
        self.customEditorPropertiesFunction = true;

        // disable reuse of form items since type is likely to change
        self.updateEditorItemsInPlace = false;

        self.getEditorProperties = $debox($entry(function(editField, editedRecord, rowNum) {
            var editProperties = this.Super("getEditorProperties", arguments);

            var editorContext = {
                defaultProperties:editProperties,
                rowNum:rowNum,
                editField:editField,
                editedRecord:editedRecord
            };
            var editorContextJ = @com.smartgwt.client.widgets.grid.ListGridEditorContext::new(Lcom/google/gwt/core/client/JavaScriptObject;)(editorContext);

            var customizerJ = this.editorCustomizer;
            var editorJ = customizer.@com.smartgwt.client.widgets.grid.ListGridEditorCustomizer::getEditor(Lcom/smartgwt/client/widgets/grid/ListGridEditorContext;)(editorContextJ);

            var editorJS = editorJ == null ? null : editorJ.@com.smartgwt.client.widgets.form.fields.FormItem::getEditorTypeConfig()();
            // Apply custom properties on top of standard item defaults.
            // This ensures field.type, field-level change handlers etc should be picked up even if
            // an otherwise custom item is provided.
            if (editorJS != editProperties) {
                $wnd.isc.addProperties(editProperties, editorJS);
            }
            return editProperties;
        }));

    }-*/;

    /**
     * @see #hideFields(String[], boolean)
     * @param fields fields to hide
     * @param suppressRelayout if passed, don't relayout non-explicit sized fields                                       to fit the available space
     */
    public native void hideFields(ListGridField[] fields, boolean suppressRelayout) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var fieldsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields);
        self.hideFields(fieldsJS, suppressRelayout);
    }-*/;

    /**
     * @see #showFields(String[],boolean)
     * @param field Fields to show.
     * @param suppressRelayout If passed, don't resize non-explicitly sized columns to fill the available space.
     * @see <a href="http://www.smartclient.com/smartgwt/showcase/#grid_appearance_columnorder" target="examples">Column order Example</a>
     */
    public native void showFields(ListGridField[] fields, boolean suppressRelayout) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var fieldsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(fields);
        self.showFields(fieldsJS, suppressRelayout);
    }-*/;

    /**
     * Returns the selected cells as a series of Records where each field value is stored under it's offset from the top-left
     * of the selection.  For example, a 2x2 cell selection starting from the first column would return two Records, each with
     * two values stored under the names "0" and "1".
     * <P>
     *If {@link com.smartgwt.client.widgets.grid.ListGrid#getCanSelectCells canSelectCells} is not enabled, this API always returns null.
     *
     * @return list of Records as described above
     */
    public native RecordList getSelectedCellData() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordListJS = self.getSelectedCellData();
        return recordListJS == null ? null : @com.smartgwt.client.data.RecordList::new(Lcom/google/gwt/core/client/JavaScriptObject;)(recordListJS);
    }-*/;

    /**
     * Properties to apply to the automatically generated {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditor
     * filterEditor} if {@link com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true.
     *
     * @param filterEditorProperties filterEditorProperties Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @deprecated in favor of {@link com.smartgwt.client.widgets.grid.ListGrid#setFilterEditorProperties(RecordEditor)}
     */
    public void setFilterEditorProperties(ListGrid filterEditorProperties)  throws IllegalStateException {
        if (filterEditorProperties != null) {
            if (filterEditorProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(this.getClass(), 
                               "setFilterEditorProperties", "ListGrid");
            }                                                                       
            filterEditorProperties.setConfigOnly(true);
        }
        JavaScriptObject config = filterEditorProperties == null ? null : filterEditorProperties.getConfig();
        setAttribute("filterEditorProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Method to find the next editable cell given a starting row/col, and a direction, either iterating through fields within each row, 
     * or checking the same field in each row.<p>Note, this is potentially an expensive method.  For example, consider a listGrid where 
     * the user can add rows but not edit any existing rows; in this case, <code>canEditCell()</code> would inspect and reject every row 
     * in the dataSet before returning true for the last row. Consider this before making use of this method on grids with large dataSets
     *
     * @param  rowNum             Index of starting row
     * @param  colNum             Index of starting column
     * @param  searchForward      true if searching forward for the next edit cell, false if searching backwards
     * @param  stepThroughFields  true if we should check every field in each row; false if we should check the same field in each row
     * @param  checkStartingCell  Should we check whether the starting cell is editable?  Pass false to skip the starting cell
     *
     * @return 2 element array containing <code>[rowNum,colNum]</code> for the next editable cell, or <code>null</code> if no editable 
     *         cell is found.
     */
    public int[] findNextEditCell(int rowNum, int colNum, boolean searchForward, boolean stepThroughFields, boolean checkStartingCell) {
        com.google.gwt.core.client.JsArrayInteger cellCoordJS = doFindNextEditCell(rowNum, colNum, searchForward, stepThroughFields, checkStartingCell);
        return cellCoordJS == null ? null : new int[]{cellCoordJS.get(0), cellCoordJS.get(1)};
    }
    
    private native com.google.gwt.core.client.JsArrayInteger doFindNextEditCell(int rowNum, int colNum, boolean searchForward, boolean stepThroughFields, boolean checkStartingCell) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var direction = searchForward ? 1 : -1;
        return self.findNextEditCell(rowNum, colNum, direction, stepThroughFields, checkStartingCell);
    }-*/;
    
    /**
     * Class level defaults to apply to the {@link com.smartgwt.client.widgets.MultiSortDialog} which gets automatically
     * generated when askForSort() is called. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInSortEditor showHeaderSpanTitlesInSortEditor} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSortEditorSpanTitleSeparator sortEditorSpanTitleSeparator}
     *
     * @param multiSortDialogDefaults  Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setMultiSortDialogDefaults(com.smartgwt.client.widgets.MultiSortDialog multiSortDialogDefaults)
        throws IllegalStateException 
    {
        if (multiSortDialogDefaults != null) {
            if (multiSortDialogDefaults.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, 
                      "setMultiSortDialogDefaults", "MultiSortDialog");
            }
            multiSortDialogDefaults.setConfigOnly(true);
        }
        JavaScriptObject config = multiSortDialogDefaults == null ? null : 
                                  multiSortDialogDefaults.getConfig();
        setAttribute("multiSortDialogDefaults", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Properties to apply to the {@link com.smartgwt.client.widgets.MultiSortDialog} which gets automatically generated when
     * askForSort() is called. <P> See also {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowHeaderSpanTitlesInSortEditor showHeaderSpanTitlesInSortEditor} and
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getSortEditorSpanTitleSeparator sortEditorSpanTitleSeparator}
     *
     * @param multiSortDialogProperties  Default value is null
     * @throws IllegalStateException this property cannot be changed after the component has been created
     * @see com.smartgwt.client.docs.SGWTProperties
     */
    public void setMultiSortDialogProperties(com.smartgwt.client.widgets.MultiSortDialog multiSortDialogProperties)
        throws IllegalStateException 
    {
        if (multiSortDialogProperties != null) {
            if (multiSortDialogProperties.isCreated()) {
                ConfigUtil.warnOfPreConfigInstantiation(ListGrid.class, 
                    "setMultiSortDialogProperties", "MultiSortDialog");
            }
            multiSortDialogProperties.setConfigOnly(true);
        }
        JavaScriptObject config = multiSortDialogProperties == null ? null : 
                                  multiSortDialogProperties.getConfig();
        setAttribute("multiSortDialogProperties", JSOHelper.cleanProperties(config, true), false);
    }

    /**
     * Retrieves a copy of the current criteria for this component (may be null). <P> Note: if {@link
     * com.smartgwt.client.widgets.grid.ListGrid#getShowFilterEditor showFilterEditor} is true, the criteria returned by this
     * method may not match the values currently displayed in the filter editor, since the user may have entered values which
     * have not yet been applied to our data. {@link com.smartgwt.client.widgets.grid.ListGrid#getFilterEditorCriteria
     * getFilterEditorCriteria()} may be used to retrieve the current criteria displayed in the filterEditor.
     *
     * @return current filter criteria
     * @see com.smartgwt.client.docs.DataBoundComponentMethods DataBoundComponentMethods overview and related methods
     */
    public native Criteria getCriteria() /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getCriteria", "");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var ret = self.getCriteria();
        if (ret == null) return null;
        if ($wnd.isc.DS.isAdvancedCriteria(ret)) {
            @com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(ret,"_constructor","AdvancedCriteria");
            return @com.smartgwt.client.data.AdvancedCriteria::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
        } else {
            return @com.smartgwt.client.data.Criteria::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
        }
    }-*/;

    /**
     * For a {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupByField grouped} grid,
     * returns all the direct children of the supplied node in the 
     * {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTree groupTree} if
     * <code>recordsOnly</code> false.  Otherwise, if <code>recordsOnly</code> is true, returns
     * instead a list of all descendants under the supplied node that are actual records from
     * the grid's original data - i.e. that are not other group nodes (for multi-grouping) or
     * summary records. <P> Note that null may be returned if the grid is not currently grouped
     * or the supplied node is not a valid {@link com.smartgwt.client.widgets.grid.GroupNode}.
     * @param node node from {@link com.smartgwt.client.widgets.grid.ListGrid#getGroupTree groupTree}
     * @param recordsOnly <code>true</code> to return all descendants that are actual records
     *                    from the grid's original data, or <code>false</code> to return all
     *                    immediate children of the supplied group node
     * @return records under the supplied node, as specified above, or null if we're not
     *         grouping or the node isn't a group node.
     */
    public native ListGridRecord[] getGroupMembers(GroupNode node, boolean recordsOnly) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "getGroupMembers", "GroupNode,boolean");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(),
            nodeJS = node.@com.smartgwt.client.widgets.grid.GroupNode::getJsObj()();

        var ret = self.getGroupMembers(nodeJS, recordsOnly);
        if (ret == null) return null;

        // apply GroupNode SGWT wrappers as appropriate
        for (var i = 0; i < ret.getLength(); i++) {
            var record = ret.get(i);
            if      (self.isGroupNode(record))     @com.smartgwt.client.widgets.grid.GroupNode::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            else if (self.isSummaryRecord(record)) @com.smartgwt.client.widgets.grid.GroupSummary::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
        }
        return @com.smartgwt.client.util.ConvertTo::arrayOfListGridRecord(Lcom/google/gwt/core/client/JavaScriptObject;)(ret);
    }-*/;

    /**
     * When {@link com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst sortByGroupFirst}
     * is active, sets the {@link com.smartgwt.client.widgets.grid.GroupNode GroupNode} value
     * normalizer used for implicit sorting by the field(s) used for grouping.
     * <P> 
     * No default implementation.
     *
     * @param GroupSortNormalizer customizer
     * @see com.smartgwt.client.widgets.grid.ListGrid#getSortByGroupFirst
     * @see com.smartgwt.client.widgets.grid.ListGrid#getGroupSortDirection
     */
    public native void setGroupSortNormalizer(GroupSortNormalizer customizer) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "setGroupSortNormalizer", "GroupSortNormalizer");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.groupSortNormalizer = $debox($entry(function(record, fieldName, context) {
            var nodeJ;
            if      (self.isGroupNode(record))     nodeJ = @com.smartgwt.client.widgets.grid.GroupNode::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            else if (self.isSummaryRecord(record)) nodeJ = @com.smartgwt.client.widgets.grid.GroupSummary::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            else                                   nodeJ = @com.smartgwt.client.widgets.grid.ListGridRecord::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(record);
            var returnValue = customizer.@com.smartgwt.client.widgets.grid.GroupSortNormalizer::normalize(Lcom/smartgwt/client/widgets/grid/ListGridRecord;Ljava/lang/String;Lcom/smartgwt/client/widgets/grid/ListGrid;)(
                    nodeJ, fieldName, 
                    @com.smartgwt.client.widgets.Canvas::getByJSObject(Lcom/google/gwt/core/client/JavaScriptObject;)(context));
            return $wnd.SmartGWT.convertToPrimitiveType(returnValue);
        }));
    }-*/;

	/**
     * Same as {@link #getFilterEditorCriteria() getFilterEditorCriteria()} but returns an
     * {@link com.smartgwt.client.data.AdvancedCriteria}.
     */
    public AdvancedCriteria getFilterEditorCriteriaAsAdvancedCriteria() {
        Criteria criteria = getFilterEditorCriteria();
        return criteria == null ? null : criteria.asAdvancedCriteria();
    }




    // ********************* DataBoundComponent Properties / Attributes ***********************

    public void setDataPageSize(int dataPageSize) {
        setAttribute("dataPageSize", dataPageSize, true);
    }

    public int getDataPageSize() {
        Integer dataPageSize = getAttributeAsInt("dataPageSize");
        return dataPageSize == null ? 0 : dataPageSize;
    }

    public void setUseAllDataSourceFields(Boolean useAllDataSourceFields) {
        setAttribute("useAllDataSourceFields", useAllDataSourceFields, true);
    }

    public Boolean getUseAllDataSourceFields() {
        return getAttributeAsBoolean("useAllDataSourceFields");
    }

    public void setShowHiddenFields(Boolean showHiddenFields) {
        setAttribute("showHiddenFields", showHiddenFields, true);
    }

    public Boolean getShowHiddenFields() {
        return getAttributeAsBoolean("showHiddenFields");
    }

    public void setShowComplexFields(Boolean showComplexFields) {
        setAttribute("showComplexFields", showComplexFields, true);
    }

    public Boolean getShowComplexFields() {
        return getAttributeAsBoolean("showComplexFields");
    }

    public void setFetchOperation(String fetchOperation) {
        setAttribute("fetchOperation", fetchOperation, true);
    }

    public String getFetchOperation() {
        return getAttributeAsString("fetchOperation");
    }

    public void setUpdateOperation(String updateOperation) {
        setAttribute("updateOperation", updateOperation, true);
    }

    public String getUpdateOperation() {
        return getAttributeAsString("updateOperation");
    }

    public void setAddOperation(String addOperation) {
        setAttribute("addOperation", addOperation, true);
    }

    public String getAddOperation() {
        return getAttributeAsString("addOperation");
    }

    public void setRemoveOperation(String removeOperation) {
        setAttribute("removeOperation", removeOperation, true);
    }

    public String getRemoveOperation() {
        return getAttributeAsString("removeOperation");
    }

    public void setExportFields(String[] exportFields) {
        setAttribute("exportFields", exportFields, true);
    }

    public String[] getExportFields() {
        return getAttributeAsStringArray("exportFields");
    }

    public void setExportAll(Boolean exportAll) {
        setAttribute("exportAll", exportAll, true);
    }

    public Boolean getExportAll() {
        return getAttributeAsBoolean("exportAll");
    }

    public void setExportIncludeSummaries(Boolean exportIncludeSummaries) {
        setAttribute("exportIncludeSummaries", exportIncludeSummaries, true);
    }

    public Boolean getExportIncludeSummaries() {
        return getAttributeAsBoolean("exportIncludeSummaries");
    }

    public void setPreventDuplicates(Boolean preventDuplicates) throws IllegalStateException {
        setAttribute("preventDuplicates", preventDuplicates, false);
    }

    public Boolean getPreventDuplicates() {
        return getAttributeAsBoolean("preventDuplicates");
    }

    public void setDuplicateDragMessage(String duplicateDragMessage) throws IllegalStateException {
        setAttribute("duplicateDragMessage", duplicateDragMessage, false);
    }

    public String getDuplicateDragMessage() {
        return getAttributeAsString("duplicateDragMessage");
    }

    public void setAddDropValues(Boolean addDropValues) {
        setAttribute("addDropValues", addDropValues, true);
    }

    public Boolean getAddDropValues() {
        return getAttributeAsBoolean("addDropValues");
    }

    public void setDropValues(Map dropValues) {
        setAttribute("dropValues", dropValues, true);
    }

    public Map getDropValues() {
        return getAttributeAsMap("dropValues");
    }

    /**
     * Indicates whether or not this component will load its data {@link DataSource#setProgressiveLoading() progressively}
     * 
     * @see com.smartgwt.client.docs.ProgressiveLoading  
     * @see com.smartgwt.client.data.DataSource#setProgressiveLoading
     * @param progressiveLoading
     */
    public void setProgressiveLoading(Boolean progressiveLoading) {
        setAttribute("progressiveLoading", progressiveLoading, false);
    }

    /**
     * Indicates whether or not this component will load its data {@link DataSource#getProgressiveLoading() progressively}
     * 
     * @see com.smartgwt.client.docs.ProgressiveLoading
     * @see com.smartgwt.client.data.DataSource#getProgressiveLoading
     * @return
     */
    public Boolean getProgressiveLoading() {
        return getAttributeAsBoolean("progressiveLoading");
    }

    public void setUseFlatFields(Boolean useFlatFields) throws IllegalStateException {
        setAttribute("useFlatFields", useFlatFields, false);
    }

    public Boolean getUseFlatFields() {
        return getAttributeAsBoolean("useFlatFields");
    }

    public void setHiliteProperty(String hiliteProperty) {
        setAttribute("hiliteProperty", hiliteProperty, true);
    }

    public String getHiliteProperty() {
        return getAttributeAsString("hiliteProperty");
    }

    /** 
     * Shows a FieldPicker interface allowing end-users to rearrange the order and visibiility
     * of the fields in the associated DataBoundComponent.
     */
    public native void editFields() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.editFields();
    }-*/;

    /**
     * Shows a HiliteEditor interface allowing end-users to edit the data-hilites currently in use by this DataBoundComponent.
     */
    public native void editHilites() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.editHilites();
    }-*/;

    /**
     * Get the current hilites encoded as a String, for saving.
     *
     * @return the hilite state
     */
    public native String getHiliteState()  /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        return self.getHiliteState();
    }-*/;

    /**
     * Set the current hilites based on a hiliteState String previously returned from getHilitesState.
     *
     * @param hiliteState hilites state encoded as a String
     */
    public native void setHiliteState(String hiliteState)  /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        return self.setHiliteState(hiliteState);
    }-*/;

    /**
     * Accepts an array of hilite objects and applies them to this DataBoundComponent. See also {@link #getHilites() getHilites} for a method of
     * retrieving the hilite array for storage, including hilites manually added by the user.
     *
     * @param hilites array of hilite objects
     */
    public native void setHilites(Hilite[] hilites)/*-{
        var isCreated = this.@com.smartgwt.client.widgets.BaseWidget::isCreated()();
        var hilitesJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(hilites);
        if (isCreated) {
            var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
            self.setHilites(hilitesJS);
        } else {
            var obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            obj.hilites = hilitesJS;
        }
    }-*/;

    /**
     * Return the set of hilite-objects currently applied to this DataBoundComponent. These can be saved for
     * storage and then restored to a component later via setHilites().
     *
     * @return array of hilite objects
     */
    public native Hilite[] getHilites()/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var hilitesJS = self.getHilites();
        return @com.smartgwt.client.util.ConvertTo::arrayOfHilite(Lcom/google/gwt/core/client/JavaScriptObject;)(hilitesJS);
    }-*/;

    public void setDragDataAction(DragDataAction dragDataAction) {
        setAttribute("dragDataAction", dragDataAction.getValue(), true);
    }

    public DragDataAction getDragDataAction() {
        return EnumUtil.getEnum(DragDataAction.values(), getAttribute("dragDataAction"));
    }

    public void setDragTrackerStyle(String dragTrackerStyle) {
        setAttribute("dragTrackerStyle", dragTrackerStyle, true);
    }

    public String getDragTrackerStyle() {
        return getAttributeAsString("dragTrackerStyle");
    }

    public void setCanAddFormulaFields(Boolean canAddFormulaFields) {
        setAttribute("canAddFormulaFields", canAddFormulaFields, true);
    }

    public native void addSummaryField() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.addSummaryField();
     }-*/;

    public native void addFormulaField() /*-{
       var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
       self.addFormulaField();
    }-*/;

    public Boolean getCanAddFormulaFields() {
        return getAttributeAsBoolean("canAddFormulaFields");
    }

    public void setAddFormulaFieldText(String addFormulaFieldText) {
        setAttribute("addFormulaFieldText", addFormulaFieldText, true);
    }

    public String getAddFormulaFieldText() {
        return getAttributeAsString("addFormulaFieldText");
    }

    public void setEditFormulaFieldText(String editFormulaFieldText) {
        setAttribute("editFormulaFieldText", editFormulaFieldText, true);
    }

    public String getEditFormulaFieldText() {
        return getAttributeAsString("editFormulaFieldText");
    }

    public void setCanAddSummaryFields(Boolean canAddSummaryFields) {
        setAttribute("canAddSummaryFields", canAddSummaryFields, true);
    }

    public Boolean getCanAddSummaryFields() {
        return getAttributeAsBoolean("canAddSummaryFields");
    }

    public void setAddSummaryFieldText(String addSummaryFieldText) {
        setAttribute("addSummaryFieldText", addSummaryFieldText, true);
    }

    public String getAddSummaryFieldText() {
        return getAttributeAsString("addSummaryFieldText");
    }

    public void setEditSummaryFieldText(String editSummaryFieldText) {
        setAttribute("editSummaryFieldText", editSummaryFieldText, true);
    }

    public String getEditSummaryFieldText() {
        return getAttributeAsString("editSummaryFieldText");
    }

    // ********************* Methods ***********************
    /**
     * Filters all objects according to the AdvancedCriteria passed
     *
     * @param adCriteria AdvancedCriteria to use to filter results
     *
     * @return all matching Objects or null if none found
     */
    public native Record[] findAll(AdvancedCriteria adCriteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = self.findAll(adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(adCriteria)){
    		var criteriaJ = adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        return recordsJS == null ? null : @com.smartgwt.client.data.Record::convertToRecordArray(Lcom/google/gwt/core/client/JavaScriptObject;)(recordsJS);
    }-*/;
    
    /**
     * Filters all objects according to the AdvancedCriteria passed and returns the first matching object or null if not found
     *
     * @param adCriteria AdvancedCriteria to use to filter results
     *
     * @return first matching object or null if not found
     */
    public native Record find(AdvancedCriteria adCriteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = self.find(adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()());
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(adCriteria)){
    		var criteriaJ = adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        return recordJS == null ? null : @com.smartgwt.client.data.Record::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(recordJS);
    }-*/;
    
    /**
     * Finds the index of the first Record that matches with the AdvacendCriteria passed.
     * @param adCriteria AdvancedCriteria to use to filter results
     *
     * @return index of the first matching Record or -1 if not found
     */
    public native int findIndex(AdvancedCriteria adCriteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(adCriteria)){
    		var criteriaJ = adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        return self.findIndex(adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;
    
    /**
     * Like {@link RecordList#findIndex}, but considering the startIndex and endIndex parameters.
     * @param startIndex first index to consider
     * @param adCriteria AdvancedCriteria to use to filter results
     * @param endIndex last index to consider
     * 
     * @return index of the first matching Record or -1 if not found
     */
    public native int findNextIndex(int startIndex, AdvancedCriteria adCriteria, int endIndex) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(adCriteria)){
    		var criteriaJ = adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        return self.findNextIndex(startIndex, adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()(), null, endIndex);
    }-*/;
    
    /**
     * Like {@link RecordList#findIndex}, but considering the startIndex parameter.
     * @param startIndex first index to consider
     * @param adCriteria AdvancedCriteria to use to filter results
     * 
     * @return index of the first matching Record or -1 if not found
     */
    public native int findNextIndex(int startIndex, AdvancedCriteria adCriteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(adCriteria)){
    		var criteriaJ = adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        return self.findNextIndex(startIndex, adCriteria.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;

    public native void selectRecord(Record record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        self.selectRecord(recordJS);
     }-*/;

    public native void selectRecord(int record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectRecord(record);
     }-*/;

    public native void selectRecord(int record, boolean newState)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.selectRecord(record, newState);
     }-*/;

    public native void selectRecord(Record record, boolean newState)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        self.selectRecord(recordJS, newState);
     }-*/;

    public native void selectRecords(int[] records)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(records);
        self.selectRecord(recordsJS);
     }-*/;

    public native void selectRecords(int[] records, boolean newState)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(records);
        self.selectRecords(recordsJS, newState);
     }-*/;

    public native void selectRecords(Record[] records)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records);
        self.selectRecords(recordsJS);
     }-*/;

    public native void selectRecords(Record[] records, boolean newState)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records);
        self.selectRecords(recordsJS, newState);
     }-*/;

    public native void deselectRecord(Record record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordJS = record.@com.smartgwt.client.data.Record::getJsObj()();
        self.deselectRecord(recordJS);
     }-*/;

    public native void deselectRecord(int record)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.deselectRecord(record);
     }-*/;

    public native void deselectRecords(int[] records)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([I)(records);
        self.deselectRecords(recordsJS);
     }-*/;

    public native void deselectRecords(Record[] records)/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records);
        self.deselectRecords(recordsJS);
     }-*/;

    public native void selectAllRecords() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.selectAllRecords();
     }-*/;

    public native void deselectAllRecords() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.deselectAllRecords();
     }-*/;

    public native Boolean anySelected() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         var retVal =self.anySelected();
         if(retVal == null) {
             return null;
         } else {
             return @com.smartgwt.client.util.JSOHelper::toBoolean(Z)(retVal);
         }
     }-*/;

    public native void enableHilite(String hiliteID) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.enableHilite(hiliteID);
     }-*/;

    public native void enableHilite(String hiliteID, boolean enable) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.enableHilite(hiliteID, enable);
     }-*/;

    public native void disableHilite(String hiliteID) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.disableHilite(hiliteID);
     }-*/;

    public native void enableHiliting() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.enableHiliting();
     }-*/;

    public native void enableHiliting(boolean enable) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.enableHiliting(enable);
     }-*/;

    public native void disableHiliting() /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         self.disableHiliting();
     }-*/;

    public native Record[] getDragData() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = self.getDragData();
        return @com.smartgwt.client.data.Record::convertToRecordArray(Lcom/google/gwt/core/client/JavaScriptObject;)(recordsJS);
     }-*/;

    public native void transferSelectedData(DataBoundComponent source) /*-{
         var self = this.@com.smartgwt.client.widgets.DataBoundComponent::getOrCreateJsObj()();
         self.transferSelectedData(source.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()());
     }-*/;

    public native void transferSelectedData(DataBoundComponent source, int index) /*-{
         var self = this.@com.smartgwt.client.widgets.DataBoundComponent::getOrCreateJsObj()();
         self.transferSelectedData(source.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()(), index);
     }-*/;

    public native int getRecordIndex(Record record) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         return self.getRecordIndex(record.@com.smartgwt.client.core.DataClass::getJsObj()());
     }-*/;

    public native String getTitleFieldValue(Record record) /*-{
         var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
         return self.getTitleFieldValue(record);
     }-*/;

    public void setTitleField(String titleField) {
        setAttribute("titleField", titleField, true);
    }

    public String getTitleField() {
        return getAttributeAsString("titleField");
    }

    public native DataSource getDataSource() /*-{
        var dataSourceJS = this.@com.smartgwt.client.widgets.grid.ListGrid::getAttributeAsJavaScriptObject(Ljava/lang/String;)("dataSource");
        if ($wnd.isc.isA.String(dataSourceJS)) dataSourceJS = $wnd.isc.DataSource.get(dataSourceJS);
        return @com.smartgwt.client.data.DataSource::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(dataSourceJS);
    }-*/;

    public void setAutoFetchData(Boolean autoFetchData) throws IllegalStateException {
        setAttribute("autoFetchData", autoFetchData, false);
    }

    public Boolean getAutoFetchData() {
        return getAttributeAsBoolean("autoFetchData");
    }

    public void setAutoFetchTextMatchStyle(TextMatchStyle autoFetchTextMatchStyle) throws IllegalStateException {
        setAttribute("autoFetchTextMatchStyle", autoFetchTextMatchStyle.getValue(), false);
    }

    public TextMatchStyle getAutoFetchTextMatchStyle() {
        return TextMatchStyle.valueOf(getAttributeAsString("autoFetchTextMatchStyle"));
    }

    public void setAutoFetchAsFilter(Boolean autoFetchAsFilter) throws IllegalStateException {
        setAttribute("autoFetchAsFilter", autoFetchAsFilter, false);
    }

    public Boolean getAutoFetchAsFilter() {
        return getAttributeAsBoolean("autoFetchAsFilter");
    }

    public void setInitialCriteria(Criteria initialCriteria) throws IllegalStateException {
        setAttribute("initialCriteria", initialCriteria.getJsObj(), false);
    }

    public Criteria getInitialCriteria() {
        return new Criteria(getAttributeAsJavaScriptObject("initialCriteria"));
    }

    public void setImplicitCriteria(Criteria implicitCriteria) {
        if (implicitCriteria instanceof Criterion) {
            implicitCriteria.setAttribute("_constructor", "AdvancedCriteria");
        }
        setAttribute("implicitCriteria", implicitCriteria == null ? 
                     null : implicitCriteria.getJsObj(), true);
    }

    public Criteria getImplicitCriteria()  {
        return new Criteria(getAttributeAsJavaScriptObject("implicitCriteria"));
    }
    
    public native void fetchData() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.fetchData();
    }-*/;

    public native void fetchData(Criteria criteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
    		var criteriaJ = criteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        self.fetchData(criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()());
    }-*/;

    public native void fetchData(Criteria criteria, DSCallback callback) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var critJS = criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
    		var criteriaJ = criteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        self.fetchData(critJS, $entry(function (dsResponse, data, dsRequest) {
            var responseJ = @com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse);
            var requestJ = @com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest);
            if(callback != null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(responseJ, data, requestJ);
        }));
    }-*/;

    public native void fetchData(Criteria criteria, DSCallback callback, DSRequest requestProperties) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var critJS = criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()();
        var requestPropertiesJS = requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()();
    	if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
    		var criteriaJ = criteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        self.fetchData(critJS, $entry(function (dsResponse, data, dsRequest) {
            var responseJ = @com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse);
            var requestJ = @com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest);
            if(callback != null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(responseJ, data, requestJ);
        }), requestPropertiesJS);
    }-*/;

    public native void filterData() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.filterData();
    }-*/;

    public native void filterData(Criteria criteria) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.filterData(criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()());
    }-*/;

    public native void filterData(Criteria criteria, DSCallback callback) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var critJS = criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
    		var criteriaJ = criteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        self.filterData(critJS, $entry(function (dsResponse, data, dsRequest) {
            var responseJ = @com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse);
            var requestJ = @com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest);
            if(callback != null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(responseJ, data, requestJ);
        }));
    }-*/;

    public native void filterData(Criteria criteria, DSCallback callback, DSRequest requestProperties) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var critJS = criteria == null ? null : criteria.@com.smartgwt.client.data.Criteria::getJsObj()();
        var requestPropertiesJS = requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()();
        if(@com.smartgwt.client.data.Criterion::instanceOf(Ljava/lang/Object;)(criteria)){
    		var criteriaJ = criteria.@com.smartgwt.client.core.DataClass::getJsObj()();
	    	@com.smartgwt.client.util.JSOHelper::setAttribute(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;Ljava/lang/String;)(criteriaJ,"_constructor","AdvancedCriteria");
	    }
        self.filterData(critJS, $entry(function (dsResponse, data, dsRequest) {
            var responseJ = @com.smartgwt.client.data.DSResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsResponse);
            var requestJ = @com.smartgwt.client.data.DSRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dsRequest);
            if(callback != null) callback.@com.smartgwt.client.data.DSCallback::execute(Lcom/smartgwt/client/data/DSResponse;Ljava/lang/Object;Lcom/smartgwt/client/data/DSRequest;)(responseJ, data, requestJ);
        }), requestPropertiesJS);
    }-*/;

    public native void invalidateCache() /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.invalidateCache();
    }-*/;

    public ResultSet getResultSet() {
        JavaScriptObject dataJS = getAttributeAsJavaScriptObject("data");
        if(dataJS == null) return null;
        if(!ResultSet.isResultSet(dataJS)) {
            SC.logWarn("getResultSet(): data is not a ResultSet; returning null " +
                "(if grouped, use getOriginalResultSet(); if unbound, use getRecordList(); " +
                "can only be called on DataBoundComponents after initial data has been fetched)");
            return null;
        }
        return ResultSet.getOrCreateRef(dataJS);
    }

    public native RecordList getRecordList() /*-{
        var dataJS = this.@com.smartgwt.client.widgets.DataBoundComponent::getDataAsJSList()();
        if (dataJS == null) return null;
        if ($wnd.isc.isA.ResultSet(dataJS)) {
            return this.@com.smartgwt.client.widgets.DataBoundComponent::getResultSet()();
        } else if ($wnd.isc.isA.ResultTree(dataJS)) {
            return @com.smartgwt.client.widgets.tree.ResultTree::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(dataJS);
        } else if ($wnd.isc.isA.Tree(dataJS)) {
            return @com.smartgwt.client.widgets.tree.Tree::getOrCreateRef(Lcom/google/gwt/core/client/JavaScriptObject;)(dataJS);
        }
        return @com.smartgwt.client.data.RecordList::new(Lcom/google/gwt/core/client/JavaScriptObject;)(dataJS);
    }-*/;

    public native JavaScriptObject getDataAsJSList() /*-{
    	var self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
    	if (self == null) return null;
    	return self.getDataAsList();
    	
    }-*/;

    public void exportData() {
        exportData(null);
    }

    public native void exportData(DSRequest requestProperties) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "exportData", "DSRequest,RPCCallback");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.exportData(requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()());
    }-*/;


    public native void exportData(DSRequest requestProperties, RPCCallback callback) /*-{
        if (this.@com.smartgwt.client.widgets.BaseWidget::isConfigOnly()()) {
            @com.smartgwt.client.util.ConfigUtil::warnOfPostConfigInstantiation(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/String;)(this.@java.lang.Object::getClass()(), "exportData", "DSRequest,RPCCallback");
        }
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.exportData(requestProperties == null ? null : requestProperties.@com.smartgwt.client.core.DataClass::getJsObj()(),
			$entry( function(response, rawData, request) {
				if(callback!=null) callback.@com.smartgwt.client.rpc.RPCCallback::execute(Lcom/smartgwt/client/rpc/RPCResponse;Ljava/lang/Object;Lcom/smartgwt/client/rpc/RPCRequest;)(
					@com.smartgwt.client.rpc.RPCResponse::new(Lcom/google/gwt/core/client/JavaScriptObject;)(response), 
					rawData, 
					@com.smartgwt.client.rpc.RPCRequest::new(Lcom/google/gwt/core/client/JavaScriptObject;)(request)
				);
			}));
    }-*/;

    /**
     * Add a fetchData handler.
     * <p>
     * Notification function fired on fetchData() or filterData()
     *
     * @param handler the filterData handler
     * @return {@link com.google.gwt.event.shared.HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addFetchDataHandler(FetchDataHandler handler) {
        if(getHandlerCount(FetchDataEvent.getType()) == 0) setupFetchDataEvent();
        return doAddHandler(handler, FetchDataEvent.getType());
    }

    private native void setupFetchDataEvent() /*-{
        var obj = null;
        var selfJ = this;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            obj.addProperties({onFetchData:$debox($entry(function(){
                    var param = {"_this": this, "criteria" : arguments[0], "requestProperties" : arguments[1]};
                    var event = @com.smartgwt.client.widgets.events.FetchDataEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                    selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
                }))
            });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            obj.onFetchData = $debox($entry(function(){
                var param = {"_this": this, "criteria" : arguments[0], "requestProperties" : arguments[1]};
                var event = @com.smartgwt.client.widgets.events.FetchDataEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            }));
        }
    }-*/;

    /**
     * Add a {@link com.smartgwt.client.widgets.DropCompleteHandler}.  See that class's documentation for a definition of "drop complete",
     * and how it differs from "drag complete" ({@link com.smartgwt.client.widgets.DragCompleteHandler}).
     *
     * @param handler the DropCompleteHandler
     * @return {@link com.google.gwt.event.shared.HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addDropCompleteHandler(DropCompleteHandler handler) {
        if(getHandlerCount(DropCompleteEvent.getType()) == 0) setupDropCompleteEvent();
        return doAddHandler(handler, DropCompleteEvent.getType());
    }

    private native void setupDropCompleteEvent() /*-{
        var obj = null;
        var selfJ = this;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            obj.addProperties({dropComplete:$debox($entry(function(){
                    var param = {"_this": this, "transferredRecords" : arguments[0]};
                    var event = @com.smartgwt.client.widgets.events.DropCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                    selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
                }))
            });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            obj.dropComplete = $debox($entry(function(){
                var param = {"_this": this, "transferredRecords" : arguments[0]};
                var event = @com.smartgwt.client.widgets.events.DropCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            }));
        }
    }-*/;

    /**
     * Add a {@link com.smartgwt.client.widgets.DragCompleteHandler}.  See that class's documentation for a definition of "drag complete",
     * and how it differs from "drop complete" ({@link com.smartgwt.client.widgets.DropCompleteHandler}).
     *
     * @param handler the DropCompleteHandler
     * @return {@link com.google.gwt.event.shared.HandlerRegistration} used to remove this handler
     */
    public HandlerRegistration addDragCompleteHandler(DragCompleteHandler handler) {
        if(getHandlerCount(DragCompleteEvent.getType()) == 0) setupDragCompleteEvent();
        return doAddHandler(handler, DragCompleteEvent.getType());
    }

    private native void setupDragCompleteEvent() /*-{
        var obj = null;
        var selfJ = this;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
            obj.addProperties({dragComplete:$debox($entry(function(){
                    var param = {"_this": this};
                    var event = @com.smartgwt.client.widgets.events.DragCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                    selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
                }))
            });
        } else {
            obj = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
            obj.dragComplete = $debox($entry(function(){
                var param = {"_this": this, "transferredRecords" : arguments[0]};
                var event = @com.smartgwt.client.widgets.events.DragCompleteEvent::new(Lcom/google/gwt/core/client/JavaScriptObject;)(param);
                selfJ.@com.smartgwt.client.widgets.BaseWidget::fireEvent(Lcom/google/gwt/event/shared/GwtEvent;)(event);
            }));
        }
    }-*/;

    public native Alignment[] getFieldAlignments()/*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var alignJS = self.getFieldAlignments();
        return @com.smartgwt.client.util.ConvertTo::arrayOfAlignment(Lcom/google/gwt/core/client/JavaScriptObject;)(alignJS);
    }-*/;

    public Boolean getDeepCloneOnEdit() {
        return getAttributeAsBoolean("deepCloneOnEdit");
    }

    public void setDeepCloneOnEdit(Boolean deepCloneOnEdit) {
        setAttribute("deepCloneOnEdit", deepCloneOnEdit, true);
    }

    public void setFields(JavaScriptObject... fields) {
        if (fields != null) for(int i = 0; i < fields.length; i++) {
            fields[i] = duplicateFieldConfig(JSOHelper.cleanProperties(fields[i], false));
        }
        setAttribute("fields", fields, true);
    }

    private native JavaScriptObject duplicateFieldConfig(JavaScriptObject config) /*-{
        return $wnd.isc.shallowClone(config);
    }-*/;

    public JavaScriptObject[] getFieldsAsJavaScriptObjects() {
        JavaScriptObject fieldsJsArray = getAttributeAsJavaScriptObject("fields");
        return JSOHelper.isArray(fieldsJsArray) ? JSOHelper.toArray(fieldsJsArray) : null;
    }

    public int getFieldCount() {
        JavaScriptObject[] fields = getFieldsAsJavaScriptObjects();
        return fields != null ? fields.length : 0;
    }
    
    public native void transferRecords(Record[] records, Record targetRecord, Integer index, Canvas sourceWidget, TransferRecordsCallback callback) /*-{
        var self = this.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        var recordsJS = @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(records);
        var targetRecordJS = targetRecord == null ? null : targetRecord.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        var indexJS = index == null ? null : index.@java.lang.Integer::intValue()();
        var sourceWidgetJS = sourceWidget == null ? null : sourceWidget.@com.smartgwt.client.widgets.BaseWidget::getOrCreateJsObj()();
        self.transferRecords(recordsJS, targetRecordJS, indexJS, sourceWidgetJS, $entry(function(records) {
            if(callback != null) {
	    		var convertedArray = [];
	    		for (var i = 0; i < records.length; i++) {
	    			convertedArray[i] =  @com.smartgwt.client.data.Record::new(Lcom/google/gwt/core/client/JavaScriptObject;)(records[i]);
	    		}
                var recordsJ = @com.smartgwt.client.util.JSOHelper::convertToJavaObjectArray(Lcom/google/gwt/core/client/JavaScriptObject;)(convertedArray);
                callback.@com.smartgwt.client.widgets.TransferRecordsCallback::execute([Lcom/smartgwt/client/data/Record;)(recordsJ);
            }
        }));
    }-*/;

	/**
     * During a drag-and-drop interaction, this method returns the set of records being dragged
     * out of the component.  In the default implementation, this is the list of currently
     * selected records.<p>
     * This method is consulted by
     * {@link com.smartgwt.client.widgets.grid.ListGrid#willAcceptDrop willAcceptDrop()}.
     * @param DragDataCustomizer customizer
     */
    public native void setDragDataCustomizer(DragDataCustomizer customizer) /*-{
        var self;
        if(this.@com.smartgwt.client.widgets.BaseWidget::isCreated()()) {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getJsObj()();
        } else {
            self = this.@com.smartgwt.client.widgets.BaseWidget::getConfig()();
        }
        var componentJ = this;
        self.getDragData = $debox($entry(function() {
        	var returnJ = customizer.@com.smartgwt.client.widgets.DragDataCustomizer::getDragData(Lcom/smartgwt/client/widgets/DataBoundComponent;)(componentJ);
        	return @com.smartgwt.client.util.JSOHelper::convertToJavaScriptArray([Ljava/lang/Object;)(returnJ);
    	}));
    }-*/;


    /**
     * Setter implementing the {@link com.smartgwt.client.core.LogicalStructure} interface,
     * which supports Eclipse's logical structure debugging facility.
     */
    public LogicalStructureObject setLogicalStructure(ListGridLogicalStructure s) {
        super.setLogicalStructure(s);
        try {
            s.advancedFieldPickerThreshold = getAttributeAsString("advancedFieldPickerThreshold");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.advancedFieldPickerThreshold:" + t.getMessage() + "\n";
        }
        try {
            s.allowFilterExpressions = getAttributeAsString("allowFilterExpressions");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.allowFilterExpressions:" + t.getMessage() + "\n";
        }
        try {
            s.allowFilterOperators = getAttributeAsString("allowFilterOperators");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.allowFilterOperators:" + t.getMessage() + "\n";
        }
        try {
            s.allowRowSpanning = getAttributeAsString("allowRowSpanning");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.allowRowSpanning:" + t.getMessage() + "\n";
        }
        try {
            s.alternateBodyStyleName = getAttributeAsString("alternateBodyStyleName");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateBodyStyleName:" + t.getMessage() + "\n";
        }
        try {
            s.alternateFieldFrequency = getAttributeAsString("alternateFieldFrequency");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateFieldFrequency:" + t.getMessage() + "\n";
        }
        try {
            s.alternateFieldStyles = getAttributeAsString("alternateFieldStyles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateFieldStyles:" + t.getMessage() + "\n";
        }
        try {
            s.alternateFieldSuffix = getAttributeAsString("alternateFieldSuffix");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateFieldSuffix:" + t.getMessage() + "\n";
        }
        try {
            s.alternateRecordFrequency = getAttributeAsString("alternateRecordFrequency");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateRecordFrequency:" + t.getMessage() + "\n";
        }
        try {
            s.alternateRecordStyles = getAttributeAsString("alternateRecordStyles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateRecordStyles:" + t.getMessage() + "\n";
        }
        try {
            s.alternateRecordSuffix = getAttributeAsString("alternateRecordSuffix");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alternateRecordSuffix:" + t.getMessage() + "\n";
        }
        try {
            s.alwaysShowEditors = getAttributeAsString("alwaysShowEditors");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alwaysShowEditors:" + t.getMessage() + "\n";
        }
        try {
            s.alwaysShowOperatorIcon = getAttributeAsString("alwaysShowOperatorIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.alwaysShowOperatorIcon:" + t.getMessage() + "\n";
        }
        try {
            s.animateFolderEffect = getAttributeAsString("animateFolderEffect");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateFolderEffect:" + t.getMessage() + "\n";
        }
        try {
            s.animateFolderMaxRows = getAttributeAsString("animateFolderMaxRows");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateFolderMaxRows:" + t.getMessage() + "\n";
        }
        try {
            s.animateFolders = getAttributeAsString("animateFolders");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateFolders:" + t.getMessage() + "\n";
        }
        try {
            s.animateFolderSpeed = getAttributeAsString("animateFolderSpeed");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateFolderSpeed:" + t.getMessage() + "\n";
        }
        try {
            s.animateFolderTime = getAttributeAsString("animateFolderTime");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateFolderTime:" + t.getMessage() + "\n";
        }
        try {
            s.animateRemoveRecord = getAttributeAsString("animateRemoveRecord");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateRemoveRecord:" + t.getMessage() + "\n";
        }
        try {
            s.animateRemoveSpeed = getAttributeAsString("animateRemoveSpeed");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateRemoveSpeed:" + t.getMessage() + "\n";
        }
        try {
            s.animateRemoveTime = getAttributeAsString("animateRemoveTime");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateRemoveTime:" + t.getMessage() + "\n";
        }
        try {
            s.animateRollOver = getAttributeAsString("animateRollOver");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateRollOver:" + t.getMessage() + "\n";
        }
        try {
            s.animateRollUnder = getAttributeAsString("animateRollUnder");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateRollUnder:" + t.getMessage() + "\n";
        }
        try {
            s.animateSelection = getAttributeAsString("animateSelection");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateSelection:" + t.getMessage() + "\n";
        }
        try {
            s.animateSelectionUnder = getAttributeAsString("animateSelectionUnder");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.animateSelectionUnder:" + t.getMessage() + "\n";
        }
        try {
            s.applyFormulaAfterSummary = getAttributeAsString("applyFormulaAfterSummary");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.applyFormulaAfterSummary:" + t.getMessage() + "\n";
        }
        try {
            s.applyRowNumberStyle = getAttributeAsString("applyRowNumberStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.applyRowNumberStyle:" + t.getMessage() + "\n";
        }
        try {
            s.arrowKeyAction = getAttributeAsString("arrowKeyAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.arrowKeyAction:" + t.getMessage() + "\n";
        }
        try {
            s.arrowKeyEditAction = getAttributeAsString("arrowKeyEditAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.arrowKeyEditAction:" + t.getMessage() + "\n";
        }
        try {
            s.asynchGroupingPrompt = getAttributeAsString("asynchGroupingPrompt");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.asynchGroupingPrompt:" + t.getMessage() + "\n";
        }
        try {
            s.autoComplete = getAttributeAsString("autoComplete");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoComplete:" + t.getMessage() + "\n";
        }
        try {
            s.autoConfirmSaveEdits = getAttributeAsString("autoConfirmSaveEdits");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoConfirmSaveEdits:" + t.getMessage() + "\n";
        }
        try {
            s.autoFetchDisplayMap = getAttributeAsString("autoFetchDisplayMap");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFetchDisplayMap:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitAllText = getAttributeAsString("autoFitAllText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitAllText:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitClipFields = getAttributeAsStringArray("autoFitClipFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitClipFieldsArray:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitData = getAttributeAsString("autoFitData");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitData:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitDateFields = getAttributeAsString("autoFitDateFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitDateFields:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitExpandField = getAttributeAsString("autoFitExpandField");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitExpandField:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitExtraRecords = getAttributeAsString("autoFitExtraRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitExtraRecords:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitFieldsFillViewport = getAttributeAsString("autoFitFieldsFillViewport");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitFieldsFillViewport:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitFieldText = getAttributeAsString("autoFitFieldText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitFieldText:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitFieldWidths = getAttributeAsString("autoFitFieldWidths");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitFieldWidths:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitHeaderHeights = getAttributeAsString("autoFitHeaderHeights");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitHeaderHeights:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitIconFields = getAttributeAsString("autoFitIconFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitIconFields:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitMaxColumns = getAttributeAsString("autoFitMaxColumns");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitMaxColumns:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitMaxHeight = getAttributeAsString("autoFitMaxHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitMaxHeight:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitMaxRecords = getAttributeAsString("autoFitMaxRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitMaxRecords:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitMaxWidthAsString = getAttributeAsString("autoFitMaxWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitMaxWidthAsString:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitTimeFields = getAttributeAsString("autoFitTimeFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitTimeFields:" + t.getMessage() + "\n";
        }
        try {
            s.autoFitWidthApproach = getAttributeAsString("autoFitWidthApproach");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoFitWidthApproach:" + t.getMessage() + "\n";
        }
        try {
            s.autoSaveEdits = getAttributeAsString("autoSaveEdits");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoSaveEdits:" + t.getMessage() + "\n";
        }
        try {
            s.autoSizeHeaderSpans = getAttributeAsString("autoSizeHeaderSpans");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.autoSizeHeaderSpans:" + t.getMessage() + "\n";
        }
        try {
            s.badFormulaResultValue = getAttributeAsString("badFormulaResultValue");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.badFormulaResultValue:" + t.getMessage() + "\n";
        }
        try {
            s.baseStyle = getAttributeAsString("baseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.baseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.bodyBackgroundColor = getAttributeAsString("bodyBackgroundColor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.bodyBackgroundColor:" + t.getMessage() + "\n";
        }
        try {
            s.bodyOverflow = getAttributeAsString("bodyOverflow");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.bodyOverflow:" + t.getMessage() + "\n";
        }
        try {
            s.bodyStyleName = getAttributeAsString("bodyStyleName");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.bodyStyleName:" + t.getMessage() + "\n";
        }
        try {
            s.booleanBaseStyle = getAttributeAsString("booleanBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.booleanFalseImage = getAttributeAsString("booleanFalseImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanFalseImage:" + t.getMessage() + "\n";
        }
        try {
            s.booleanImageHeight = getAttributeAsString("booleanImageHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanImageHeight:" + t.getMessage() + "\n";
        }
        try {
            s.booleanImageWidth = getAttributeAsString("booleanImageWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanImageWidth:" + t.getMessage() + "\n";
        }
        try {
            s.booleanPartialImage = getAttributeAsString("booleanPartialImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanPartialImage:" + t.getMessage() + "\n";
        }
        try {
            s.booleanTrueImage = getAttributeAsString("booleanTrueImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.booleanTrueImage:" + t.getMessage() + "\n";
        }
        try {
            s.canAcceptDroppedRecords = getAttributeAsString("canAcceptDroppedRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canAcceptDroppedRecords:" + t.getMessage() + "\n";
        }
        try {
            s.canAutoFitFields = getAttributeAsString("canAutoFitFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canAutoFitFields:" + t.getMessage() + "\n";
        }
        try {
            s.cancelEditingConfirmationMessage = getAttributeAsString("cancelEditingConfirmationMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.cancelEditingConfirmationMessage:" + t.getMessage() + "\n";
        }
        try {
            s.canCollapseGroup = getAttributeAsString("canCollapseGroup");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canCollapseGroup:" + t.getMessage() + "\n";
        }
        try {
            s.canDragRecordsOut = getAttributeAsString("canDragRecordsOut");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canDragRecordsOut:" + t.getMessage() + "\n";
        }
        try {
            s.canDragSelect = getAttributeAsString("canDragSelect");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canDragSelect:" + t.getMessage() + "\n";
        }
        try {
            s.canDragSelectText = getAttributeAsString("canDragSelectText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canDragSelectText:" + t.getMessage() + "\n";
        }
        try {
            s.canDropInEmptyArea = getAttributeAsString("canDropInEmptyArea");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canDropInEmptyArea:" + t.getMessage() + "\n";
        }
        try {
            s.canEdit = getAttributeAsString("canEdit");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canEdit:" + t.getMessage() + "\n";
        }
        try {
            s.canEditFieldAttribute = getAttributeAsString("canEditFieldAttribute");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canEditFieldAttribute:" + t.getMessage() + "\n";
        }
        try {
            s.canEditHilites = getAttributeAsString("canEditHilites");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canEditHilites:" + t.getMessage() + "\n";
        }
        try {
            s.canEditTitles = getAttributeAsString("canEditTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canEditTitles:" + t.getMessage() + "\n";
        }
        try {
            s.canExpandMultipleRecords = getAttributeAsString("canExpandMultipleRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canExpandMultipleRecords:" + t.getMessage() + "\n";
        }
        try {
            s.canExpandRecordProperty = getAttributeAsString("canExpandRecordProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canExpandRecordProperty:" + t.getMessage() + "\n";
        }
        try {
            s.canExpandRecords = getAttributeAsString("canExpandRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canExpandRecords:" + t.getMessage() + "\n";
        }
        try {
            s.canFocusInEmptyGrid = getAttributeAsString("canFocusInEmptyGrid");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canFocusInEmptyGrid:" + t.getMessage() + "\n";
        }
        try {
            s.canFreezeFields = getAttributeAsString("canFreezeFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canFreezeFields:" + t.getMessage() + "\n";
        }
        try {
            s.canGroupBy = getAttributeAsString("canGroupBy");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canGroupBy:" + t.getMessage() + "\n";
        }
        try {
            s.canHover = getAttributeAsString("canHover");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canHover:" + t.getMessage() + "\n";
        }
        try {
            s.canMultiGroup = getAttributeAsString("canMultiGroup");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canMultiGroup:" + t.getMessage() + "\n";
        }
        try {
            s.canMultiSort = getAttributeAsString("canMultiSort");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canMultiSort:" + t.getMessage() + "\n";
        }
        try {
            s.canPickFields = getAttributeAsString("canPickFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canPickFields:" + t.getMessage() + "\n";
        }
        try {
            s.canPickOmittedFields = getAttributeAsString("canPickOmittedFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canPickOmittedFields:" + t.getMessage() + "\n";
        }
        try {
            s.canRemoveRecords = getAttributeAsString("canRemoveRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canRemoveRecords:" + t.getMessage() + "\n";
        }
        try {
            s.canReorderFields = getAttributeAsString("canReorderFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canReorderFields:" + t.getMessage() + "\n";
        }
        try {
            s.canReorderRecords = getAttributeAsString("canReorderRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canReorderRecords:" + t.getMessage() + "\n";
        }
        try {
            s.canResizeFields = getAttributeAsString("canResizeFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canResizeFields:" + t.getMessage() + "\n";
        }
        try {
            s.canSelectAll = getAttributeAsString("canSelectAll");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canSelectAll:" + t.getMessage() + "\n";
        }
        try {
            s.canSelectCells = getAttributeAsString("canSelectCells");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canSelectCells:" + t.getMessage() + "\n";
        }
        try {
            s.canSelectGroups = getAttributeAsString("canSelectGroups");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canSelectGroups:" + t.getMessage() + "\n";
        }
        try {
            s.canSort = getAttributeAsString("canSort");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canSort:" + t.getMessage() + "\n";
        }
        try {
            s.canTabToHeader = getAttributeAsString("canTabToHeader");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.canTabToHeader:" + t.getMessage() + "\n";
        }
        try {
            s.cellHeight = getAttributeAsString("cellHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.cellHeight:" + t.getMessage() + "\n";
        }
        try {
            s.cellPadding = getAttributeAsString("cellPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.cellPadding:" + t.getMessage() + "\n";
        }
        try {
            s.chartConstructor = getAttributeAsString("chartConstructor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.chartConstructor:" + t.getMessage() + "\n";
        }
        try {
            s.chartType = getAttributeAsString("chartType");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.chartType:" + t.getMessage() + "\n";
        }
        try {
            s.checkboxFieldFalseImage = getAttributeAsString("checkboxFieldFalseImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.checkboxFieldFalseImage:" + t.getMessage() + "\n";
        }
        try {
            s.checkboxFieldImageHeight = getAttributeAsString("checkboxFieldImageHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.checkboxFieldImageHeight:" + t.getMessage() + "\n";
        }
        try {
            s.checkboxFieldImageWidth = getAttributeAsString("checkboxFieldImageWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.checkboxFieldImageWidth:" + t.getMessage() + "\n";
        }
        try {
            s.checkboxFieldPartialImage = getAttributeAsString("checkboxFieldPartialImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.checkboxFieldPartialImage:" + t.getMessage() + "\n";
        }
        try {
            s.checkboxFieldTrueImage = getAttributeAsString("checkboxFieldTrueImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.checkboxFieldTrueImage:" + t.getMessage() + "\n";
        }
        try {
            s.childExpansionMode = getAttributeAsString("childExpansionMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.childExpansionMode:" + t.getMessage() + "\n";
        }
        try {
            s.clearAllSortingText = getAttributeAsString("clearAllSortingText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.clearAllSortingText:" + t.getMessage() + "\n";
        }
        try {
            s.clearFilterText = getAttributeAsString("clearFilterText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.clearFilterText:" + t.getMessage() + "\n";
        }
        try {
            s.clearSortFieldText = getAttributeAsString("clearSortFieldText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.clearSortFieldText:" + t.getMessage() + "\n";
        }
        try {
            s.clipHeaderTitles = getAttributeAsString("clipHeaderTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.clipHeaderTitles:" + t.getMessage() + "\n";
        }
        try {
            s.collapseGroupOnRowClick = getAttributeAsString("collapseGroupOnRowClick");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.collapseGroupOnRowClick:" + t.getMessage() + "\n";
        }
        try {
            s.configureGroupingText = getAttributeAsString("configureGroupingText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.configureGroupingText:" + t.getMessage() + "\n";
        }
        try {
            s.configureSortText = getAttributeAsString("configureSortText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.configureSortText:" + t.getMessage() + "\n";
        }
        try {
            s.confirmCancelEditing = getAttributeAsString("confirmCancelEditing");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.confirmCancelEditing:" + t.getMessage() + "\n";
        }
        try {
            s.confirmDiscardEdits = getAttributeAsString("confirmDiscardEdits");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.confirmDiscardEdits:" + t.getMessage() + "\n";
        }
        try {
            s.confirmDiscardEditsMessage = getAttributeAsString("confirmDiscardEditsMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.confirmDiscardEditsMessage:" + t.getMessage() + "\n";
        }
        try {
            s.dataFetchDelay = getAttributeAsString("dataFetchDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dataFetchDelay:" + t.getMessage() + "\n";
        }
        try {
            s.dataFetchMode = getAttributeAsString("dataFetchMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dataFetchMode:" + t.getMessage() + "\n";
        }
        try {
            s.dateFormatter = getAttributeAsString("dateFormatter");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dateFormatter:" + t.getMessage() + "\n";
        }
        try {
            s.datetimeFormatter = getAttributeAsString("datetimeFormatter");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.datetimeFormatter:" + t.getMessage() + "\n";
        }
        try {
            s.defaultDateFieldWidth = getAttributeAsString("defaultDateFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultDateFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.defaultDateTimeFieldWidth = getAttributeAsString("defaultDateTimeFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultDateTimeFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.defaultEditableDateFieldWidth = getAttributeAsString("defaultEditableDateFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultEditableDateFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.defaultEditableDateTimeFieldWidth = getAttributeAsString("defaultEditableDateTimeFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultEditableDateTimeFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.defaultFilterOperator = getAttributeAsString("defaultFilterOperator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultFilterOperator:" + t.getMessage() + "\n";
        }
        try {
            s.defaultFilterOperatorSuffix = getAttributeAsString("defaultFilterOperatorSuffix");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultFilterOperatorSuffix:" + t.getMessage() + "\n";
        }
        try {
            s.defaultTimeFieldWidth = getAttributeAsString("defaultTimeFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.defaultTimeFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.deferRemoval = getAttributeAsString("deferRemoval");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.deferRemoval:" + t.getMessage() + "\n";
        }
        try {
            s.deselectOnPartialCheckboxClick = getAttributeAsString("deselectOnPartialCheckboxClick");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.deselectOnPartialCheckboxClick:" + t.getMessage() + "\n";
        }
        try {
            s.detailDS = getAttributeAsString("detailDS");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.detailDS:" + t.getMessage() + "\n";
        }
        try {
            s.detailField = getAttributeAsString("detailField");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.detailField:" + t.getMessage() + "\n";
        }
        try {
            s.discardEditsOnHideField = getAttributeAsString("discardEditsOnHideField");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.discardEditsOnHideField:" + t.getMessage() + "\n";
        }
        try {
            s.discardEditsSaveButtonTitle = getAttributeAsString("discardEditsSaveButtonTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.discardEditsSaveButtonTitle:" + t.getMessage() + "\n";
        }
        try {
            s.dragHandleFieldTitle = getAttributeAsString("dragHandleFieldTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dragHandleFieldTitle:" + t.getMessage() + "\n";
        }
        try {
            s.dragHandleIcon = getAttributeAsString("dragHandleIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dragHandleIcon:" + t.getMessage() + "\n";
        }
        try {
            s.dragHandleIconSize = getAttributeAsString("dragHandleIconSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dragHandleIconSize:" + t.getMessage() + "\n";
        }
        try {
            s.dragScrollRedrawDelay = getAttributeAsString("dragScrollRedrawDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dragScrollRedrawDelay:" + t.getMessage() + "\n";
        }
        try {
            s.dragTrackerMode = getAttributeAsString("dragTrackerMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.dragTrackerMode:" + t.getMessage() + "\n";
        }
        try {
            s.drawAllMaxCells = getAttributeAsString("drawAllMaxCells");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.drawAllMaxCells:" + t.getMessage() + "\n";
        }
        try {
            s.editByCell = getAttributeAsString("editByCell");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editByCell:" + t.getMessage() + "\n";
        }
        try {
            s.editEvent = getAttributeAsString("editEvent");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editEvent:" + t.getMessage() + "\n";
        }
        try {
            s.editFailedBaseStyle = getAttributeAsString("editFailedBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editFailedBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.editFailedCSSText = getAttributeAsString("editFailedCSSText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editFailedCSSText:" + t.getMessage() + "\n";
        }
        try {
            s.editOnF2Keypress = getAttributeAsString("editOnF2Keypress");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editOnF2Keypress:" + t.getMessage() + "\n";
        }
        try {
            s.editOnFocus = getAttributeAsString("editOnFocus");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editOnFocus:" + t.getMessage() + "\n";
        }
        try {
            s.editPendingBaseStyle = getAttributeAsString("editPendingBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editPendingBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.editPendingCSSText = getAttributeAsString("editPendingCSSText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editPendingCSSText:" + t.getMessage() + "\n";
        }
        try {
            s.editProxyConstructor = getAttributeAsString("editProxyConstructor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editProxyConstructor:" + t.getMessage() + "\n";
        }
        try {
            s.editSelectionType = getAttributeAsString("editSelectionType");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.editSelectionType:" + t.getMessage() + "\n";
        }
        try {
            s.emptyCellValue = getAttributeAsString("emptyCellValue");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.emptyCellValue:" + t.getMessage() + "\n";
        }
        try {
            s.emptyMessage = getAttributeAsString("emptyMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.emptyMessage:" + t.getMessage() + "\n";
        }
        try {
            s.emptyMessageStyle = getAttributeAsString("emptyMessageStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.emptyMessageStyle:" + t.getMessage() + "\n";
        }
        try {
            s.enforceVClipping = getAttributeAsString("enforceVClipping");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.enforceVClipping:" + t.getMessage() + "\n";
        }
        try {
            s.enterKeyEditAction = getAttributeAsString("enterKeyEditAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.enterKeyEditAction:" + t.getMessage() + "\n";
        }
        try {
            s.enumCriteriaAsInitialValues = getAttributeAsString("enumCriteriaAsInitialValues");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.enumCriteriaAsInitialValues:" + t.getMessage() + "\n";
        }
        try {
            s.errorIconHeight = getAttributeAsString("errorIconHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.errorIconHeight:" + t.getMessage() + "\n";
        }
        try {
            s.errorIconSrc = getAttributeAsString("errorIconSrc");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.errorIconSrc:" + t.getMessage() + "\n";
        }
        try {
            s.errorIconWidth = getAttributeAsString("errorIconWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.errorIconWidth:" + t.getMessage() + "\n";
        }
        try {
            s.escapeKeyEditAction = getAttributeAsString("escapeKeyEditAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.escapeKeyEditAction:" + t.getMessage() + "\n";
        }
        try {
            s.expansionCanEdit = getAttributeAsString("expansionCanEdit");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionCanEdit:" + t.getMessage() + "\n";
        }
        try {
            s.expansionComponentPoolingMode = getAttributeAsString("expansionComponentPoolingMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionComponentPoolingMode:" + t.getMessage() + "\n";
        }
        try {
            s.expansionEditorCollapseOnSave = getAttributeAsString("expansionEditorCollapseOnSave");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionEditorCollapseOnSave:" + t.getMessage() + "\n";
        }
        try {
            s.expansionEditorSaveButtonTitle = getAttributeAsString("expansionEditorSaveButtonTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionEditorSaveButtonTitle:" + t.getMessage() + "\n";
        }
        try {
            s.expansionEditorSaveDialogPrompt = getAttributeAsString("expansionEditorSaveDialogPrompt");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionEditorSaveDialogPrompt:" + t.getMessage() + "\n";
        }
        try {
            s.expansionEditorShowSaveDialog = getAttributeAsString("expansionEditorShowSaveDialog");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionEditorShowSaveDialog:" + t.getMessage() + "\n";
        }
        try {
            s.expansionFieldFalseImage = getAttributeAsString("expansionFieldFalseImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionFieldFalseImage:" + t.getMessage() + "\n";
        }
        try {
            s.expansionFieldImageHeight = getAttributeAsString("expansionFieldImageHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionFieldImageHeight:" + t.getMessage() + "\n";
        }
        try {
            s.expansionFieldImageShowSelected = getAttributeAsString("expansionFieldImageShowSelected");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionFieldImageShowSelected:" + t.getMessage() + "\n";
        }
        try {
            s.expansionFieldImageWidth = getAttributeAsString("expansionFieldImageWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionFieldImageWidth:" + t.getMessage() + "\n";
        }
        try {
            s.expansionFieldTrueImage = getAttributeAsString("expansionFieldTrueImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionFieldTrueImage:" + t.getMessage() + "\n";
        }
        try {
            s.expansionMode = getAttributeAsString("expansionMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.expansionMode:" + t.getMessage() + "\n";
        }
        try {
            s.exportAlternateRowBGColor = getAttributeAsString("exportAlternateRowBGColor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportAlternateRowBGColor:" + t.getMessage() + "\n";
        }
        try {
            s.exportDefaultBGColor = getAttributeAsString("exportDefaultBGColor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportDefaultBGColor:" + t.getMessage() + "\n";
        }
        try {
            s.exportFieldAlignments = getAttributeAsString("exportFieldAlignments");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportFieldAlignments:" + t.getMessage() + "\n";
        }
        try {
            s.exportFieldWidths = getAttributeAsString("exportFieldWidths");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportFieldWidths:" + t.getMessage() + "\n";
        }
        try {
            s.exportHeaderHeights = getAttributeAsString("exportHeaderHeights");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportHeaderHeights:" + t.getMessage() + "\n";
        }
        try {
            s.exportHiddenFieldWidth = getAttributeAsString("exportHiddenFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportHiddenFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.exportRawNumbers = getAttributeAsString("exportRawNumbers");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportRawNumbers:" + t.getMessage() + "\n";
        }
        try {
            s.exportRawValues = getAttributeAsString("exportRawValues");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportRawValues:" + t.getMessage() + "\n";
        }
        try {
            s.exportWidthScale = getAttributeAsString("exportWidthScale");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportWidthScale:" + t.getMessage() + "\n";
        }
        try {
            s.exportWrapHeaderTitles = getAttributeAsString("exportWrapHeaderTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.exportWrapHeaderTitles:" + t.getMessage() + "\n";
        }
        try {
            s.fetchDelay = getAttributeAsString("fetchDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fetchDelay:" + t.getMessage() + "\n";
        }
        try {
            s.fieldPickerFieldProperties = getAttributeAsStringArray("fieldPickerFieldProperties");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fieldPickerFieldPropertiesArray:" + t.getMessage() + "\n";
        }
        try {
            s.fieldPickerShowSampleValues = getAttributeAsString("fieldPickerShowSampleValues");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fieldPickerShowSampleValues:" + t.getMessage() + "\n";
        }
        try {
            s.fields = getFields();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fieldsArray:" + t.getMessage() + "\n";
        }
        try {
            s.fieldState = getAttributeAsString("fieldState");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fieldState:" + t.getMessage() + "\n";
        }
        try {
            s.fieldVisibilitySubmenuTitle = getAttributeAsString("fieldVisibilitySubmenuTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fieldVisibilitySubmenuTitle:" + t.getMessage() + "\n";
        }
        try {
            s.filterButtonPrompt = getAttributeAsString("filterButtonPrompt");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterButtonPrompt:" + t.getMessage() + "\n";
        }
        try {
            s.filterByCell = getAttributeAsString("filterByCell");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterByCell:" + t.getMessage() + "\n";
        }
        try {
            s.filterEditorHeight = getAttributeAsString("filterEditorHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterEditorHeight:" + t.getMessage() + "\n";
        }
        try {
            s.filterLocalData = getAttributeAsString("filterLocalData");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterLocalData:" + t.getMessage() + "\n";
        }
        try {
            s.filterOnKeypress = getAttributeAsString("filterOnKeypress");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterOnKeypress:" + t.getMessage() + "\n";
        }
        try {
            s.filterUsingText = getAttributeAsString("filterUsingText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.filterUsingText:" + t.getMessage() + "\n";
        }
        try {
            s.fixedFieldWidths = getAttributeAsString("fixedFieldWidths");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fixedFieldWidths:" + t.getMessage() + "\n";
        }
        try {
            s.fixedRecordHeights = getAttributeAsString("fixedRecordHeights");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.fixedRecordHeights:" + t.getMessage() + "\n";
        }
        try {
            s.formulaBuilderSpanTitleSeparator = getAttributeAsString("formulaBuilderSpanTitleSeparator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.formulaBuilderSpanTitleSeparator:" + t.getMessage() + "\n";
        }
        try {
            s.freezeFieldText = getAttributeAsString("freezeFieldText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.freezeFieldText:" + t.getMessage() + "\n";
        }
        try {
            s.freezeOnLeftText = getAttributeAsString("freezeOnLeftText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.freezeOnLeftText:" + t.getMessage() + "\n";
        }
        try {
            s.freezeOnRightText = getAttributeAsString("freezeOnRightText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.freezeOnRightText:" + t.getMessage() + "\n";
        }
        try {
            s.frozenBaseStyle = getAttributeAsString("frozenBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.frozenBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.frozenHeaderBaseStyle = getAttributeAsString("frozenHeaderBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.frozenHeaderBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.frozenHeaderTitleStyle = getAttributeAsString("frozenHeaderTitleStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.frozenHeaderTitleStyle:" + t.getMessage() + "\n";
        }
        try {
            s.generateClickOnEnter = getAttributeAsString("generateClickOnEnter");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.generateClickOnEnter:" + t.getMessage() + "\n";
        }
        try {
            s.generateClickOnSpace = getAttributeAsString("generateClickOnSpace");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.generateClickOnSpace:" + t.getMessage() + "\n";
        }
        try {
            s.generateDoubleClickOnEnter = getAttributeAsString("generateDoubleClickOnEnter");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.generateDoubleClickOnEnter:" + t.getMessage() + "\n";
        }
        try {
            s.generateDoubleClickOnSpace = getAttributeAsString("generateDoubleClickOnSpace");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.generateDoubleClickOnSpace:" + t.getMessage() + "\n";
        }
        try {
            s.gridSummaryRecordProperty = getAttributeAsString("gridSummaryRecordProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.gridSummaryRecordProperty:" + t.getMessage() + "\n";
        }
        try {
            s.groupByAsyncThreshold = getAttributeAsString("groupByAsyncThreshold");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupByAsyncThreshold:" + t.getMessage() + "\n";
        }
        try {
            s.groupByFieldSummaries = getAttributeAsStringArray("groupByFieldSummaries");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupByFieldSummariesArray:" + t.getMessage() + "\n";
        }
        try {
            s.groupByMaxRecords = getAttributeAsString("groupByMaxRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupByMaxRecords:" + t.getMessage() + "\n";
        }
        try {
            s.groupByText = getAttributeAsString("groupByText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupByText:" + t.getMessage() + "\n";
        }
        try {
            s.groupIcon = getAttributeAsString("groupIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupIcon:" + t.getMessage() + "\n";
        }
        try {
            s.groupIconSize = getAttributeAsString("groupIconSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupIconSize:" + t.getMessage() + "\n";
        }
        try {
            s.groupIndentSize = getAttributeAsString("groupIndentSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupIndentSize:" + t.getMessage() + "\n";
        }
        try {
            s.groupLeadingIndent = getAttributeAsString("groupLeadingIndent");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupLeadingIndent:" + t.getMessage() + "\n";
        }
        try {
            s.groupNodeBaseStyle = getAttributeAsString("groupNodeBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupNodeBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.groupNodeStyle = getAttributeAsString("groupNodeStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupNodeStyle:" + t.getMessage() + "\n";
        }
        try {
            s.groupSortDirection = getAttributeAsString("groupSortDirection");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupSortDirection:" + t.getMessage() + "\n";
        }
        try {
            s.groupStartOpenAsString = getAttributeAsString("groupStartOpen");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupStartOpenAsString:" + t.getMessage() + "\n";
        }
        try {
            s.groupState = getAttributeAsString("groupState");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupState:" + t.getMessage() + "\n";
        }
        try {
            s.groupSummaryRecordProperty = getAttributeAsString("groupSummaryRecordProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupSummaryRecordProperty:" + t.getMessage() + "\n";
        }
        try {
            s.groupSummaryStyle = getAttributeAsString("groupSummaryStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupSummaryStyle:" + t.getMessage() + "\n";
        }
        try {
            s.groupTitleField = getAttributeAsString("groupTitleField");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.groupTitleField:" + t.getMessage() + "\n";
        }
        try {
            s.headerAutoFitEvent = getAttributeAsString("headerAutoFitEvent");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerAutoFitEvent:" + t.getMessage() + "\n";
        }
        try {
            s.headerBackgroundColor = getAttributeAsString("headerBackgroundColor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerBackgroundColor:" + t.getMessage() + "\n";
        }
        try {
            s.headerBarStyle = getAttributeAsString("headerBarStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerBarStyle:" + t.getMessage() + "\n";
        }
        try {
            s.headerBaseStyle = getAttributeAsString("headerBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.headerHeight = getAttributeAsString("headerHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHeight:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverAlign = getAttributeAsString("headerHoverAlign");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverAlign:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverHeight = getAttributeAsString("headerHoverHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverHeight:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverOpacity = getAttributeAsString("headerHoverOpacity");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverOpacity:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverStyle = getAttributeAsString("headerHoverStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverStyle:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverVAlign = getAttributeAsString("headerHoverVAlign");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverVAlign:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverWidth = getAttributeAsString("headerHoverWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverWidth:" + t.getMessage() + "\n";
        }
        try {
            s.headerHoverWrap = getAttributeAsString("headerHoverWrap");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerHoverWrap:" + t.getMessage() + "\n";
        }
        try {
            s.headerMenuButtonHeight = getAttributeAsString("headerMenuButtonHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerMenuButtonHeight:" + t.getMessage() + "\n";
        }
        try {
            s.headerMenuButtonIcon = getAttributeAsString("headerMenuButtonIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerMenuButtonIcon:" + t.getMessage() + "\n";
        }
        try {
            s.headerMenuButtonIconHeight = getAttributeAsString("headerMenuButtonIconHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerMenuButtonIconHeight:" + t.getMessage() + "\n";
        }
        try {
            s.headerMenuButtonIconWidth = getAttributeAsString("headerMenuButtonIconWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerMenuButtonIconWidth:" + t.getMessage() + "\n";
        }
        try {
            s.headerMenuButtonWidth = getAttributeAsString("headerMenuButtonWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerMenuButtonWidth:" + t.getMessage() + "\n";
        }
        try {
            s.headerShadowColor = getAttributeAsString("headerShadowColor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerShadowColor:" + t.getMessage() + "\n";
        }
        try {
            s.headerShadowHOffset = getAttributeAsString("headerShadowHOffset");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerShadowHOffset:" + t.getMessage() + "\n";
        }
        try {
            s.headerShadowSoftness = getAttributeAsString("headerShadowSoftness");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerShadowSoftness:" + t.getMessage() + "\n";
        }
        try {
            s.headerShadowVOffset = getAttributeAsString("headerShadowVOffset");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerShadowVOffset:" + t.getMessage() + "\n";
        }
        try {
            s.headerSpanHeight = getAttributeAsString("headerSpanHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerSpanHeight:" + t.getMessage() + "\n";
        }
        try {
            s.headerTitleStyle = getAttributeAsString("headerTitleStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerTitleStyle:" + t.getMessage() + "\n";
        }
        try {
            s.headerTitleVAlign = getAttributeAsString("headerTitleVAlign");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.headerTitleVAlign:" + t.getMessage() + "\n";
        }
        try {
            s.hideEmptySummaryRow = getAttributeAsString("hideEmptySummaryRow");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hideEmptySummaryRow:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteCanReplaceValue = getAttributeAsString("hiliteCanReplaceValue");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteCanReplaceValue:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteEditorSpanTitleSeparator = getAttributeAsString("hiliteEditorSpanTitleSeparator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteEditorSpanTitleSeparator:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteHTMLAfterFormat = getAttributeAsString("hiliteHTMLAfterFormat");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteHTMLAfterFormat:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconHeight = getAttributeAsString("hiliteIconHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconHeight:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconLeftPadding = getAttributeAsString("hiliteIconLeftPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconLeftPadding:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconPosition = getAttributeAsString("hiliteIconPosition");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconPosition:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconRightPadding = getAttributeAsString("hiliteIconRightPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconRightPadding:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIcons = getAttributeAsStringArray("hiliteIcons");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconsArray:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconSize = getAttributeAsString("hiliteIconSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconSize:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteIconWidth = getAttributeAsString("hiliteIconWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteIconWidth:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteReplaceValueFieldTitle = getAttributeAsString("hiliteReplaceValueFieldTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteReplaceValueFieldTitle:" + t.getMessage() + "\n";
        }
        try {
            s.hiliteRowOnFocus = getAttributeAsString("hiliteRowOnFocus");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hiliteRowOnFocus:" + t.getMessage() + "\n";
        }
        try {
            s.hoverMode = getAttributeAsString("hoverMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hoverMode:" + t.getMessage() + "\n";
        }
        try {
            s.hoverStyle = getAttributeAsString("hoverStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.hoverStyle:" + t.getMessage() + "\n";
        }
        try {
            s.iconPadding = getAttributeAsString("iconPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.iconPadding:" + t.getMessage() + "\n";
        }
        try {
            s.imageSize = getAttributeAsString("imageSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.imageSize:" + t.getMessage() + "\n";
        }
        try {
            s.includeHilitesInSummaryFields = getAttributeAsString("includeHilitesInSummaryFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.includeHilitesInSummaryFields:" + t.getMessage() + "\n";
        }
        try {
            s.includeInSummaryProperty = getAttributeAsString("includeInSummaryProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.includeInSummaryProperty:" + t.getMessage() + "\n";
        }
        try {
            s.initialSort = getInitialSort();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.initialSortArray:" + t.getMessage() + "\n";
        }
        try {
            s.instantScrollTrackRedraw = getAttributeAsString("instantScrollTrackRedraw");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.instantScrollTrackRedraw:" + t.getMessage() + "\n";
        }
        try {
            s.invalidSummaryValue = getAttributeAsString("invalidSummaryValue");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.invalidSummaryValue:" + t.getMessage() + "\n";
        }
        try {
            s.isGrouped = getAttributeAsString("isGrouped");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.isGrouped:" + t.getMessage() + "\n";
        }
        try {
            s.isSeparatorProperty = getAttributeAsString("isSeparatorProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.isSeparatorProperty:" + t.getMessage() + "\n";
        }
        try {
            s.leaveScrollbarGap = getAttributeAsString("leaveScrollbarGap");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.leaveScrollbarGap:" + t.getMessage() + "\n";
        }
        try {
            s.linkTextProperty = getAttributeAsString("linkTextProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.linkTextProperty:" + t.getMessage() + "\n";
        }
        try {
            s.listEndEditAction = getAttributeAsString("listEndEditAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.listEndEditAction:" + t.getMessage() + "\n";
        }
        try {
            s.loadingDataMessage = getAttributeAsString("loadingDataMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.loadingDataMessage:" + t.getMessage() + "\n";
        }
        try {
            s.loadingDataMessageStyle = getAttributeAsString("loadingDataMessageStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.loadingDataMessageStyle:" + t.getMessage() + "\n";
        }
        try {
            s.loadingMessage = getAttributeAsString("loadingMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.loadingMessage:" + t.getMessage() + "\n";
        }
        try {
            s.locateColumnsBy = getAttributeAsString("locateColumnsBy");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.locateColumnsBy:" + t.getMessage() + "\n";
        }
        try {
            s.locateRowsBy = getAttributeAsString("locateRowsBy");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.locateRowsBy:" + t.getMessage() + "\n";
        }
        try {
            s.longTextEditorThreshold = getAttributeAsString("longTextEditorThreshold");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.longTextEditorThreshold:" + t.getMessage() + "\n";
        }
        try {
            s.longTextEditorType = getAttributeAsString("longTextEditorType");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.longTextEditorType:" + t.getMessage() + "\n";
        }
        try {
            s.maxExpandedRecords = getAttributeAsString("maxExpandedRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.maxExpandedRecords:" + t.getMessage() + "\n";
        }
        try {
            s.maxExpandedRecordsPrompt = getAttributeAsString("maxExpandedRecordsPrompt");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.maxExpandedRecordsPrompt:" + t.getMessage() + "\n";
        }
        try {
            s.minFieldWidth = getAttributeAsString("minFieldWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.minFieldWidth:" + t.getMessage() + "\n";
        }
        try {
            s.minHeight = getAttributeAsString("minHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.minHeight:" + t.getMessage() + "\n";
        }
        try {
            s.minimumCellHeight = getAttributeAsString("minimumCellHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.minimumCellHeight:" + t.getMessage() + "\n";
        }
        try {
            s.missingSummaryFieldValue = getAttributeAsString("missingSummaryFieldValue");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.missingSummaryFieldValue:" + t.getMessage() + "\n";
        }
        try {
            s.modalEditing = getAttributeAsString("modalEditing");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.modalEditing:" + t.getMessage() + "\n";
        }
        try {
            s.navigateOnTab = getAttributeAsString("navigateOnTab");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.navigateOnTab:" + t.getMessage() + "\n";
        }
        try {
            s.neverValidate = getAttributeAsString("neverValidate");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.neverValidate:" + t.getMessage() + "\n";
        }
        try {
            s.normalBaseStyle = getAttributeAsString("normalBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.normalBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.normalCellHeight = getAttributeAsString("normalCellHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.normalCellHeight:" + t.getMessage() + "\n";
        }
        try {
            s.nullGroupTitle = getAttributeAsString("nullGroupTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.nullGroupTitle:" + t.getMessage() + "\n";
        }
        try {
            s.offlineMessageStyle = getAttributeAsString("offlineMessageStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.offlineMessageStyle:" + t.getMessage() + "\n";
        }
        try {
            s.originBaseStyle = getAttributeAsString("originBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.originBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.overflow = getAttributeAsString("overflow");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.overflow:" + t.getMessage() + "\n";
        }
        try {
            s.poolComponentsPerColumn = getAttributeAsString("poolComponentsPerColumn");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.poolComponentsPerColumn:" + t.getMessage() + "\n";
        }
        try {
            s.preserveWhitespace = getAttributeAsString("preserveWhitespace");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.preserveWhitespace:" + t.getMessage() + "\n";
        }
        try {
            s.printAutoFit = getAttributeAsString("printAutoFit");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printAutoFit:" + t.getMessage() + "\n";
        }
        try {
            s.printBaseStyle = getAttributeAsString("printBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.printBooleanBaseStyle = getAttributeAsString("printBooleanBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printBooleanBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.printBooleanFalseImage = getAttributeAsString("printBooleanFalseImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printBooleanFalseImage:" + t.getMessage() + "\n";
        }
        try {
            s.printBooleanPartialImage = getAttributeAsString("printBooleanPartialImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printBooleanPartialImage:" + t.getMessage() + "\n";
        }
        try {
            s.printBooleanTrueImage = getAttributeAsString("printBooleanTrueImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printBooleanTrueImage:" + t.getMessage() + "\n";
        }
        try {
            s.printCheckboxFieldFalseImage = getAttributeAsString("printCheckboxFieldFalseImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printCheckboxFieldFalseImage:" + t.getMessage() + "\n";
        }
        try {
            s.printCheckboxFieldPartialImage = getAttributeAsString("printCheckboxFieldPartialImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printCheckboxFieldPartialImage:" + t.getMessage() + "\n";
        }
        try {
            s.printCheckboxFieldTrueImage = getAttributeAsString("printCheckboxFieldTrueImage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printCheckboxFieldTrueImage:" + t.getMessage() + "\n";
        }
        try {
            s.printHeaderStyle = getAttributeAsString("printHeaderStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printHeaderStyle:" + t.getMessage() + "\n";
        }
        try {
            s.printMaxRows = getAttributeAsString("printMaxRows");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printMaxRows:" + t.getMessage() + "\n";
        }
        try {
            s.printWrapCells = getAttributeAsString("printWrapCells");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.printWrapCells:" + t.getMessage() + "\n";
        }
        try {
            s.recordBaseStyleProperty = getAttributeAsString("recordBaseStyleProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordBaseStyleProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordCanRemoveProperty = getAttributeAsString("recordCanRemoveProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordCanRemoveProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordCanSelectProperty = getAttributeAsString("recordCanSelectProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordCanSelectProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordComponentHeight = getAttributeAsString("recordComponentHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordComponentHeight:" + t.getMessage() + "\n";
        }
        try {
            s.recordComponentPoolingMode = getAttributeAsString("recordComponentPoolingMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordComponentPoolingMode:" + t.getMessage() + "\n";
        }
        try {
            s.recordComponentPosition = getAttributeAsString("recordComponentPosition");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordComponentPosition:" + t.getMessage() + "\n";
        }
        try {
            s.recordDetailDSProperty = getAttributeAsString("recordDetailDSProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordDetailDSProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordDropAppearance = getAttributeAsString("recordDropAppearance");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordDropAppearance:" + t.getMessage() + "\n";
        }
        try {
            s.recordEditProperty = getAttributeAsString("recordEditProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordEditProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordEnabledProperty = getAttributeAsString("recordEnabledProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordEnabledProperty:" + t.getMessage() + "\n";
        }
        try {
            s.recordSummaryBaseStyle = getAttributeAsString("recordSummaryBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.recordSummaryBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.removedCSSText = getAttributeAsString("removedCSSText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.removedCSSText:" + t.getMessage() + "\n";
        }
        try {
            s.removeFieldTitle = getAttributeAsString("removeFieldTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.removeFieldTitle:" + t.getMessage() + "\n";
        }
        try {
            s.removeIcon = getAttributeAsString("removeIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.removeIcon:" + t.getMessage() + "\n";
        }
        try {
            s.removeIconSize = getAttributeAsString("removeIconSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.removeIconSize:" + t.getMessage() + "\n";
        }
        try {
            s.reselectOnUpdate = getAttributeAsString("reselectOnUpdate");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.reselectOnUpdate:" + t.getMessage() + "\n";
        }
        try {
            s.reselectOnUpdateNotifications = getAttributeAsString("reselectOnUpdateNotifications");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.reselectOnUpdateNotifications:" + t.getMessage() + "\n";
        }
        try {
            s.resizeFieldsInRealTime = getAttributeAsString("resizeFieldsInRealTime");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.resizeFieldsInRealTime:" + t.getMessage() + "\n";
        }
        try {
            s.reverseRTLAlign = getAttributeAsString("reverseRTLAlign");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.reverseRTLAlign:" + t.getMessage() + "\n";
        }
        try {
            s.rotatedHeaderMenuButtonHeight = getAttributeAsString("rotatedHeaderMenuButtonHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rotatedHeaderMenuButtonHeight:" + t.getMessage() + "\n";
        }
        try {
            s.rotatedHeaderMenuButtonWidth = getAttributeAsString("rotatedHeaderMenuButtonWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rotatedHeaderMenuButtonWidth:" + t.getMessage() + "\n";
        }
        try {
            s.rotateHeaderTitles = getAttributeAsString("rotateHeaderTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rotateHeaderTitles:" + t.getMessage() + "\n";
        }
        try {
            s.rowEndEditAction = getAttributeAsString("rowEndEditAction");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rowEndEditAction:" + t.getMessage() + "\n";
        }
        try {
            s.rowNumberStart = getAttributeAsString("rowNumberStart");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rowNumberStart:" + t.getMessage() + "\n";
        }
        try {
            s.rowNumberStyle = getAttributeAsString("rowNumberStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rowNumberStyle:" + t.getMessage() + "\n";
        }
        try {
            s.rowSpanEditMode = getAttributeAsString("rowSpanEditMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rowSpanEditMode:" + t.getMessage() + "\n";
        }
        try {
            s.rowSpanSelectionMode = getAttributeAsString("rowSpanSelectionMode");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.rowSpanSelectionMode:" + t.getMessage() + "\n";
        }
        try {
            s.saveByCell = getAttributeAsString("saveByCell");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.saveByCell:" + t.getMessage() + "\n";
        }
        try {
            s.saveLocally = getAttributeAsString("saveLocally");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.saveLocally:" + t.getMessage() + "\n";
        }
        try {
            s.screenReaderCellSeparator = getAttributeAsString("screenReaderCellSeparator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.screenReaderCellSeparator:" + t.getMessage() + "\n";
        }
        try {
            s.screenReaderRowSeparator = getAttributeAsString("screenReaderRowSeparator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.screenReaderRowSeparator:" + t.getMessage() + "\n";
        }
        try {
            s.scrollRedrawDelay = getAttributeAsString("scrollRedrawDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.scrollRedrawDelay:" + t.getMessage() + "\n";
        }
        try {
            s.scrollToCellXPosition = getAttributeAsString("scrollToCellXPosition");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.scrollToCellXPosition:" + t.getMessage() + "\n";
        }
        try {
            s.scrollToCellYPosition = getAttributeAsString("scrollToCellYPosition");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.scrollToCellYPosition:" + t.getMessage() + "\n";
        }
        try {
            s.scrollWheelRedrawDelay = getAttributeAsString("scrollWheelRedrawDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.scrollWheelRedrawDelay:" + t.getMessage() + "\n";
        }
        try {
            s.selectCellTextOnClick = getAttributeAsString("selectCellTextOnClick");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectCellTextOnClick:" + t.getMessage() + "\n";
        }
        try {
            s.selectedState = getAttributeAsString("selectedState");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectedState:" + t.getMessage() + "\n";
        }
        try {
            s.selectHeaderOnSort = getAttributeAsString("selectHeaderOnSort");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectHeaderOnSort:" + t.getMessage() + "\n";
        }
        try {
            s.selectionAppearance = getAttributeAsString("selectionAppearance");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectionAppearance:" + t.getMessage() + "\n";
        }
        try {
            s.selectionProperty = getAttributeAsString("selectionProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectionProperty:" + t.getMessage() + "\n";
        }
        try {
            s.selectionType = getAttributeAsString("selectionType");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectionType:" + t.getMessage() + "\n";
        }
        try {
            s.selectOnEdit = getAttributeAsString("selectOnEdit");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectOnEdit:" + t.getMessage() + "\n";
        }
        try {
            s.selectOnExpandRecord = getAttributeAsString("selectOnExpandRecord");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.selectOnExpandRecord:" + t.getMessage() + "\n";
        }
        try {
            s.showAllColumns = getAttributeAsString("showAllColumns");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showAllColumns:" + t.getMessage() + "\n";
        }
        try {
            s.showAllRecords = getAttributeAsString("showAllRecords");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showAllRecords:" + t.getMessage() + "\n";
        }
        try {
            s.showAsynchGroupingPrompt = getAttributeAsString("showAsynchGroupingPrompt");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showAsynchGroupingPrompt:" + t.getMessage() + "\n";
        }
        try {
            s.showBackgroundComponents = getAttributeAsString("showBackgroundComponents");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showBackgroundComponents:" + t.getMessage() + "\n";
        }
        try {
            s.showCellContextMenus = getAttributeAsString("showCellContextMenus");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showCellContextMenus:" + t.getMessage() + "\n";
        }
        try {
            s.showClippedHeaderTitlesOnHover = getAttributeAsString("showClippedHeaderTitlesOnHover");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showClippedHeaderTitlesOnHover:" + t.getMessage() + "\n";
        }
        try {
            s.showClippedValuesOnHover = getAttributeAsString("showClippedValuesOnHover");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showClippedValuesOnHover:" + t.getMessage() + "\n";
        }
        try {
            s.showCollapsedGroupSummary = getAttributeAsString("showCollapsedGroupSummary");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showCollapsedGroupSummary:" + t.getMessage() + "\n";
        }
        try {
            s.showDetailFields = getAttributeAsString("showDetailFields");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showDetailFields:" + t.getMessage() + "\n";
        }
        try {
            s.showEllipsisWhenClipped = getAttributeAsString("showEllipsisWhenClipped");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showEllipsisWhenClipped:" + t.getMessage() + "\n";
        }
        try {
            s.showEmptyMessage = getAttributeAsString("showEmptyMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showEmptyMessage:" + t.getMessage() + "\n";
        }
        try {
            s.showErrorIcons = getAttributeAsString("showErrorIcons");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showErrorIcons:" + t.getMessage() + "\n";
        }
        try {
            s.showExpansionEditorSaveButton = getAttributeAsString("showExpansionEditorSaveButton");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showExpansionEditorSaveButton:" + t.getMessage() + "\n";
        }
        try {
            s.showFilterEditor = getAttributeAsString("showFilterEditor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showFilterEditor:" + t.getMessage() + "\n";
        }
        try {
            s.showGridSummary = getAttributeAsString("showGridSummary");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showGridSummary:" + t.getMessage() + "\n";
        }
        try {
            s.showGroupSummary = getAttributeAsString("showGroupSummary");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showGroupSummary:" + t.getMessage() + "\n";
        }
        try {
            s.showGroupSummaryInHeader = getAttributeAsString("showGroupSummaryInHeader");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showGroupSummaryInHeader:" + t.getMessage() + "\n";
        }
        try {
            s.showGroupTitleColumn = getAttributeAsString("showGroupTitleColumn");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showGroupTitleColumn:" + t.getMessage() + "\n";
        }
        try {
            s.showGroupTitleInFrozenBody = getAttributeAsString("showGroupTitleInFrozenBody");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showGroupTitleInFrozenBody:" + t.getMessage() + "\n";
        }
        try {
            s.showHeader = getAttributeAsString("showHeader");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeader:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderContextMenu = getAttributeAsString("showHeaderContextMenu");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderContextMenu:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderMenuButton = getAttributeAsString("showHeaderMenuButton");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderMenuButton:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderPartialSelection = getAttributeAsString("showHeaderPartialSelection");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderPartialSelection:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderShadow = getAttributeAsString("showHeaderShadow");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderShadow:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderSpanTitlesInFormulaBuilder = getAttributeAsString("showHeaderSpanTitlesInFormulaBuilder");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderSpanTitlesInFormulaBuilder:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderSpanTitlesInHiliteEditor = getAttributeAsString("showHeaderSpanTitlesInHiliteEditor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderSpanTitlesInHiliteEditor:" + t.getMessage() + "\n";
        }
        try {
            s.showHeaderSpanTitlesInSortEditor = getAttributeAsString("showHeaderSpanTitlesInSortEditor");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHeaderSpanTitlesInSortEditor:" + t.getMessage() + "\n";
        }
        try {
            s.showHilitesInGroupSummary = getAttributeAsString("showHilitesInGroupSummary");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHilitesInGroupSummary:" + t.getMessage() + "\n";
        }
        try {
            s.showHover = getAttributeAsString("showHover");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHover:" + t.getMessage() + "\n";
        }
        try {
            s.showHoverComponents = getAttributeAsString("showHoverComponents");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showHoverComponents:" + t.getMessage() + "\n";
        }
        try {
            s.showInitialDragHandles = getAttributeAsString("showInitialDragHandles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showInitialDragHandles:" + t.getMessage() + "\n";
        }
        try {
            s.showPartialSelection = getAttributeAsString("showPartialSelection");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showPartialSelection:" + t.getMessage() + "\n";
        }
        try {
            s.showRecordComponents = getAttributeAsString("showRecordComponents");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRecordComponents:" + t.getMessage() + "\n";
        }
        try {
            s.showRollOver = getAttributeAsString("showRollOver");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRollOver:" + t.getMessage() + "\n";
        }
        try {
            s.showRollOverCanvas = getAttributeAsString("showRollOverCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRollOverCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showRollOverInExpansion = getAttributeAsString("showRollOverInExpansion");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRollOverInExpansion:" + t.getMessage() + "\n";
        }
        try {
            s.showRollUnderCanvas = getAttributeAsString("showRollUnderCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRollUnderCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showRowNumbers = getAttributeAsString("showRowNumbers");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showRowNumbers:" + t.getMessage() + "\n";
        }
        try {
            s.showSelectedRollOverCanvas = getAttributeAsString("showSelectedRollOverCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSelectedRollOverCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showSelectedRollUnderCanvas = getAttributeAsString("showSelectedRollUnderCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSelectedRollUnderCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showSelectedStyle = getAttributeAsString("showSelectedStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSelectedStyle:" + t.getMessage() + "\n";
        }
        try {
            s.showSelectionCanvas = getAttributeAsString("showSelectionCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSelectionCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showSelectionUnderCanvas = getAttributeAsString("showSelectionUnderCanvas");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSelectionUnderCanvas:" + t.getMessage() + "\n";
        }
        try {
            s.showSortArrow = getAttributeAsString("showSortArrow");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSortArrow:" + t.getMessage() + "\n";
        }
        try {
            s.showSortNumerals = getAttributeAsString("showSortNumerals");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showSortNumerals:" + t.getMessage() + "\n";
        }
        try {
            s.showTreeColumnPicker = getAttributeAsString("showTreeColumnPicker");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.showTreeColumnPicker:" + t.getMessage() + "\n";
        }
        try {
            s.shrinkForFreeze = getAttributeAsString("shrinkForFreeze");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.shrinkForFreeze:" + t.getMessage() + "\n";
        }
        try {
            s.singleCellValueProperty = getAttributeAsString("singleCellValueProperty");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.singleCellValueProperty:" + t.getMessage() + "\n";
        }
        try {
            s.skinImgDir = getAttributeAsString("skinImgDir");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.skinImgDir:" + t.getMessage() + "\n";
        }
        try {
            s.skipLineBreaks = getAttributeAsString("skipLineBreaks");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.skipLineBreaks:" + t.getMessage() + "\n";
        }
        try {
            s.sortArrowMenuButtonSpaceOffset = getAttributeAsString("sortArrowMenuButtonSpaceOffset");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortArrowMenuButtonSpaceOffset:" + t.getMessage() + "\n";
        }
        try {
            s.sortAscendingImage = getSortAscendingImage();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortAscendingImage:" + t.getMessage() + "\n";
        }
        try {
            s.sortBinaryByFileName = getAttributeAsString("sortBinaryByFileName");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortBinaryByFileName:" + t.getMessage() + "\n";
        }
        try {
            s.sortByGroupFirst = getAttributeAsString("sortByGroupFirst");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortByGroupFirst:" + t.getMessage() + "\n";
        }
        try {
            s.sortDescendingImage = getSortDescendingImage();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortDescendingImage:" + t.getMessage() + "\n";
        }
        try {
            s.sortDirection = getAttributeAsString("sortDirection");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortDirection:" + t.getMessage() + "\n";
        }
        try {
            s.sortEditorSpanTitleSeparator = getAttributeAsString("sortEditorSpanTitleSeparator");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortEditorSpanTitleSeparator:" + t.getMessage() + "\n";
        }
        try {
            s.sorterButtonTitle = getAttributeAsString("sorterButtonTitle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sorterButtonTitle:" + t.getMessage() + "\n";
        }
        try {
            s.sortFieldAscendingText = getAttributeAsString("sortFieldAscendingText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortFieldAscendingText:" + t.getMessage() + "\n";
        }
        try {
            s.sortFieldDescendingText = getAttributeAsString("sortFieldDescendingText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortFieldDescendingText:" + t.getMessage() + "\n";
        }
        try {
            s.sortNumeralMenuButtonSpaceOffset = getAttributeAsString("sortNumeralMenuButtonSpaceOffset");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortNumeralMenuButtonSpaceOffset:" + t.getMessage() + "\n";
        }
        try {
            s.sortNumeralStyle = getAttributeAsString("sortNumeralStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortNumeralStyle:" + t.getMessage() + "\n";
        }
        try {
            s.sortState = getAttributeAsString("sortState");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.sortState:" + t.getMessage() + "\n";
        }
        try {
            s.spannedHeaderBaseStyle = getAttributeAsString("spannedHeaderBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.spannedHeaderBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.stopOnErrors = getAttributeAsString("stopOnErrors");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.stopOnErrors:" + t.getMessage() + "\n";
        }
        try {
            s.styleName = getAttributeAsString("styleName");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.styleName:" + t.getMessage() + "\n";
        }
        try {
            s.summaryRowCriteria = getSummaryRowCriteria();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.summaryRowCriteria:" + t.getMessage() + "\n";
        }
        try {
            s.summaryRowDataSource = getSummaryRowDataSource();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.summaryRowDataSource:" + t.getMessage() + "\n";
        }
        try {
            s.summaryRowHeight = getAttributeAsString("summaryRowHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.summaryRowHeight:" + t.getMessage() + "\n";
        }
        try {
            s.summaryRowStyle = getAttributeAsString("summaryRowStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.summaryRowStyle:" + t.getMessage() + "\n";
        }
        try {
            s.tallBaseStyle = getAttributeAsString("tallBaseStyle");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.tallBaseStyle:" + t.getMessage() + "\n";
        }
        try {
            s.touchScrollRedrawDelay = getAttributeAsString("touchScrollRedrawDelay");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.touchScrollRedrawDelay:" + t.getMessage() + "\n";
        }
        try {
            s.trackerImage = getTrackerImage();
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.trackerImage:" + t.getMessage() + "\n";
        }
        try {
            s.unfreezeFieldText = getAttributeAsString("unfreezeFieldText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.unfreezeFieldText:" + t.getMessage() + "\n";
        }
        try {
            s.ungroupText = getAttributeAsString("ungroupText");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.ungroupText:" + t.getMessage() + "\n";
        }
        try {
            s.unremoveIcon = getAttributeAsString("unremoveIcon");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.unremoveIcon:" + t.getMessage() + "\n";
        }
        try {
            s.useAdvancedCriteria = getAttributeAsString("useAdvancedCriteria");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useAdvancedCriteria:" + t.getMessage() + "\n";
        }
        try {
            s.useAdvancedFieldPicker = getAttributeAsString("useAdvancedFieldPicker");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useAdvancedFieldPicker:" + t.getMessage() + "\n";
        }
        try {
            s.useCellRollOvers = getAttributeAsString("useCellRollOvers");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useCellRollOvers:" + t.getMessage() + "\n";
        }
        try {
            s.useCopyPasteShortcuts = getAttributeAsString("useCopyPasteShortcuts");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useCopyPasteShortcuts:" + t.getMessage() + "\n";
        }
        try {
            s.useRemoteValidators = getAttributeAsString("useRemoteValidators");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useRemoteValidators:" + t.getMessage() + "\n";
        }
        try {
            s.useRowSpanStyling = getAttributeAsString("useRowSpanStyling");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.useRowSpanStyling:" + t.getMessage() + "\n";
        }
        try {
            s.validateByCell = getAttributeAsString("validateByCell");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.validateByCell:" + t.getMessage() + "\n";
        }
        try {
            s.validateOnChange = getAttributeAsString("validateOnChange");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.validateOnChange:" + t.getMessage() + "\n";
        }
        try {
            s.valueIconHeight = getAttributeAsString("valueIconHeight");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.valueIconHeight:" + t.getMessage() + "\n";
        }
        try {
            s.valueIconLeftPadding = getAttributeAsString("valueIconLeftPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.valueIconLeftPadding:" + t.getMessage() + "\n";
        }
        try {
            s.valueIconRightPadding = getAttributeAsString("valueIconRightPadding");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.valueIconRightPadding:" + t.getMessage() + "\n";
        }
        try {
            s.valueIconSize = getAttributeAsString("valueIconSize");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.valueIconSize:" + t.getMessage() + "\n";
        }
        try {
            s.valueIconWidth = getAttributeAsString("valueIconWidth");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.valueIconWidth:" + t.getMessage() + "\n";
        }
        try {
            s.viewState = getAttributeAsString("viewState");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.viewState:" + t.getMessage() + "\n";
        }
        try {
            s.virtualScrolling = getAttributeAsString("virtualScrolling");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.virtualScrolling:" + t.getMessage() + "\n";
        }
        try {
            s.waitForSave = getAttributeAsString("waitForSave");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.waitForSave:" + t.getMessage() + "\n";
        }
        try {
            s.warnOnRemoval = getAttributeAsString("warnOnRemoval");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.warnOnRemoval:" + t.getMessage() + "\n";
        }
        try {
            s.warnOnRemovalMessage = getAttributeAsString("warnOnRemovalMessage");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.warnOnRemovalMessage:" + t.getMessage() + "\n";
        }
        try {
            s.warnOnUnmappedValueFieldChange = getAttributeAsString("warnOnUnmappedValueFieldChange");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.warnOnUnmappedValueFieldChange:" + t.getMessage() + "\n";
        }
        try {
            s.wrapCells = getAttributeAsString("wrapCells");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.wrapCells:" + t.getMessage() + "\n";
        }
        try {
            s.wrapHeaderSpanTitles = getAttributeAsString("wrapHeaderSpanTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.wrapHeaderSpanTitles:" + t.getMessage() + "\n";
        }
        try {
            s.wrapHeaderTitles = getAttributeAsString("wrapHeaderTitles");
        } catch (Throwable t) {
            s.logicalStructureErrors += "ListGrid.wrapHeaderTitles:" + t.getMessage() + "\n";
        }
        return s;
    }

    /**
     * Getter implementing the {@link com.smartgwt.client.core.LogicalStructure} interface,
     * which supports Eclipse's logical structure debugging facility.
     */
    public LogicalStructureObject getLogicalStructure() {
        ListGridLogicalStructure s = new ListGridLogicalStructure();
        setLogicalStructure(s);
        return s;
    }
}
